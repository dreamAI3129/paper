<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js snort-dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Snort 3 Rule Writing Guide</title>
        
        <meta name="robots" content="noindex">
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="css2?family=Nunito+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "snort-dark" : "snort-dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('snort-dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="welcome.htm">Snort 3 Rule Writing Guide</a></li><li class="chapter-item expanded "><a href="intro.htm">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Using Snort 3</li><li class="chapter-item expanded "><a href="start/index.htm">Getting Started with Snort 3</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/installation.htm">Installing Snort</a></li><li class="chapter-item expanded "><a href="start/running.htm">Using Snort</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/help.htm">Command Line Basics</a></li><li class="chapter-item expanded "><a href="start/inspection.htm">Reading Traffic</a></li><li class="chapter-item expanded "><a href="start/configuration.htm">Configuration</a></li><li class="chapter-item expanded "><a href="start/rules.htm">Rules</a></li><li class="chapter-item expanded "><a href="start/wizard_binder.htm">Wizard and Binder</a></li><li class="chapter-item expanded "><a href="start/tweaks_scripts.htm">Tweaks and Scripts</a></li><li class="chapter-item expanded "><a href="start/tracing.htm">Trace Modules</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Writing Snort Rules</li><li class="chapter-item expanded "><a href="rules/index.htm">The Basics</a></li><li class="chapter-item expanded "><a href="rules/headers/index.htm">Rule Headers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rules/headers/actions.htm">Rule Actions</a></li><li class="chapter-item expanded "><a href="rules/headers/protocols.htm">Protocols</a></li><li class="chapter-item expanded "><a href="rules/headers/ips.htm">IP Addresses</a></li><li class="chapter-item expanded "><a href="rules/headers/ports.htm">Port Numbers</a></li><li class="chapter-item expanded "><a href="rules/headers/directions.htm">Direction Operators</a></li></ol></li><li class="chapter-item expanded "><a href="rules/headers/new_header_types.htm">New Rule Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rules/headers/service_rules.htm">Service Rules</a></li><li class="chapter-item expanded "><a href="rules/headers/file_rules.htm">File Rules</a></li><li class="chapter-item expanded "><a href="rules/headers/file_id_rules.htm">File Identification Rules</a></li></ol></li><li class="chapter-item expanded "><a href="rules/options/index.htm">Rule Options</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rules/options/key.htm">Rule Option Syntax Key</a></li><li class="chapter-item expanded "><a href="rules/options/general/index.htm">General Rule Options</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rules/options/general/msg.htm">msg</a></li><li class="chapter-item expanded "><a href="rules/options/general/reference.htm">reference</a></li><li class="chapter-item expanded "><a href="rules/options/general/gid.htm">gid</a></li><li class="chapter-item expanded "><a href="rules/options/general/sid.htm">sid</a></li><li class="chapter-item expanded "><a href="rules/options/general/rev.htm">rev</a></li><li class="chapter-item expanded "><a href="rules/options/general/classtype.htm">classtype</a></li><li class="chapter-item expanded "><a href="rules/options/general/priority.htm">priority</a></li><li class="chapter-item expanded "><a href="rules/options/general/metadata.htm">metadata</a></li><li class="chapter-item expanded "><a href="rules/options/general/service.htm">service</a></li><li class="chapter-item expanded "><a href="rules/options/general/rem.htm">rem</a></li><li class="chapter-item expanded "><a href="rules/options/general/file_meta.htm">file_meta</a></li></ol></li><li class="chapter-item expanded "><a href="rules/options/payload/index.htm">Payload Detection Rule Options</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rules/options/payload/content.htm">content</a></li><li class="chapter-item expanded "><a href="rules/options/payload/fast_pattern.htm">fast_pattern</a></li><li class="chapter-item expanded "><a href="rules/options/payload/nocase.htm">nocase</a></li><li class="chapter-item expanded "><a href="rules/options/payload/oddw.htm">offset, depth, distance, and within</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/index.htm">HTTP Specific Options</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rules/options/payload/http/uri.htm">http_uri and http_raw_uri</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/header.htm">http_header and http_raw_header</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/cookie.htm">http_cookie and http_raw_cookie</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/body.htm">http_client_body and http_raw_body</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/param.htm">http_param</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/method.htm">http_method</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/version.htm">http_version</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/stat_code.htm">http_stat_code</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/stat_msg.htm">http_stat_msg</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/raw_req-raw_status.htm">http_raw_request and http_raw_status</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/trailer.htm">http_trailer and http_raw_trailer</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/true_ip.htm">http_true_ip</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/version_match.htm">http_version_match</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/num_headers.htm">http_num_headers</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/num_trailers.htm">http_num_trailers</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/num_cookies.htm">http_num_cookies</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/header_test.htm">http_header_test</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/trailer_test.htm">http_trailer_test</a></li><li class="chapter-item expanded "><a href="rules/options/payload/http/req_resp_detection.htm">Combining Request and Response Detection</a></li></ol></li><li class="chapter-item expanded "><a href="rules/options/payload/bufferlen.htm">bufferlen</a></li><li class="chapter-item expanded "><a href="rules/options/payload/isdataat.htm">isdataat</a></li><li class="chapter-item expanded "><a href="rules/options/payload/dsize.htm">dsize</a></li><li class="chapter-item expanded "><a href="rules/options/payload/pcre.htm">pcre</a></li><li class="chapter-item expanded "><a href="rules/options/payload/regex.htm">regex</a></li><li class="chapter-item expanded "><a href="rules/options/payload/pkt_data.htm">pkt_data</a></li><li class="chapter-item expanded "><a href="rules/options/payload/raw_data.htm">raw_data</a></li><li class="chapter-item expanded "><a href="rules/options/payload/file_data.htm">file_data</a></li><li class="chapter-item expanded "><a href="rules/options/payload/js_data.htm">js_data</a></li><li class="chapter-item expanded "><a href="rules/options/payload/vba_data.htm">vba_data</a></li><li class="chapter-item expanded "><a href="rules/options/payload/base64.htm">base64_decode and base64_data</a></li><li class="chapter-item expanded "><a href="rules/options/payload/byte_extract.htm">byte_extract</a></li><li class="chapter-item expanded "><a href="rules/options/payload/byte_test.htm">byte_test</a></li><li class="chapter-item expanded "><a href="rules/options/payload/byte_math.htm">byte_math</a></li><li class="chapter-item expanded "><a href="rules/options/payload/byte_jump.htm">byte_jump</a></li><li class="chapter-item expanded "><a href="rules/options/payload/ber.htm">ber_data and ber_skip</a></li><li class="chapter-item expanded "><a href="rules/options/payload/ssl.htm">ssl_state and ssl_version</a></li><li class="chapter-item expanded "><a href="rules/options/payload/dce.htm">DCE Specific Options</a></li><li class="chapter-item expanded "><a href="rules/options/payload/sip.htm">SIP Specific Options</a></li><li class="chapter-item expanded "><a href="rules/options/payload/sd_pattern.htm">sd_pattern</a></li><li class="chapter-item expanded "><a href="rules/options/payload/cvs.htm">cvs</a></li><li class="chapter-item expanded "><a href="rules/options/payload/hash.htm">md5, sha256, and sha512</a></li><li class="chapter-item expanded "><a href="rules/options/payload/gtp.htm">GTP Specific Options</a></li><li class="chapter-item expanded "><a href="rules/options/payload/dnp3.htm">DNP3 Specific Options</a></li><li class="chapter-item expanded "><a href="rules/options/payload/cip.htm">CIP Specific Options</a></li><li class="chapter-item expanded "><a href="rules/options/payload/iec104.htm">IEC 104 Specific Options</a></li><li class="chapter-item expanded "><a href="rules/options/payload/mms.htm">MMS Specific Options</a></li><li class="chapter-item expanded "><a href="rules/options/payload/modbus.htm">Modbus Specific Options</a></li><li class="chapter-item expanded "><a href="rules/options/payload/s7commplus.htm">S7CommPlus Specific Options</a></li></ol></li><li class="chapter-item expanded "><a href="rules/options/non_payload/index.htm">Non-Payload Detection Rule Options</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rules/options/non_payload/fragoffset.htm">fragoffset</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/ttl.htm">ttl</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/tos.htm">tos</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/id.htm">id</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/ipopts.htm">ipopts</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/fragbits.htm">fragbits</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/ip_proto.htm">ip_proto</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/flags.htm">flags</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/flow.htm">flow</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/flowbits.htm">flowbits</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/file_type.htm">file_type</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/seq.htm">seq</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/ack.htm">ack</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/window.htm">window</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/itype.htm">itype</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/icode.htm">icode</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/icmp_id.htm">icmp_id</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/icmp_seq.htm">icmp_seq</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/rpc.htm">rpc</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/stream_reassemble.htm">stream_reassemble</a></li><li class="chapter-item expanded "><a href="rules/options/non_payload/stream_size.htm">stream_size</a></li></ol></li><li class="chapter-item expanded "><a href="rules/options/post/index.htm">Post-Detection Rule Options</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rules/options/post/detection_filter.htm">detection_filter</a></li><li class="chapter-item expanded "><a href="rules/options/post/replace.htm">replace</a></li><li class="chapter-item expanded "><a href="rules/options/post/tag.htm">tag</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Miscellaneous Information</li><li class="chapter-item expanded "><a href="misc/shared-object-rules.htm">Shared Object Rules</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="snort-light">Snort Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="snort-dark">Snort Dark</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Snort 3 Rule Writing Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.htm" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="snort-3-rule-writing-guide"><a class="header" href="#snort-3-rule-writing-guide">Snort 3 Rule Writing Guide</a></h1>
<p><em>by the Cisco Talos Detection Response Team</em> </p>
<p><img src="pics/Snort-3-logo_v.png" alt="Snort 3 logo"></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Snort 3 brings many new features, improvements, and detection capabilities to the Snort engine, as well as updates to the Snort rule language syntax that improve the rule-writing process. This <em>Snort 3 Rule Writing Guide</em> elucidates all these new enhancements and contains detailed documentation for all the different rule options available in Snort 3, in a format that is easy to understand and use.</p>
<p>This manual is meant for new and experienced Snort rule-writers alike, and it is intended to <em>supplement</em> the <a href="https://github.com/snort3/snort3#documentation">documentation provided in the official Snort 3 repository</a>,  focusing primarily on the rule-writing process. Each rule option has its own page that describes its functionality, its specific syntax, as well as a few examples to show how the given option might be used in a Snort rule. Additionally, the manual also includes a few overview pages that cover the basic steps needed to help get Snort 3 up and running. We expect to expand on this section in the future.</p>
<p>As Snort 3 continues to evolve, this manual will too. We will provide timely updates to the manual whenever necessary, to keep the greater Snort community abreast of any recent changes.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-snort-3"><a class="header" href="#getting-started-with-snort-3">Getting Started with Snort 3</a></h1>
<p>The section will walk you through the basics of building and running Snort 3, and also help get you started with all things Snort 3. Specifically, this section contains information on building Snort 3, running Snort 3 for the first time, configuring Snort's detection engines, inspecting network traffic with Snort, extending Snort's functionality with &quot;tweaks&quot; and &quot;scripts&quot;, and lastly tracing Snort.</p>
<p>While not an exhaustive guide on installing and running Snort 3, this section does provide a foundation that can be built upon to learn and take advantage of the more advanced features that Snort 3 has to offer.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="snort-3-installation"><a class="header" href="#snort-3-installation">Snort 3 Installation</a></h1>
<h2 id="required-packages"><a class="header" href="#required-packages">Required Packages</a></h2>
<p>The very first thing to do is make sure all necessary dependencies are installed. The following is a list of required packages:</p>
<ul>
<li>cmake to build from source</li>
<li>The Snort 3 libdaq for packet IO</li>
<li>dnet for network utility functions</li>
<li>flex &gt;= 2.6.0 for JavaScript syntax parsing</li>
<li>g++ &gt;= 5 or other C++14 compiler</li>
<li>hwloc for CPU affinity management</li>
<li>LuaJIT for configuration and scripting</li>
<li>OpenSSL for SHA and MD5 file signatures, the protected_content rule option, and SSL service detection</li>
<li>pcap for tcpdump style logging</li>
<li>pcre for regular expression pattern matching</li>
<li>pkgconfig to locate build dependencies</li>
<li>zlib for decompression</li>
</ul>
<p>Information on where to download each of these <em>required</em> packages can be found here: <a href="https://github.com/snort3/snort3/blob/master/doc/user/tutorial.txt#L6">https://github.com/snort3/snort3/blob/master/doc/user/tutorial.txt#L6</a>.</p>
<h2 id="optional-packages"><a class="header" href="#optional-packages">Optional Packages</a></h2>
<p>There are also a few optional packages that can be installed to take advantage of some of Snort's optional features. These include:</p>
<ul>
<li>asciidoc to build the HTML manual</li>
<li>cpputest to run additional unit tests with make check</li>
<li>dblatex to build the PDF manual included with Snort 3 installs</li>
<li>flatbuffers for enabling the flatbuffers serialization format</li>
<li>hyperscan &gt;= 4.4.0 to build the new regex and sd_pattern rule options and hyperscan search engine.</li>
<li>iconv for converting UTF16-LE filenames to UTF8 (usually included in glibc)</li>
<li>libunwind to attempt to dump a somewhat readable backtrace when a fatal signal is received</li>
<li>lzma &gt;= 5.1.2 for decompression of SWF and PDF files</li>
<li>safec &gt;= 3.5 for runtime bounds checks on certain legacy C-library calls</li>
<li>source-highlight to generate the dev guide</li>
<li>w3m from to build the plain text manual</li>
<li>uuid from uuid-dev package for unique identifiers</li>
</ul>
<p>Information on where to download each of these <em>optional</em> packages can be found here: <a href="https://github.com/snort3/snort3/blob/master/doc/user/tutorial.txt#L36">https://github.com/snort3/snort3/blob/master/doc/user/tutorial.txt#L36</a>.</p>
<h2 id="installing-libdaq"><a class="header" href="#installing-libdaq">Installing LibDAQ</a></h2>
<p>We now need to install the Snort 3 LibDAQ, which provides an abstraction layer for communicating with a data source (such as a network interface).</p>
<p>If you have LibDAQ already installed for Snort 2 and want to install a DAQ just for Snort 3, or if you want to install LibDAQ in a custom location, you can change the DAQ install location with the <code>--prefix</code> option when configuring: <code>./configure --prefix=/usr/local/lib/daq_s3</code>.</p>
<p>To show this in action, first clone the LibDAQ repository from GitHub:</p>
<pre><code>$ git clone https://github.com/snort3/libdaq.git
</code></pre>
<p>Then, run the following commands to generate the configure script, configure with a specified prefix, build, and lastly install:</p>
<pre><code>$ cd libdaq
$ ./bootstrap
$ ./configure --prefix=/usr/local/lib/daq_s3
$ make install
</code></pre>
<p>After installing libdaq, you must then run <code>ldconfig</code> to configure your system's dynamic linker run-time bindings. However, if you have installed the DAQ in a nonstandard location, you'll first need to tell your system where to find the new shared libraries. One common solution is to create a file in the <code>/etc/ld.so.conf.d/</code> directory that points to where those libraries are located:</p>
<pre><code>$ cat /etc/ld.so.conf.d/libdaq3.conf
/usr/local/lib/daq_s3/lib/
</code></pre>
<p>Once ready you may proceed with the <code>ldconfig</code> command to configure the run-time bindings:</p>
<pre><code>$ sudo ldconfig
</code></pre>
<h2 id="building-snort"><a class="header" href="#building-snort">Building Snort</a></h2>
<p>After all dependencies have been installed, it is time to build Snort. </p>
<p>To do this, first clone the Snort 3 repository:</p>
<pre><code>$ git clone https://github.com/snort3/snort3.git
</code></pre>
<p>You can choose to install Snort in the system-default directories, or you can specify to install it in some other directory with the <code>--prefix=&lt;path&gt;</code> command line argument.</p>
<pre><code>$ export my_path=/path/to/snorty
$ mkdir -p $my_path
$ cd snort3
$ ./configure_cmake.sh --prefix=$my_path 
</code></pre>
<p>Additionally, if the LibDAQ has been installed in a non-standard or custom location, then you must include the <code>--with-daq-libraries</code> and <code>--with-daq-includes</code> arguments and set them accordingly.</p>
<pre><code>$ ./configure_cmake.sh --prefix=$my_path \
                       --with-daq-includes=/usr/local/lib/daq_s3/include/ \
                       --with-daq-libraries=/usr/local/lib/daq_s3/lib/
</code></pre>
<p>There are many more CMake configuration options to choose from (like enabling debug mode, for example), and the full list of options can be seen by running the following command:</p>
<pre><code>$ ./configure_cmake.sh --help
</code></pre>
<p>Once you've configured CMake to your liking and the build files are ready to go, it's time to compile and install Snort. To do this, <code>cd</code> to the newly-created <code>build</code> directory, and then compile and install:</p>
<pre><code>$ cd build
$ make -j $(nproc)
$ make install
</code></pre>
<p>If all goes well, run <code>snort -V</code> at the command line to verify successful installation.</p>
<pre><code>$ $my_path/bin/snort -V

   ,,_     -*&gt; Snort++ &lt;*-
  o&quot;  )~   Version 3.1.36.0
   ''''    By Martin Roesch &amp; The Snort Team
           http://snort.org/contact#team
           Copyright (C) 2014-2022 Cisco and/or its affiliates. All rights reserved.
           Copyright (C) 1998-2013 Sourcefire, Inc., et al.
           Using DAQ version 3.0.6
           Using LuaJIT version 2.1.0-beta3
           Using OpenSSL 1.1.1q  5 Jul 2022
           Using libpcap version 1.10.1 (with TPACKET_V3)
           Using PCRE version 8.45 2021-06-15
           Using ZLIB version 1.2.12
           Using LZMA version 5.2.6
</code></pre>
<p>Lastly, verify that your installation has the appropriate DAQs available to it:</p>
<pre><code>$ $my_path/bin/snort --daq-list
Available DAQ modules:
afpacket(v7): live inline multi unpriv
 Variables:
  buffer_size_mb &lt;arg&gt; - Packet buffer space to allocate in megabytes
  debug - Enable debugging output to stdout
  fanout_type &lt;arg&gt; - Fanout loadbalancing method
  fanout_flag &lt;arg&gt; - Fanout loadbalancing option
  use_tx_ring - Use memory-mapped TX ring
…
</code></pre>
<p>If, however, you get <code>No available DAQ modules (try adding directories with --daq-dir).</code>, then you will need to specify <code>--daq-dir</code> as the error points out:</p>
<pre><code>$ $my_path/bin/snort --daq-dir /usr/local/lib/daq_s3/lib/daq --daq-list
</code></pre>
<p>If that's the case, you can create an &quot;alias&quot; for your Snort command so that you don't have to specify <code>--daq-dir</code> each time you want to invoke Snort:</p>
<pre><code class="language-sh">alias snort='/path/to/bin/snort --daq-dir /usr/local/lib/daq_s3/lib/daq'
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="using-snort"><a class="header" href="#using-snort">Using Snort</a></h1>
<p>Snort is an incredibly powerful multipurpose engine. In this section, we'll go over the basics of using Snort on the command line, briefly discuss how to set and tweak one's configuration, and lastly go over how to use Snort to detect and prevent attacks.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="command-line-basics"><a class="header" href="#command-line-basics">Command Line Basics</a></h1>
<p>Running Snort on the command line is easy, but the number of arguments available might be overwhelming at first. So let's start with the basics.</p>
<p>All Snort commands start with <code>snort</code>, and running this command by itself will show basic usage instructions:</p>
<pre><code>$ snort
usage:
    snort -?: list options
    snort -V: output version
    snort --help: help summary
    snort [-options] -c conf [-T]: validate conf
    snort [-options] -c conf -i iface: process live
    snort [-options] -c conf -r pcap: process readback
</code></pre>
<p>Fortunately, Snort 3 provides a very robust set of help commands that detail just about every aspect of the engine. </p>
<p>To see the main help &quot;directory&quot;, run the following command:</p>
<pre><code>$ snort --help

Snort has several options to get more help:

-? list command line options (same as --help)
--help this overview of help
--help-commands [&lt;module prefix&gt;] output matching commands
--help-config [&lt;module prefix&gt;] output matching config options
--help-counts [&lt;module prefix&gt;] output matching peg counts
--help-limits print the int upper bounds denoted by max*
--help-module &lt;module&gt; output description of given module
--help-modules list all available modules with brief help
…
</code></pre>
<p>As we can see from the output, Snort contains separate help pages for the different parts of the Snort engine, and these subpages can be used to get granular help information about a particular component. Shown below are a few of these help subpages.</p>
<p>Listing all available Snort modules:</p>
<pre><code>$ snort --list-modules
</code></pre>
<p>Getting help on a specific Snort module:</p>
<pre><code>$ snort --help-module http_inspect 
</code></pre>
<p>Getting help on a specific rule option module:</p>
<pre><code>$ snort --help-module http_uri
</code></pre>
<p>Listing command line options available:</p>
<pre><code>$ snort -?
</code></pre>
<p>Getting help on the &quot;-A&quot; command line option:</p>
<pre><code>$ snort --help-options A
</code></pre>
<p>Getting help with a specific configuration setting:</p>
<pre><code>$ snort --help-config | grep http
</code></pre>
<p>Outputting help on &quot;rule&quot; options in an AsciiDoc format:</p>
<pre><code>$ snort --markup --help-options rule
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="reading-traffic"><a class="header" href="#reading-traffic">Reading Traffic</a></h1>
<p>Snort is at its best when it has network traffic to inspect, and Snort can perform network inspection in a few different ways. This includes (but is not limited to) reading traffic directly from a packet capture, running passively on a network interface to sniff traffic, and testing Snort's inline injection capabilities locally. Before we can dive into that, we first need to go over how to provide Snort with traffic to inspect.</p>
<h2 id="specifying-libdaq-directory"><a class="header" href="#specifying-libdaq-directory">Specifying LibDAQ directory</a></h2>
<p>First things first, it's important to make sure the Snort 3 install knows where to find the appropriate LibDAQ that we installed earlier. LibDAQ is the &quot;Data Acquisition Library&quot;, and at a high-level, it's an abstraction layer used by &quot;modules&quot; to communicate with both hardware and software network data sources. For example, one DAQ module installed by default is the <code>pcap</code> module that is built around around the libpcap library to listen on network interfaces or read from <code>.pcap</code> files.</p>
<p>If users have Snort both 2 and Snort 3 installed on a single system, then that means they also have two LibDAQ versions installed, one for Snort 2 and another Snort 3. Therefore when using Snort 3 on the command line, users must explicitly set the <code>--daq-dir</code> option to tell Snort where to find the appropriate modules. </p>
<p>For example, if the Snort 3 LibDAQ is installed in <code>/usr/local/lib/daq_s3/</code>, then users will want to set <code>--daq-dir</code> to <code>/usr/local/lib/daq_s3/lib/daq</code>:</p>
<pre><code>$ snort --daq-dir /usr/local/lib/daq_s3/lib/daq
</code></pre>
<p>Users can run <code>snort --daq-list</code> to see which DAQ modules are available for use. </p>
<h2 id="reading-packet-captures"><a class="header" href="#reading-packet-captures">Reading Packet Captures</a></h2>
<p>The simplest way to see Snort in action is to run it against a packet capture file. Simply pass in a pcap file name to the <code>-r</code> option on the command line, and Snort will process it accordingly:</p>
<pre><code>$ snort -r get.pcap
</code></pre>
<p>If successful, Snort will print out basic information about the pcap file that was just read, including details such as the number of packets and the protocols detected.</p>
<p>Users can also run Snort against an entire directory of pcaps with the <code>--pcap-dir</code> option. If that directory contains files other pcaps, then the <code>--pcap-filter</code> option can be used to tell Snort <em>which</em> of those files to process. For instance:</p>
<pre><code>$ snort --pcap-dir /path/to/pcap/dir --pcap-filter '*.pcap'
</code></pre>
<h2 id="running-snort-on-network-interfaces"><a class="header" href="#running-snort-on-network-interfaces">Running Snort on Network Interfaces</a></h2>
<p>Snort can also listen on active network interfaces, and specifying it to do so is done with the <code>-i</code> option followed by the interface names to run on. The following command, for example, runs Snort on the <code>eth0</code> network interface:</p>
<pre><code>$ snort -i eth0
</code></pre>
<h3 id="modes-of-operation"><a class="header" href="#modes-of-operation">Modes of operation</a></h3>
<p>With certain DAQ modules, Snort is able to utilize two different modes of operation: <strong>passive</strong> and <strong>inline</strong>. Passive mode gives Snort the ability to observe and detect traffic on a network interface, but it prevents outright <em>blocking</em> of traffic. Inline mode on the other hand, <em>does</em> give Snort the ability to block traffic if a particular packet warrants such an event.</p>
<p>Snort will infer the particular mode of operation based on the options used at the command line. For example, reading from a pcap file with the <code>-r</code> option or listening on an interface with <code>-i</code> will cause Snort to run in passive mode by default. If the DAQ supports inline, however, then users can specify the <code>-Q</code> flag to run Snort inline.</p>
<p>One DAQ module that supports inline mode is <code>afpacket</code>, which is a module that gives Snort access to packets received on Linux network devices. </p>
<p>Using the <code>afpacket</code> module inline requires specifying a pair of network interfaces in the <code>-i</code> command line option, where each pair is two interface names separated by a colon character. </p>
<pre><code>$ snort -Q --daq afpacket -i &quot;eth0:eth1&quot;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Once we've got Snort set up to process traffic, it's now time to tell Snort <em>how</em> to process traffic, and this is done through configuration. Snort configuration handles things like the setting of global variables, the different modules to enable or disable, performance settings, event logging policies, the paths to specific rules files to enable, and much more.</p>
<p>Snort 3 configuration is now all done in Lua, and these configuration options can be supplied to Snort in three different ways: via the command line, with a single Lua configuration file, or with multiple Lua configuration files.</p>
<h2 id="configuration-files"><a class="header" href="#configuration-files">Configuration Files</a></h2>
<p>There are <strong>many</strong> different configuration options that can be tuned in Snort, but luckily open-source Snort 3 comes with a set of standard configuration files that help get Snort users up and running quickly. These default files are located in the <code>lua/</code> directory, and the <code>snort.lua</code> and <code>snort_defaults.lua</code> files present there make up what is considered to be the the base configuration. This default config is an excellent template to build upon, and it can be plugged right into Snort for immediate use.</p>
<h3 id="module-configuration"><a class="header" href="#module-configuration">Module configuration</a></h3>
<p>A big part of one's configuration is the enabling and tuning of Snort &quot;modules&quot;, which at a high level control how Snort processes and handles network traffic. Snort contains modules to decipher raw packets, perform traffic normalization, determine whether or not a specific action should be taken against a particular packet, and also control how events should be logged. Snort features eight different types of modules:</p>
<ul>
<li>Basic Modules -&gt; handle configuration for basic traffic and rule processing</li>
<li>Codec Modules -&gt; decode protocols and perform anomaly detection</li>
<li>Inspector Modules -&gt; analyze and process protocols</li>
<li>IPS Action Modules -&gt; enable custom actions that can be performed when an event occurs</li>
<li>IPS Option Modules -&gt; options set in Snort rules to set the detection parameters</li>
<li>Search Engine -&gt; perform pattern matching against packet data to determine which rules to evaluate</li>
<li>SO Rule Modules -&gt; perform detection not attainable with the existing IPS options</li>
<li>Logger Modules -&gt; control the output of events and packet data</li>
</ul>
<p>A list and brief description of all Snort 3 modules can be seen with the <code>--help-modules</code> command:</p>
<pre><code>$ snort --help-modules
</code></pre>
<p>Modules are enabled and configured in a configuration as Lua table literals. For example, the <code>stream_tcp</code> inspector module, which handles TCP flow tracking and stream normalization and reassembly, can enabled like so:</p>
<pre><code class="language-lua">stream_tcp = { }
</code></pre>
<p>If a module is initialized as an <em>empty</em> table, then that means the module is using its &quot;default&quot; settings. We can view these defaults with the <code>--help-config</code> argument:</p>
<pre><code>$ snort --help-config stream_tcp
int stream_tcp.flush_factor = 0: flush upon seeing a drop in segment size after given number of non-decreasing segments { 0:65535 }
int stream_tcp.max_window = 0: maximum allowed TCP window { 0:1073725440 }
int stream_tcp.overlap_limit = 0: maximum number of allowed overlapping segments per session { 0:max32 }
int stream_tcp.max_pdu = 16384: maximum reassembled PDU size { 1460:32768 }
bool stream_tcp.no_ack = false: received data is implicitly acked immediately
enum stream_tcp.policy = 'bsd': determines operating system characteristics like reassembly { 'first' | 'last' | 'linux' | 'old_linux' | 'bsd' | 'macos' | 'solaris' | 'irix' | 'hpux11' | 'hpux10' | 'windows' | 'win_2003' | 'vista' | 'proxy' }
bool stream_tcp.reassemble_async = true: queue data for reassembly before traffic is seen in both directions
int stream_tcp.require_3whs = -1: don't track midstream sessions after given seconds from start up; -1 tracks all { -1:max31 }
bool stream_tcp.show_rebuilt_packets = false: enable cmg like output of reassembled packets
int stream_tcp.queue_limit.max_bytes = 4194304: don't queue more than given bytes per session and direction, 0 = unlimited { 0:max32 }
int stream_tcp.queue_limit.max_segments = 3072: don't queue more than given segments per session and direction, 0 = unlimited { 0:max32 }
int stream_tcp.small_segments.count = 0: number of consecutive (in the received order) TCP small segments considered to be excessive (129:12) { 0:2048 }
int stream_tcp.small_segments.maximum_size = 0: minimum bytes for a TCP segment not to be considered small (129:12) { 0:2048 }
int stream_tcp.session_timeout = 180: session tracking timeout { 1:max31 }
bool stream_tcp.track_only = false: disable reassembly if true
</code></pre>
<p>This command outputs the different settings for the given module, a description of each setting, and valid values for each one. The <code>max_pdu</code> setting, for example, can be set to an integer between 1460 and 32768 (inclusive).</p>
<p>Entries in Lua table literals are effectively just key-value pairs. If we wanted to set <code>stream_tcp.max_pdu</code> to its max setting, we would simply add a table entry like so:</p>
<pre><code class="language-lua">stream_tcp = 
{ 
    max_pdu = 32768
}
</code></pre>
<p>Other entries follow the same format and are separated by commas.</p>
<p>The default <code>snort.lua</code> configuration file enables and configures many of the core modules relied upon by Snort, and users are encouraged to go through that file and learn about the different ones using the <code>--help-module</code> and <code>--help-config</code> Snort commands.</p>
<h3 id="passing-configuration-files-to-snort"><a class="header" href="#passing-configuration-files-to-snort">Passing configuration files to Snort</a></h3>
<p>Snort doesn't look for a specific configuration file by default, but you can pass one to it very easily with the <code>-c</code> argument: </p>
<pre><code>$ snort -c $my_path/lua/snort.lua
</code></pre>
<p>This command simply validates the supplied configuration file, and if everything is in order, the output will include a message that says &quot;Snort successfully validated the configuration&quot;.</p>
<h2 id="tuning-lua-configurations-via-the-command-line"><a class="header" href="#tuning-lua-configurations-via-the-command-line">Tuning Lua Configurations via the Command Line</a></h2>
<p>Sometimes rule writers will want to experiment with a specific configuration to see how it might affect detection. Fortunately, Snort 3 provides the ability to run one-off custom Lua configurations directly from the command line using the <code>--lua</code> flag followed by a string enclosed in quotes containing the specific Lua configuration (or configurations) to set.</p>
<p>For example, the following <code>--lua</code> command sets the <code>enable_builtin_rules</code> boolean from the <code>ips</code> module to <code>true</code>:</p>
<pre><code>$ snort -c $my_path/lua/snort.lua -R local.rules \
        --lua 'ips.enable_builtin_rules = true'
</code></pre>
<p>Note that the above <code>--lua</code> argument uses <em>dot notation</em> to <em>extend</em> any existing <code>ips</code> configuration present in one's Snort configuration file. However, users can also <em>override</em> a given module's configuration using <em>curly braces</em> instead of using dot notation.</p>
<p>The following argument, for example, overrides any existing <code>ips</code> configuration with the one specified:</p>
<pre><code>$ snort -c $my_path/lua/snort.lua -R local.rules \
        --lua 'ips = { enable_builtin_rules = true }'
</code></pre>
<p>This above example sets <code>ips</code> back to its default settings, but then also sets <code>enable_builtin_rules</code> to <code>true</code>.</p>
<h2 id="snort2lua"><a class="header" href="#snort2lua">Snort2Lua</a></h2>
<h3 id="converting-configuration-files"><a class="header" href="#converting-configuration-files">Converting configuration files</a></h3>
<p>For those that are coming from Snort 2 and have a working 2.x configuration file, building Snort 3 also creates a binary named <code>snort2lua</code>, which can take one's old Snort 2 configuration and output one that can be plugged into Snort 3.</p>
<p>Running this command is as easy as invoking the binary followed by a <code>-c</code> option that points to the Snort 2 configuration file:</p>
<pre><code>$ snort2lua -c snort.conf
</code></pre>
<p>If any errors occur during the conversion, they will be placed in a <code>snort.rej</code> file in the current working directory. Once all errors have been taken care of, <code>snort2lua</code> will output a <code>snort.lua</code> file that can then be passed directly to Snort 3.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="snort-rules"><a class="header" href="#snort-rules">Snort Rules</a></h1>
<p>At its core, Snort is an intrusion detection system (IDS) and an intrusion prevention system (IPS), which means that it has the capability to detect intrusions on a network, and also prevent them. A configuration tells Snort how to process network traffic. It is the <em>rules</em> that determine whether Snort acts on a particular packet.</p>
<p>Snort rules can be placed directly in one's Lua configuration file(s) via the <code>ips</code> module, but for the most part they will live in distinct <code>.rules</code> files that get &quot;included&quot;. For example, say we had a <code>malware.rules</code> file in the same directory as our Lua configuration file. We could &quot;include&quot; that rules file like so: </p>
<pre><code class="language-lua">ips = { include = 'malware.rules' }
</code></pre>
<p>If users want to include multiple <code>.rules</code> files, then they can do so like:</p>
<pre><code class="language-lua">ips = 
{
    rules = [[
        include /path/to/rulesfile1.rules
        include /path/to/rulesfile2.rules
        …
    ]]
}
</code></pre>
<p>Alternatively, a single rules file or a path to a rules directory can be passed directly to Snort on the command line. This is done either with the <code>-R</code> option for a single rules file or the <code>--rule-path</code> option to pass in a whole directory of rules files. This is convenient for when you need to verify or troubleshoot a rule or rules against a pcap.</p>
<p>For example, the below command will run all the rules present in <code>malware.rules</code> against the traffic in <code>bad.pcap</code>:</p>
<pre><code>$ snort -c $my_path/lua/snort.lua -R malware.rules -r bad.pcap
</code></pre>
<h2 id="generating-alerts"><a class="header" href="#generating-alerts">Generating Alerts</a></h2>
<p>The above command by default will output various statistics about the particular run. These include details about any identified applications, any detection events, types of services detected, and much more. The detection events will show <em>how many</em> alerts fired on the provided traffic, but sometimes we want to know more than that. </p>
<p>Snort provides a few different &quot;alert mode&quot; options that can be set on the command line to tweak the way alerts are displayed. These modes include <code>cmg</code> which displays alerts alongside a hexdump of the alerting packet(s), as well as a few different <code>alert_*</code> modes shown below:</p>
<pre><code>$ snort --help-modules | grep alert
alert_csv (logger): output event in csv format
alert_fast (logger): output event with brief text format
alert_full (logger): output event with full packet dump
alert_json (logger): output event in json format
alert_syslog (logger): output event to syslog
alert_talos (logger): output event in Talos alert format
alert_unixsock (logger): output event over unix socket
alerts (basic): configure alerts
</code></pre>
<p>These modes are set with the <code>-A</code> option followed by the desired alert mode, and we can focus solely on the alerts by also including the <code>-q</code> (quiet) flag. The <code>cmg</code> alert mode, for example, will look something like: </p>
<pre><code>$ snort -q -c $my_path/lua/snort.lua -q -r get.pcap -R local.rules -A cmg
10/14-14:59:14.186063 [**] [1:0:0] &quot;GET request&quot; [**] [Classification: Web Application Attack] [Priority: 1] {TCP} 10.1.2.3:50284 -&gt; 10.9.8.7:80

http_inspect.http_method[3]:
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
47 45 54                                          GET
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -

http_inspect.http_version[8]:
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
48 54 54 50 2F 31 2E 31                           HTTP/1.1
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -

http_inspect.http_uri[6]:
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
2F 68 65 6C 6C 6F                                 /hello
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -

http_inspect.http_header[78]:
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
48 6F 73 74 3A 20 61 62  63 69 70 2D 68 6F 73 74  Host: ab cip-host
2E 6C 6F 63 61 6C 0D 0A  55 73 65 72 2D 41 67 65  .local.. User-Age
6E 74 3A 20 61 62 63 69  70 0D 0A 41 63 63 65 70  nt: abci p..Accep
74 2D 4C 61 6E 67 75 61  67 65 3A 20 65 6E 2D 75  t-Langua ge: en-u
73 0D 0A 41 63 63 65 70  74 3A 20 2A 2F 2A        s..Accep t: */*
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
</code></pre>
<p>The <code>alert_talos</code> is another useful mode that displays alerts in a format that is simple and easy-to-understand.</p>
<pre><code>$ snort -q -c $my_path/lua/snort.lua -q -r get.pcap -R local.rules -A alert_talos

##### get.pcap #####
        [1:0:0] GET request (alerts: 1)
#####
</code></pre>
<p>Lastly, Some of the <code>alert_*</code> modes are customizable. <code>alert_csv</code> for example allows for customization of the different &quot;fields&quot; that can be outputted. The following example demonstrates a custom CSV alert configuration using the <code>--lua</code> command line flag:</p>
<pre><code>$ snort -q -c $my_path/lua/snort/lua -r cmd_injection.pcap -R local.rules --lua 'alert_csv = { fields = &quot;action pkt_num gid sid rev msg service src_addr src_port dst_addr dst_port&quot;, separator = &quot;,&quot; }'
would_block,5,1,1000000,0,&quot;Command injection detected&quot;,http,10.1.2.3,50284,10.9.8.7,80
would_block,6,1,1000000,0,&quot;Command injection detected&quot;,http,10.1.2.3,50284,10.9.8.7,80
</code></pre>
<h2 id="testing-rules-inline"><a class="header" href="#testing-rules-inline">Testing Rules Inline</a></h2>
<p>To protect networks, it's also important to make sure that our rules are blocking attacks appropriately, and the <code>dump</code> DAQ enables us to do just that.</p>
<p>Specifying the <code>-Q</code> option to enable inline mode and then setting the <code>--daq</code> to <code>dump</code> will &quot;dump&quot; the traffic that would've been passed through, emulating a real inline operation. The resulting traffic will be dumped, by default, to a file named <code>inline-out.pcap</code>:</p>
<pre><code>$ snort3 -Q --daq dump -q -r get.pcap -R local.rules
</code></pre>
<p>In the above example, if the <code>local.rules</code> file contains a <code>block</code> rule that fires on some traffic in the <code>get.pcap</code> file, then the resulting <code>inline-out.pcap</code> file will contain only the traffic that was not blocked. We can use this functionality to test that our rules are preventing the actual attack packet(s) from getting through.</p>
<h2 id="converting-snort-2-rules-to-snort-3"><a class="header" href="#converting-snort-2-rules-to-snort-3">Converting Snort 2 Rules to Snort 3</a></h2>
<p>Lastly, just like with configuration files, <code>snort2lua</code> can also be used to convert old Snort 2 rules to Snort 3 ones. Pass the Snort 2 rules file to the <code>-c</code> option and then provide a filename for the new Snort 3 rules file to the <code>-r</code> option:</p>
<pre><code>$ snort2lua -c in.rules -r out.rules
</code></pre>
<p>Note that if any errors occur during the conversion, <code>snort2lua</code> will output a <code>snort.rej</code> file that explains what went wrong:</p>
<pre><code>$ snort2lua -c 2.rules -r 3.rules
ERROR: 1 errors occurred while converting
ERROR: see snort.rej for details
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="snort-wizard-and-binder"><a class="header" href="#snort-wizard-and-binder">Snort Wizard and Binder</a></h1>
<p>Snort 3 features two new components to help determine the most likely service of a given flow of traffic and then direct that traffic to the right &quot;service inspector&quot;: the <strong>wizard</strong> and <strong>binder</strong>. These next sections go over each of these components in detail, starting with the wizard.</p>
<h2 id="the-wizard"><a class="header" href="#the-wizard">The Wizard</a></h2>
<p>The wizard uses what are called <strong>hexes</strong>, <strong>spells</strong>, and <strong>curses</strong> to help determine the service present on a given flow. All three look at different parts of the traffic to help identify the service being used. However, the wizard simply helps with service identification; it's the job of the Application Identification inspector to make the definitive determination. Therefore, the wizard's main goal is to quickly identify the <em>most likely</em> service so that it can hand it off to the appropriate inspector to do the rest.</p>
<h4 id="hexes"><a class="header" href="#hexes">Hexes</a></h4>
<p>Hexes are binary-based patterns that are used to detect binary protocols such as <code>ssl</code> and <code>dnp3</code>. Hexes are configured in Lua as an array of tables, where each table contains keys to define how the hexes should operate. Those keys include the following:</p>
<ul>
<li><code>service</code> -&gt; the name of the service that would be assigned</li>
<li><code>proto</code> -&gt; the protocol to scan (e.g., <code>tcp</code>)</li>
<li><code>client_first</code> -&gt; boolean flag that indicates if the client is the initiator of the data transfer</li>
<li><code>to_server</code> -&gt; list of text patterns to search in the data sent to the client</li>
<li><code>to_client</code> -&gt; list of text patterns to search in the data sent to the server</li>
</ul>
<p>Hex patterns contain a series of hexadecimal bytes enclosed <code>|</code> characters. Users can also add an arbitrary number of <code>?</code> characters to look for any number of hexadecimal digits. For instance, <code>|05 ?4|</code> would match <code>|05 84|</code> as well as <code>|05 34|</code>.</p>
<p>Here's one hex declaration for DNP3 traffic:</p>
<pre><code class="language-lua">{ 
  service = 'dnp3',
  proto = 'tcp',
  client_first = true,
  to_server = { '|05 64|' },
  to_client = { '|05 64|' } 
}
</code></pre>
<p>This hex and other built-in hexes can be found in the <code>snort_defaults.lua</code> configuration file <a href="https://github.com/snort3/snort3/blob/master/lua/snort_defaults.lua#L390">here</a>.</p>
<h4 id="spells"><a class="header" href="#spells">Spells</a></h4>
<p>Hexes are binary-based patterns, whereas <em>spells</em> are <strong>text-based</strong>, meaning they are best used with text-dominant protocols such as <code>http</code>, <code>smtp</code>, <code>sip</code>, and so forth. Spells are configured in the same manner that hexes are, and they also have an identical set of keys/options.</p>
<p>The text strings used in spells are case-insensitive and white-space sensitive. Spells can also contain wildcard characters, denoted with <code>*</code>, to match any number of bytes until a subsequent text pattern.</p>
<p>For example, an SMTP spell definition might look like this:</p>
<pre><code class="language-lua">{ 
  service = 'smtp', 
  proto = 'tcp', 
  client_first = true,
  to_server = { 'HELO', 'EHLO' },
  to_client = { '220*SMTP', '220*MAIL' } 
}
</code></pre>
<p>The built-in spells can be found in the <code>snort_defaults.lua</code> configuration file <a href="https://github.com/snort3/snort3/blob/master/lua/snort_defaults.lua#L359">here</a>.</p>
<h4 id="curses"><a class="header" href="#curses">Curses</a></h4>
<p>Curses are a little different than hexes and spells in that they are built as C++ state machines, as opposed to being defined in a Snort configuration. Curses exist for services where identification requires more than just a few string or hexadecimal patterns.</p>
<p>Snort currently has algorithms for five services/protocols:</p>
<ul>
<li>DCE/RPC over UDP</li>
<li>DCE/RPC over TCP</li>
<li>DCE/RPC over SMB</li>
<li>SSLv2</li>
<li>S7CommPlus</li>
<li>MMS</li>
</ul>
<p>The code for these algorithms can be found in <a href="https://github.com/snort3/snort3/blob/master/src/service_inspectors/wizard/curses.cc">src/service_inspectors/wizard/curses.cc</a>.</p>
<p>Like hexes and spells, curses also get enabled in a Snort configuration. The following line in <code>snort_defaults.lua</code> enables the six default curse algorithms present in <code>curses.cc</code>:</p>
<pre><code class="language-lua">curses = {'dce_udp', 'dce_tcp', 'dce_smb', 'mms', 's7commplus', 'sslv2'}
</code></pre>
<p>One can view the available curses with the following help command:</p>
<pre><code>$ snort --help-config wizard | grep curses
multi wizard.curses: enable service identification based on internal algorithm { dce_smb | dce_udp | dce_tcp | mms | s7commplus | sslv2 }
</code></pre>
<h2 id="the-binder"><a class="header" href="#the-binder">The Binder</a></h2>
<p>Snort 3's binder is a feature that directs network traffic to a specific service inspector based on some combination of the traffic's detected service, the ports and network ranges involved, and the network protocol being used. Users can create configurations with those options to tell Snort which service inspector to apply to a given network flow.</p>
<p>These configurations are written as an array of Lua tables and placed in one's Snort configuration file(s). These binder entries will typically contain two nested tables, <code>when</code> and <code>use</code>. The <code>when</code> table controls the criteria for invoking the action that's specified in the <code>use</code> table.</p>
<p>Here are some examples of a few different binder entries:</p>
<pre><code class="language-lua">binder =
{
  -- allow all tcp port 22:
  -- (similar to Snort 2 config ignore_ports)
  { when = { proto = 'tcp', ports = '22' }, use = { action = 'allow' } },

  -- select a config file by vlan
  -- (similar to Snort 2 config binding by vlan)
  { when = { vlans = '1024' }, use = { file = 'vlan.lua' } },
  
  -- use the DNS service inspector when the server port is TCP port 53
  { when = { proto = 'tcp', ports = '53', role='server' },  use = { type = 'dns' } },

  -- use a non-default HTTP inspector for port 8080:
  -- (similar to a Snort 2 targeted preprocessor config)
  { when = { nets = '192.168.0.0/16', proto = 'tcp', ports = '8080' },
    use = { name = 'alt_http', type = 'http_inspect' } },

  -- use the default inspectors:
  -- (similar to a Snort 2 default preprocessor config)
  { when = { proto = 'tcp' }, use = { type = 'stream_tcp' } },
  { when = { service = 'http' }, use = { type = 'http_inspect' } },

  -- figure out which inspector to run automatically:
  { use = { type = 'wizard' } }
}
</code></pre>
<p>One can view all the available binder table parameters with the following Snort command:</p>
<pre><code>$ snort --help-module binder
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="snort-tweaks-and-scripts"><a class="header" href="#snort-tweaks-and-scripts">Snort Tweaks and Scripts</a></h1>
<h2 id="tweaks"><a class="header" href="#tweaks">Tweaks</a></h2>
<p>Snort also provides the ability to add additional tunings to configurations with the <code>--tweaks</code> option. This can be used, for example, to employ one of Snort's various policy files that tweak Snort's detection engine to favor either more performance or more security. </p>
<p>Snort 3 comes with four policy tweak files by default: <code>max_detect</code>, <code>security</code>, <code>balanced</code> and <code>connectivity</code>. The <code>max_detect</code> policy provides the <em>most</em> security whereas the <code>connectivity</code> policy prioritizes performance and uptime at the expense of security.</p>
<p>These tweaks are more-or-less just configuration extensions; the <code>snort.lua</code> and <code>snort_defaults.lua</code> files provide a base policy, and then the <code>tweaks</code> allow for a particular set of targeted changes. </p>
<p>To use a tweak, simply specify the <code>--tweaks</code> option followed by the name of the tweak file to use. For example, to use the <code>max_detect</code> policy, one would run Snort like so:</p>
<pre><code>$ snort -c $my_path/lua/snort.lua -R local.rules --tweaks max_detect
</code></pre>
<p>There also exists a <code>talos</code> tweaks option that configures Snort to the way Talos analysts will initially test their own rules:</p>
<pre><code>$ snort -c $my_path/lua/snort.lua -R local.rules --tweaks talos
</code></pre>
<p>You can check out each of these tweaks in the <code>lua/</code> directory to see what kinds of changes each one makes.</p>
<h2 id="scripts"><a class="header" href="#scripts">Scripts</a></h2>
<p>Snort 3 is extensible in that it offers the ability for users to create custom LuaJIT scripts to extend its functionality. Scripts are passed to Snort 3 on the command line with the <code>--script-path &lt;scripts_path&gt;</code> argument, and they are then called in Snort rules by specifying the script &quot;name&quot; (declared in the .lua file) as a rule option.</p>
<p>One script we commonly work with is <code>hexdump.lua</code>, which prints out packet data at the detection cursor's current location. This is incredibly useful when creating rules because it helps rule writers determine if and what data is present in a specific buffer or at the current cursor location.</p>
<p>For example, if we were to invoke this <code>hexdump</code> script right after an <code>http_uri;</code> buffer declaration, Snort will print out all the bytes in the <code>http_uri</code> buffer:</p>
<pre><code>$ ls scripts/
hexdump.lua

$ cat local.rules
alert http ( \
    msg:&quot;GET request&quot;; \
    http_uri;
    hexdump;
    classtype:web-application-attack; \
    sid:1000000; \
)

$ snort --talos --script-path scripts/ -q -r get.pcap -R local.rules
[http_uri] (6 bytes)
00000000  2F 68 65 6C 6C 6F                                /hello
</code></pre>
<p>Because this particular script is relative to the previous content match, adding a <code>content:&quot;/h&quot;;</code> match to the rule after <code>http_uri;</code> would result in the following change:</p>
<pre><code>$ cat local.rules
alert http (
    msg:&quot;GET request&quot;;
    http_uri;
    content:&quot;/h&quot;;
    hexdump;
    classtype:web-application-attack;
    sid:1000000;
)

$ snort --talos --script-path scripts/ -q -r get.pcap -R local.rules
[http_uri] (4 bytes)
00000000  65 6C 6C 6F                                      ello 
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="snort-trace-modules"><a class="header" href="#snort-trace-modules">Snort Trace Modules</a></h1>
<p>Snort 3 also contains new &quot;trace&quot; modules that enable logging Snort's engine output at a very low level to display things such as rule evaluation tracing, buffer dumping, Application ID (wizard) tracing, and much more.</p>
<p>Snort tracing options are configured in Lua, and they can be placed in a tweak file that is included in the Snort configuration being used, or they can be provided directly on the command line.</p>
<p>We can see all the different trace module options and configurations available via the <code>--help-module trace</code> command line option:</p>
<pre><code>$ snort --help-module trace

trace


Help: configure trace log messages

Type: basic

Usage: global

Configuration:

int trace.modules.all: enable trace for all modules { 0:255 }
int trace.modules.appid.all: enable all trace options { 0:255 }
int trace.modules.dce_smb.all: enable all trace options { 0:255 }
int trace.modules.dce_udp.all: enable all trace options { 0:255 }
int trace.modules.decode.all: enable all trace options { 0:255 }
int trace.modules.detection.all: enable all trace options { 0:255 }
int trace.modules.detection.detect_engine: enable detection engine trace logging { 0:255 }
int trace.modules.detection.rule_eval: enable rule evaluation trace logging { 0:255 }
int trace.modules.detection.buffer: enable buffer trace logging { 0:255 }
int trace.modules.detection.rule_vars: enable rule variables trace logging { 0:255 }
…
</code></pre>
<p>There are many modules to choose from. These include <code>trace.modules.detection.buffer</code>, which is useful for packet buffer dumping, and <code>trace.modules.wizard</code>, which is used to show application detection information. </p>
<blockquote>
<p><strong>Note</strong>: To use all available tracing modules, Snort 3 must be configured with the <code>--enable-debug-msgs</code> option.</p>
</blockquote>
<p>Using a trace option is done by constructing a <code>trace.modules</code> Lua table and including in it the Lua table constructor(s) of the module(s) to enable. For example, the Lua table to enable the <code>trace.modules.wizard</code>, <code>trace.modules.detection.buffer</code>, and <code>trace.modules.detection.fp_search</code> modules is done like so:</p>
<pre><code class="language-lua">trace.modules = {
    detection = {
        fp_search = 1,
        buffer = 1,
    },
    wizard = {
        all = 1,
    },
}
</code></pre>
<p>Setting these values to an integer greater than zero will enable them, and conversely, setting them to zero will disable them.</p>
<p>Once the Lua table has been constructed, users will then include the table declaration either in a tweak file or on the command line with the <code>--lua</code> option.</p>
<p>Below is a list of common trace options that might be useful when working with Snort rules:</p>
<table><thead><tr><th>Option</th><th>Result</th><th>Lua</th></tr></thead><tbody>
<tr><td><code>fp_search</code></td><td>Show <code>fast_pattern</code> buffer name on entry</td><td><code>trace.modules = {detection = {fp_search = 1}}</code></td></tr>
<tr><td><code>buffer</code></td><td>Print packet buffer</td><td><code>trace.modules = {detection = {buffer = 1}}</code></td></tr>
<tr><td><code>rule_vars</code></td><td>Show rule variables like <code>byte_extract</code></td><td><code>trace.modules = {detection = {rule_vars = 1}}</code></td></tr>
<tr><td><code>rule_eval</code></td><td>Show rule eval tracing</td><td><code>trace.modules = {detection = {rule_eval = 1}}</code></td></tr>
<tr><td><code>wizard</code></td><td>Show application detection information</td><td><code>trace.modules = {wizard = { all = 1}}</code></td></tr>
</tbody></table>
<h2 id="more-examples"><a class="header" href="#more-examples">More Examples</a></h2>
<p>Here are a few examples of specifying tracing on the command line.</p>
<p>This first example incorporates the <code>wizard</code> trace module to display the application detection information:</p>
<pre><code>$ snort -c $my_path/lua/snort.lua -q -r get.pcap -R local.rules -A alert_talos \
        --lua 'trace.modules = {wizard = {all = 1}}'
P0:wizard:all:1: c2s streaming search found service http

##### get.pcap #####
        [1:0:0] GET request (alerts: 1)
#####
</code></pre>
<p>This next example uses multiple trace modules, <code>wizard</code>, <code>detection.fp_search</code>, and <code>detection.buffer</code>, to dump application detection information, the packet buffer(s), and rule <code>fast_pattern</code> details.</p>
<pre><code>$ snort -q -r get.pcap -R local.rules -A alert_talos \
        --lua 'trace.modules = {wizard = {all = 2}, \
        detection = {fp_search = 1, buffer = 1}}'
P0:wizard:all:1: c2s streaming search found service http
P0:detection:fp_search:1: 5 fp http_inspect.key[6]

http_inspect.stream_tcp[6]:
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
2F 68 65 6C 6C 6F                                 /hello
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
P0:detection:buffer:1: Buffer dump - empty buffer

http_inspect.stream_tcp[6]:
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
2F 68 65 6C 6C 6F                                 /hello
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
P0:detection:buffer:1: Buffer dump - empty buffer

##### get.pcap #####
        [1:0:0] GET request (alerts: 1)
#####
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-basics"><a class="header" href="#the-basics">The Basics</a></h1>
<h2 id="snort-rule-structure"><a class="header" href="#snort-rule-structure">Snort Rule Structure</a></h2>
<p>Snort's intrusion detection and prevention system relies on the presence of Snort rules to protect networks, and those rules consist of two main sections:</p>
<ul>
<li>The <strong>rule header</strong> defines the action to take upon any matching traffic, as well as the protocols, network addresses, port numbers, and direction of traffic that the rule should apply to.</li>
<li>The <strong>rule body</strong> section defines the message associated with a given rule, and most importantly the payload and non-payload criteria that need to be met in order for a rule to match. Although rule options are not required, they are essential for making sure a given rule targets the right traffic.</li>
</ul>
<p>The following is an example of a fully-formed Snort 3 rule with a correct rule header and rule option definitions:</p>
<pre><code class="language-snort">alert tcp $EXTERNAL_NET 80 -&gt; $HOME_NET any
(
    msg:&quot;Attack attempt!&quot;;
    flow:to_client,established;
    file_data;
    content:&quot;1337 hackz 1337&quot;,fast_pattern,nocase;
    service:http;
    sid:1;
)
</code></pre>
<p>The rule header includes all the text up to the first parenthesis, while the body includes everything between the two parentheses. </p>
<p>The action defined in a given Snort rule's header is not taken unless all of the rule's individual options evaluate to true. </p>
<blockquote>
<p><strong>Note:</strong> Snort 3 ignores extra whitespace in rules, and so there's no need to escape newlines with backslashes like what was required with Snort 2 rules.</p>
</blockquote>
<h3 id="rule-comments"><a class="header" href="#rule-comments">Rule comments</a></h3>
<p>Rule writers can also add comments to their rules to provide additional context or information about a rule or rule option. These comments are added with <code>#</code> to start a comment <em>line</em> or with <code>/* … */</code> to create either inline or multi-line comments.</p>
<pre><code class="language-snort"># hash comment here
content:&quot;ABCD&quot;;
</code></pre>
<pre><code class="language-snort">/* these can be used to create
   multi-line comments
*/
content:&quot;ABCD&quot;; /* or they can be used like this */
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rule-headers"><a class="header" href="#rule-headers">Rule Headers</a></h1>
<p>All Snort rules start with a rule header that helps filter the traffic that the rule's body will evaluate. </p>
<p>A <em>traditional</em> rule header consists of five main components, and the following example is used to highlight what these five parts are:</p>
<pre><code class="language-snort">alert tcp $EXTERNAL_NET 80 -&gt; $HOME_NET any
</code></pre>
<ul>
<li>
<p>Rule <strong>actions</strong> tell Snort what to do when a rule &quot;fires&quot;:
<br>
<code>
<strong>alert</strong> tcp $EXTERNAL_NET 80 -&gt; $HOME_NET any
</code>
<br></p>
</li>
<li>
<p>The <strong>protocol</strong> tells Snort which protocol applies:
<br>
<code>
alert <strong>tcp</strong> $EXTERNAL_NET 80 -&gt; $HOME_NET any
</code>
<br></p>
</li>
<li>
<p><strong>IP addresses</strong> tell Snort what networks to evaluate the rule against:
<br>
<code>
alert tcp <strong>$EXTERNAL_NET</strong> 80 -&gt; <strong>$HOME_NET</strong> any
</code>
<br></p>
</li>
<li>
<p><strong>Ports</strong> tell Snort which ports to evaluate the rule against:
<br>
<code>
alert tcp $EXTERNAL_NET <strong>80</strong> -&gt; $HOME_NET <strong>any</strong>
</code>
<br></p>
</li>
<li>
<p>The <strong>direction operator</strong> tells Snort which traffic direction to look for:
<br>
<code>
alert tcp $EXTERNAL_NET 80 <strong>-&gt;</strong> $HOME_NET any
</code>
<br></p>
</li>
</ul>
<p>We will discuss each of these in detail in the next few pages.</p>
<blockquote>
<p><strong>Note:</strong> Snort 3 also introduces three new rule types that each have their own rule header format, and all three are described in later sections.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rule-actions"><a class="header" href="#rule-actions">Rule Actions</a></h1>
<p>Rule actions tell Snort how to handle matching packets. There are five basic actions:</p>
<ul>
<li><code>alert</code> -&gt; generate an alert on the current packet</li>
<li><code>block</code> -&gt; block the current packet and all the subsequent packets in this flow</li>
<li><code>drop</code> -&gt; drop the current packet</li>
<li><code>log</code> -&gt; log the current packet</li>
<li><code>pass</code> -&gt; mark the current packet as passed</li>
</ul>
<p>There are also what are known as &quot;active responses&quot; that perform some action in response to the packet being detected:</p>
<ul>
<li><code>react</code> -&gt; send response to client and terminate session.</li>
<li><code>reject</code> -&gt; terminate session with TCP reset or ICMP unreachable</li>
<li><code>rewrite</code> -&gt; enables overwrite packet contents based on a &quot;replace&quot; option in the rules</li>
</ul>
<p>The desired action for a given rule is the very first thing declared in a rule. </p>
<h4 id="examples"><a class="header" href="#examples">Examples:</a></h4>
<pre><code class="language-snort">alert http (msg:&quot;Generate an alert&quot;; sid:1;)
</code></pre>
<pre><code class="language-snort">drop http (msg:&quot;Drop this packet&quot;; sid:2;)
</code></pre>
<pre><code class="language-snort">block http (msg:&quot;Block this packet and subsequent ones&quot;; sid:3;)
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="protocols"><a class="header" href="#protocols">Protocols</a></h1>
<p>The protocol field tells Snort what type of protocols a given rule should look at, and the currently supported ones include:</p>
<ul>
<li><code>ip</code></li>
<li><code>icmp</code></li>
<li><code>tcp</code></li>
<li><code>udp</code></li>
</ul>
<p>A rule can only have one protocol set, and the name of the protocol is placed after the action.</p>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples:</a></h4>
<pre><code class="language-snort">alert udp $EXTERNAL_NET any -&gt; $HOME_NET 53 (
</code></pre>
<pre><code class="language-snort">alert tcp $EXTERNAL_NET any -&gt; $HOME_NET 80 (
</code></pre>
<pre><code class="language-snort">alert ip any any -&gt; $HOME_NET any (
</code></pre>
<h2 id="services-in-place-of-protocols"><a class="header" href="#services-in-place-of-protocols">Services in place of protocols</a></h2>
<p>The above four protocols look for specific &quot;Layer 3&quot; (<code>ip</code> and <code>icmp</code>) and &quot;Layer 4&quot; (<code>tcp</code> and <code>udp</code>) protocols. However, rule writers also have the option of specifying <em>application layer</em> services here—instead of one of the four aforementioned protocols—to tell Snort to only match on traffic of the specified <em>service</em>. This means that not only must the networks, ports, and direction of the traffic match what's present in the header, but the specified service <em>must also match</em> the service that Snort detects in the traffic.</p>
<p>To utilize this, one must place the <em>name</em> of a given service where a protocol would usually go. For example, if we wanted to match only on traffic sent to destination port 443 that Snort detects as SSL/TLS, we would simply specify <code>ssl</code> in our rule header like so:</p>
<pre><code class="language-snort">alert ssl any any -&gt; any 443
</code></pre>
<p>It's important to reiterate that the service specified in the header <strong>MUST</strong> match the service detected in the traffic for a rule to be considered a match. This means, for example, that the above rule header <em>can only match on traffic that Snort has detected as SSL/TLS</em>.</p>
<p>The names of services that can be used here can be found by looking at the wizard entries in the <code>snort_defauls.lua</code> file included in the <code>lua/</code> directory, as well as the curse service names present in the <code>curse_map</code> in <code>src/service_inspectors/wizard/curses.cc</code>.</p>
<h4 id="examples-2"><a class="header" href="#examples-2">Examples:</a></h4>
<pre><code class="language-snort"># will only run on HTTP traffic sent to destination port 8000
alert http $EXTERNAL_NET any -&gt; $HOME_NET 8000 (
</code></pre>
<pre><code class="language-snort"># will only run on SMTP traffic sent to destination port 5300
alert smtp $EXTERNAL_NET any -&gt; $HOME_NET 5300 (
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ip-addresses"><a class="header" href="#ip-addresses">IP Addresses</a></h1>
<p>IP addresses in a rule header tell Snort what source and destination IP addresses a given rule should apply to. A rule will only match if the source and destination IP addresses of a given packet match the IP addresses set in that rule.</p>
<p>They can be declared in one of four ways:</p>
<ul>
<li>As a numeric IP address with an optional CIDR block (e.g., <code>192.168.0.5</code>, <code>192.168.1.0/24</code>)</li>
<li>As a variable defined in the Snort config that specifies a network address or a set of network addresses (e.g., <code>$EXTERNAL_NET</code>, <code>$HOME_NET</code>, etc.)</li>
<li>The keyword <code>any</code>, meaning any IP address</li>
<li>A list of IP addresses, IP address variables, and/or port ranges, enclosed in square brackets and separated by commas (e.g., <code>[192.168.1.0/24,10.1.1.0/24]</code>)</li>
</ul>
<p>Two IP address declarations are made in a single rule header: the source IP addresses declared after the protocol field and the destination IP addresses declared after the direction operator.</p>
<blockquote>
<p><strong>Note:</strong> IP address declarations can also be negated to tell Snort to match any IP address except for the ones listed. This negation is done with the <code>!</code> operator.</p>
</blockquote>
<h4 id="examples-3"><a class="header" href="#examples-3">Examples:</a></h4>
<pre><code class="language-snort"># look for traffic sent from the 192.168.1.0/24 subnet to the
# 192.168.5.0/24 subnet
alert tcp 192.168.1.0/24 any -&gt; 192.168.5.0/24 any (
</code></pre>
<pre><code class="language-snort"># look for traffic sent from addresses included in the
# defined $EXTERNAL_NET variable to addresses included in the defined
# $HOME_NET variable
alert tcp $EXTERNAL_NET any -&gt; $HOME_NET 80 (
</code></pre>
<pre><code class="language-snort"># look for traffic sent from any source network to the IP address, 192.168.1.3
alert tcp any any -&gt; 192.168.1.3 445 (
</code></pre>
<pre><code class="language-snort">alert tcp !192.168.1.0/24 any -&gt; 192.168.1.0/24 23 (
</code></pre>
<pre><code class="language-snort">alert tcp ![192.168.1.0/24,10.1.1.0/24] any -&gt; [192.168.1.0/24,10.1.1.0/24] 80 (
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="port-numbers"><a class="header" href="#port-numbers">Port Numbers</a></h1>
<p>The port numbers in a rule header tell Snort to apply a given rule to traffic sent from or sent to the specified source and destination ports.</p>
<p>Ports are declared in a few different ways:</p>
<ul>
<li>As <code>any</code> ports (meaning match traffic being sent from or to <em>any</em> port)</li>
<li>As a static port (e.g., <code>80</code>, <code>445</code>, <code>21</code>)</li>
<li>As a variable defined in the Snort config that specifies a port or set of ports (e.g., <code>$HTTP_PORTS</code>)</li>
<li>As port ranges indicated with the range operator, <code>:</code> (e.g., <code>1:1024</code>, <code>500:</code>)</li>
<li>A list of static ports, port variables, and/or port ranges, enclosed in square brackets and separated by commas (e.g., <code>[1:1024,4444,5555,$HTTP_PORTS]</code>)</li>
</ul>
<p>A rule header should have two port declarations, one to define the source ports and another to define the destination ports. Source and destination ports are declared after the source and destination IP addresses, respectively. </p>
<p>An important thing to note, however, is that the ports specified in the rule header do not have to match the ports being used in the traffic if a service specified in the <a href="rules/options/general/service.htm">service rule option</a> matches the service of the given traffic. For instance, if <code>service:http</code> is set in a rule, then Snort will apply that rule to <em>all</em> HTTP traffic detected, even if that traffic is being sent to a port that is not included in the rule's destination port list.</p>
<p>If on the other hand you want to look for a particular service <strong>AND</strong> a specific port or multiple ports, then you should specify a service in the &quot;traditional&quot; rule header as mentioned in the <a href="rules/headers/protocols.htm#services-in-place-of-protocols">protocols page</a>.</p>
<blockquote>
<p><strong>Note:</strong> Port declarations can also be negated by placing <code>!</code> before them.</p>
</blockquote>
<h4 id="examples-4"><a class="header" href="#examples-4">Examples:</a></h4>
<pre><code class="language-snort"># log udp traffic coming from any source port and destination ports
# ranging from 1 to 1024
log udp any any -&gt; 192.168.1.0/24 1:1024 (
</code></pre>
<pre><code class="language-snort"># log tcp traffic from any port going to ports less than or equal to 6000
log tcp any any -&gt; 192.168.1.0/24 :6000 (
</code></pre>
<pre><code class="language-snort"># log tcp traffic from privileged ports less than or equal to 1024 going
# to ports greater than or equal to 500
log tcp any :1024 -&gt; 192.168.1.0/24 500: (
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="direction-operators"><a class="header" href="#direction-operators">Direction Operators</a></h1>
<p>The direction operator of a header indicates the direction of the traffic that the rule should apply to. There are two valid direction operators:</p>
<ul>
<li><code>-&gt;</code></li>
<li><code>&lt;&gt;</code></li>
</ul>
<p>The <code>-&gt;</code> operator is the most common, and it denotes that the IP addresses and port numbers on the left side represent the source and the IP addresses and port numbers on the right side represent the destination. </p>
<p>The <code>&lt;&gt;</code> operation is the bidirectional operator, and it tells Snort to consider the two IP address and port pairs as <em>either</em> the source or destination. </p>
<p>The direction operator is placed after the first ports declaration in the header.</p>
<h4 id="examples-5"><a class="header" href="#examples-5">Examples:</a></h4>
<pre><code class="language-snort">alert tcp $EXTERNAL_NET 80 -&gt; $HOME_NET any (
</code></pre>
<pre><code class="language-snort">log tcp !192.168.1.0/24 any &lt;&gt; 192.168.1.0/24 23 (
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="new-rule-types-in-snort-3"><a class="header" href="#new-rule-types-in-snort-3">New Rule Types in Snort 3</a></h1>
<p>Snort 3 introduces three new rule types to simplify and enhance rule writing: <strong>service rules</strong>, <strong>file rules</strong>, and <strong>file identification rules</strong>. </p>
<p>Service and file rules allow for the creation of cleaner-looking rules that are service-specific and service-agnostic, respectively, while file identification rules use the new <code>file_meta</code> rule option to perform file type identification.</p>
<p>Each of these new rule types are created using a unique rule header, and more info about each can be found in the subsequent chapters.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="service-rules"><a class="header" href="#service-rules">Service Rules</a></h1>
<p>Service rules are a new rule type in Snort 3 that allows rule writers to match on traffic of a particular service by using a rule header that consists of only an <a href="rules/headers/actions.htm">action</a> and the name of an application-layer service. The difference between these headers and the &quot;traditional&quot; headers described <a href="rules/headers/index.htm">here</a> is that <em>these</em> ones do not require declarations of network addresses, ports, or a direction operator.</p>
<p>These service rules let rule writers target a particular service regardless of the IP addresses or ports being used in a given network flow. This type of rule is especially useful for services like HTTP where it's not uncommon to see web servers running on TCP ports other than <code>80</code>.</p>
<p>For example, the following rule header tells Snort to apply this rule only to traffic that Snort detects as HTTP:</p>
<pre><code class="language-snort">alert http (
</code></pre>
<p>Note however that with these rules, the service specified in the header <strong>MUST</strong> match the service detected in the traffic for a rule to be considered a match. To be more explicit, the above rule header <em>can only match on traffic that Snort has detected as HTTP</em>.</p>
<p>The names of services that can be used here can be found by looking at the wizard entries in the <code>snort_defauls.lua</code> file included in the <code>lua/</code> directory, as well as the curse service names present in the <code>curse_map</code> in <code>src/service_inspectors/wizard/curses.cc</code>.</p>
<h4 id="format"><a class="header" href="#format">Format:</a></h4>
<p>These rules are created with a rule header that includes only an <a href="rules/headers/actions.htm">action</a> followed by a service name.</p>
<pre><code><i>action</i> <i>service</i></code></pre>
<blockquote>
<p><strong>Note</strong>: Service rules do not require a <code>service</code> option declaration in the rule.</p>
</blockquote>
<h4 id="example"><a class="header" href="#example">Example:</a></h4>
<p>The following rule would alert on matching HTTP traffic regardless of ports or IP addresses used in the communication:</p>
<pre><code class="language-snort">alert http
(
    msg:&quot;SERVER-WEBAPP This rule only looks at HTTP traffic&quot;;
    flow:to_server,established;
    http_uri;
    content:&quot;/admin.php&quot;,fast_pattern,nocase;
    content:&quot;cmd=&quot;,nocase;
    pcre:&quot;/[?&amp;]cmd=[^&amp;]*?\x3b/i&quot;;
    sid:1;
)
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="file-rules"><a class="header" href="#file-rules">File Rules</a></h1>
<p>Snort 3's new &quot;file rules&quot; allow rule writers to create rules to match a particular file regardless of the protocol, source IPs, destination IPs, ports, and service.</p>
<p>Snort is able to process files that are sent using any of the following application-layer protocols:</p>
<ul>
<li>HTTP</li>
<li>SMTP</li>
<li>POP3</li>
<li>IMAP</li>
<li>SMB</li>
<li>FTP</li>
</ul>
<h4 id="format-1"><a class="header" href="#format-1">Format:</a></h4>
<p>These rules are created with a rule header containing just an <a href="rules/headers/actions.htm">action</a> followed by the keyword <code>file</code>:</p>
<pre><code><i>action</i> file</code></pre>
<p>When creating file rules, rule writers should make sure to do the following two things:</p>
<ul>
<li>Specify the <code>file_data</code> buffer for all content matches that should be matched in the file</li>
<li>Omit any <code>service</code> and <code>flow</code> rule options from the rule</li>
</ul>
<h4 id="example-1"><a class="header" href="#example-1">Example:</a></h4>
<p>To see the advantage of such a rule header, consider the two rules below that look for &quot;secret_encryption_key&quot; in a packet. The first rule looks for the string included in HTTP and IMAP packets sent to a client, while the second rule looks for the string included in SMTP packets sent to some SMTP server. </p>
<pre><code class="language-snort">alert tcp $EXTERNAL_NET [80,143] -&gt; $HOME_NET any
(
    msg:&quot;MALWARE-OTHER Win.Ransomware.Agent payload download attempt&quot;;
    flow:to_client,established;
    file_data; content:&quot;secret_encryption_key&quot;,fast_pattern,nocase;
    service:http, imap;
    classtype:trojan-activity;
    sid:1;
)
alert tcp $EXTERNAL_NET any -&gt; $SMTP_SERVERS 25 
(
    msg:&quot;MALWARE-OTHER Win.Ransomware.Agent payload download attempt&quot;;
    flow:to_server,established;
    file_data; content:&quot;secret_encryption_key&quot;,fast_pattern,nocase;
    service:smtp;
    classtype:trojan-activity;
    sid:2;
)
</code></pre>
<p>However, this pair of rules can be written as a single <code>alert file</code> rule, which will tell Snort to look for &quot;secret_encryption_key&quot; in any file detected on the network, regardless of source, destination, or service.</p>
<pre><code class="language-snort">alert file
(
    msg:&quot;MALWARE-OTHER Win.Ransomware.Agent payload download attempt&quot;;
    file_data;
    content:&quot;secret_encryption_key&quot;,fast_pattern,nocase;
    classtype:trojan-activity;
    sid:3;
)
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="file-identification-rules"><a class="header" href="#file-identification-rules">File Identification Rules</a></h1>
<p>File identification rules take advantage of Snort's detection engine to enable file type identification. These rules are basic Snort 3 rules, but instead of alerting on and/or blocking traffic, they <em>identify</em> files based on the contents of that file and then define a file <em>type</em> that can be used in subsequent rules with <a href="rules/options/non_payload/file_type.htm">file_type</a> options. </p>
<p>File identification rules have two key components:</p>
<ul>
<li>a rule header consisting of only <code>file_id</code>, which tells Snort that the rule that follows is a file type definition</li>
<li>a <code>file_meta</code> rule option that set the file metadata for a given file identification rule</li>
</ul>
<p>Because these rules are used to identify a particular file, rule-writers should look for any and all payload options in the <code>file_data</code> buffer.</p>
<p>More info on using the <code>file_meta</code> option is available on the <a href="rules/options/general/file_meta.htm">file_meta manual page</a>.</p>
<h4 id="examples-6"><a class="header" href="#examples-6">Examples:</a></h4>
<pre><code class="language-snort">file_id (
    msg:&quot;Windows/DOS executable file&quot;; 
    file_meta:type MSEXE, id 21, category &quot;Executables,Dynamic Analysis Capable,Local Malware Analysis Capable&quot;; 
    file_data; 
    content:&quot;| 4D 5A |&quot;, depth 2, offset 0; 
    gid:4; 
    sid:16; 
    rev:1;
)
</code></pre>
<p>A <code>file_id</code> entry can also define a specific file type <em>version</em>, which is set via the <code>version</code> argument.</p>
<pre><code class="language-snort">file_id (
    msg:&quot;PDF file&quot;; 
    file_meta:type PDF, id 282, category &quot;PDF files,Dynamic Analysis Capable,Local Malware Analysis Capable&quot;, version &quot;1.0&quot;; 
    file_data; 
    content:&quot;| 25 50 44 46 2D 31 2E 30 |&quot;, depth 8, offset 0; 
    gid:4; 
    sid:158; 
    rev:1;
)
</code></pre>
<h4 id="enabling-file-identification"><a class="header" href="#enabling-file-identification">Enabling file identification</a></h4>
<p>Use of file identification rules requires that the <code>file_id</code> and <code>file_policy</code> builtins are enabled in one's Snort 3 config. Fortunately, both are enabled by default in the standard <code>snort.lua</code> file:</p>
<pre><code>file_id = { rules_file = 'file_magic.rules' }
file_policy = { }
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rule-options"><a class="header" href="#rule-options">Rule Options</a></h1>
<p>Rule options are the heart and soul of a Snort rule, as they determine if a given packet should be passed along to its destination, or if it should instead be stopped in its tracks.</p>
<p>Each rule option has its own set of option-specific critera, but they all follow the same general structure. First, all rule options are enclosed in parentheses after the rule header. Then, each rule option is declared with its name followed optionally by a<code>:</code> character and any option-specific criteria. Lastly, each rule option is terminated with a <code>;</code> character. </p>
<p>It's important to note that not all options have arguments, and some options have multiple arguments that are separated by commas. </p>
<p>There are four major categories of rule options:</p>
<ul>
<li><a href="rules/options/general/index.htm">general</a> options provide additional context for a given rule</li>
<li><a href="rules/options/payload/index.htm">payload</a> options set payload-specific criteria</li>
<li><a href="rules/options/non_payload/index.htm">non-payload</a> options set non-payload specific criteria</li>
<li><a href="rules/options/post/index.htm">post-detection</a> options set actions to take on a given packet after the rule has &quot;fired&quot;</li>
</ul>
<p>All of these are discussed in great detail later in the manual, but here are a few example options and their specific structure:</p>
<pre><code class="language-snort"># this is an example of a buffer modifier, &quot;http_uri&quot;
# it tells Snort to look for subsequent content matches only in that buffer
http_uri;

# content match specific criteria, as well as others, require double quotes
content:&quot;/web_form.php&quot;;
</code></pre>
<pre><code class="language-snort"># not all options have criteria that require quotes
service:http;
</code></pre>
<pre><code class="language-snort"># some options require specifying a &quot;sub-option&quot;
reference:url,www.example.com;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rule-option-syntax-key"><a class="header" href="#rule-option-syntax-key">Rule Option Syntax Key</a></h1>
<p>Each rule option page features a &quot;Format&quot; section that describes how the specific rule option can be formatted. Some rule options are simple and specified with just the option name, while others are more complicated and have a mix of required and optional &quot;arguments&quot;. This page serves as a key to help understand the syntax that you will find in those sections. </p>
<h2 id="italicized-strings"><a class="header" href="#italicized-strings">Italicized strings</a></h2>
<p>Italicized strings serve as placeholders for arbitrary values. When one sees this option they must replace it with an appropriate value.</p>
<p>It's important to note italicized strings can be placeholders for different <em>types</em> of data, such as strings or integers, and so one must make sure take that into account when specifying a value or values.</p>
<p>In the following example, the user must write <code>food </code> followed a food value.</p>
<pre><code>food <var>food</var></code></pre>
<p>For example, <code>food pizza</code>, <code>food cookies</code>, and <code>food cheese</code> would all be valid entries.</p>
<h2 id="square-brackets"><a class="header" href="#square-brackets">Square brackets</a></h2>
<p>Square brackets (<code>[]</code>) indicate that the enclosed item or items are <em>optional</em>. If the items in the square brackets are separated between pipe characters (<code>|</code>), then the rule writer can choose one of the items or none of them.</p>
<p>In the following example, the rule writer can choose <code>pizza</code> or <code>cookies</code>, or none of them.</p>
<pre><code>[pizza|cookies]
</code></pre>
<p>And in the following example, the rule writer can optionally add the <code>, nocase</code> string.</p>
<pre><code>[, nocase]
</code></pre>
<h2 id="curly-braces"><a class="header" href="#curly-braces">Curly braces</a></h2>
<p>Curly braces (<code>{}</code>) indicate that the rule writer <strong>must</strong> select one—but <em>only one</em>—of the items separated by pipe characters.</p>
<p>In the following example, the rule writer must choose either <code>pizza</code> or <code>cookies</code>, but not both.</p>
<pre><code>{pizza|cookies}
</code></pre>
<h2 id="ellipses"><a class="header" href="#ellipses">Ellipses</a></h2>
<p>Three dots (<code>…</code>) indicates that a rule option, a rule option argument, or some other modifier can be repeated any number of times. An ellipsis applies to the entire group that it's in, whether that's a curly-brace group or a square-bracket group.</p>
<p>In the following example, the rule writer must specify the string <code>food</code> plus any number of <code><i>food</i></code> items separated by commas.</p>
<pre><code>food <var>food</var>[, <var>food</var>]…</code></pre>
<p>For example, <code>food pizza, cookies, bacon</code> would be a valid entry.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="general-rule-options"><a class="header" href="#general-rule-options">General Rule Options</a></h1>
<p>General rule options provide information about a rule, but they do not at all change what a given rule looks for in a packet. General options are not required for a rule, but it is strongly recommended that they are used to provide additional context for a rule should that rule ever generate an event.</p>
<p>Each general option is described in subsequent sections, but the following table lists each one for quick reference.</p>
<table><thead><tr><th>keyword</th><th>description</th></tr></thead><tbody>
<tr><td><a href="rules/options/general/msg.htm">msg</a></td><td><code>msg</code> sets the message to be printed out when a rule matches</td></tr>
<tr><td><a href="rules/options/general/reference.htm">reference</a></td><td><code>reference</code> is used to provide additional context to rules in the form of links to relevant attack identification systems</td></tr>
<tr><td><a href="rules/options/general/gid.htm">gid</a></td><td><code>gid</code> identifies the specific Snort component that generates a given event</td></tr>
<tr><td><a href="rules/options/general/sid.htm">sid</a></td><td><code>sid</code> identifies the unique signature number assigned to a given Snort rule</td></tr>
<tr><td><a href="rules/options/general/rev.htm">rev</a></td><td><code>rev</code> identifies the particular revision number of a given Snort rule</td></tr>
<tr><td><a href="rules/options/general/classtype.htm">classtype</a></td><td><code>classtype</code> assigns a classification to the rule to indicate the type of attack associated with an event</td></tr>
<tr><td><a href="rules/options/general/priority.htm">priority</a></td><td><code>priority</code> sets a severity level for appropriate event prioritizing</td></tr>
<tr><td><a href="rules/options/general/metadata.htm">metadata</a></td><td><code>metadata</code> adds additional and arbitrary information to a rule in the form of name-value pairs</td></tr>
<tr><td><a href="rules/options/general/service.htm">service</a></td><td><code>service</code> sets the list of services to be associated with a given rule</td></tr>
<tr><td><a href="rules/options/general/rem.htm">rem</a></td><td><code>rem</code> is used to convey an arbitrary comment in the rule body</td></tr>
<tr><td><a href="rules/options/general/file_meta.htm">file_meta</a></td><td><code>file_meta</code> is used to set the file metadata for a given file identification rule</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="msg"><a class="header" href="#msg">msg</a></h1>
<p>The <code>msg</code> rule option is used to add a message describing the rule. The message should summarize the rule's purpose, and it will be outputted along with events generated by the rule.</p>
<p>This option takes just a single argument: a text string enclosed in double quotes that explains what kind of traffic the rule will match. </p>
<p><code>msg</code> is typically the first one present in a Snort rule.</p>
<blockquote>
<p><strong>Note</strong>: Snort rules have a few reserved characters (e.g., <code>&quot;</code>, <code>;</code>), and rule-writers must escape them with <code>\</code> to use them in the rule's <code>msg</code> option. </p>
</blockquote>
<h4 id="format-2"><a class="header" href="#format-2">Format:</a></h4>
<pre><code>msg:"<var style="color:slategrey;">message</var>";</code></pre>
<h4 id="examples-7"><a class="header" href="#examples-7">Examples:</a></h4>
<pre><code class="language-snort">msg:&quot;SERVER-WEBAPP /etc/inetd.conf file access attempt&quot;;
</code></pre>
<pre><code class="language-snort">msg:&quot;Malicious file download attempt&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">reference</a></h1>
<p>The <code>reference</code> rule option provides additional context to rules in the form of links to relevant attack identification systems.</p>
<p>This option takes in two arguments separated by commas. The first argument is the <code><var>scheme</var></code>, which is the attack identification system being referenced, and the second argument is the <code>id</code>, which is the specific identifier within that system. </p>
<p>There are a few <code><var>scheme</var></code> types known to Snort by default, but the two most common ones used are <code>cve</code> and <code>url</code>.</p>
<p>For example, consider the CVE identification system, which identifies a software vulnerability via a CVE record that is formatted like &quot;CVE-XXXX-YYYY&quot;, where &quot;XXXX&quot; is the year the vulnerability was identified and &quot;YYYY&quot; is a unique numeric identifier. Snort rule writers can put references to CVE records in rules with a <code>reference</code> option that has <code>scheme</code> set to <code>cve</code> and the <code>id</code> set to the &quot;XXXX-YYYY&quot; portion of the record. For example, <code>reference:cve,2020-1234</code> puts in the rule a reference to <code>CVE-2020-1234</code>.</p>
<h4 id="format-3"><a class="header" href="#format-3">Format:</a></h4>
<pre><code>reference:<var style="color:slategrey;">scheme</var>,<var style="color:slategrey;">id</var>;</code></pre>
<h4 id="examples-8"><a class="header" href="#examples-8">Examples:</a></h4>
<pre><code class="language-snort">reference:url,www.example.com;
</code></pre>
<pre><code class="language-snort">reference:cve,2020-1234;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="gid"><a class="header" href="#gid">gid</a></h1>
<p>The <code>gid</code> keyword stands for &quot;generator id&quot; and it identifies the specific part of Snort that generated a given event. The different parts include, but are not limited to, standard text rules, shared object rules, and builtin rules, and each have part their own generator ID. Standard text rules, for example, are identified with as GID 1, shared object rules are identified with GID 3, and builtin rules are identified with gids over 100. </p>
<p>The GIDs included within Snort can be listed with the following command:</p>
<pre><code>$ snort --list-gids
</code></pre>
<p>It's important to note that the <code>gid</code> keyword is <strong>optional</strong>, and if it is not specified in a rule, then it will default to 1 and the rule will be part of the standard rule subsystem.</p>
<h4 id="format-4"><a class="header" href="#format-4">Format:</a></h4>
<pre><code>gid:<var style="color:slategrey;">generator_id</var>;</code></pre>
<h4 id="examples-9"><a class="header" href="#examples-9">Examples:</a></h4>
<pre><code class="language-snort"># sets the rule's generator ID to 1 to tell Snort it's a standard text rule
gid:1;
</code></pre>
<pre><code class="language-snort"># sets the rule's generator ID to 3 to tell Snort it's a shared object rule
gid:3;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="sid"><a class="header" href="#sid">sid</a></h1>
<p>The <code>sid</code> keyword uniquely identifies a given Snort rule. This rule option takes in a single argument that is a numeric value that must be unique to the rule. </p>
<p>While not technically required, all Snort rules should have a <code>sid</code> option to be able to quickly identify a rule should it ever generate an alert. </p>
<p>Snort &quot;reserves&quot; <code>sid</code> values 0-999999 because those are used in rules included with the Snort distribution. Therefore users should use for local rules <code>sid</code> values that start at 1000000, incrementing the <code>sid</code> values by one for each additional local rule.</p>
<h4 id="format-5"><a class="header" href="#format-5">Format:</a></h4>
<pre><code>sid:<var style="color:slategrey;">signature_id</var>;</code></pre>
<h4 id="example-2"><a class="header" href="#example-2">Example:</a></h4>
<pre><code class="language-snort">sid:44763;
</code></pre>
<pre><code class="language-snort">sid:1000001;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rev"><a class="header" href="#rev">rev</a></h1>
<p>The <code>rev</code> keyword uniquely identifies the revision number of a given Snort rule. This option should be used along with the <code>sid</code> keyword and should be incremented by one each time a change is made to a rule. </p>
<p>This option takes in a single argument, a numeric value that identifies the rule's current revision number. Revision values start at <code>1</code>, and rules will default to this value if the option is omitted from them.</p>
<h4 id="format-6"><a class="header" href="#format-6">Format:</a></h4>
<pre><code>rev:<var style="color:slategrey;">revision</var>;</code></pre>
<h4 id="examples-10"><a class="header" href="#examples-10">Examples:</a></h4>
<pre><code class="language-snort">sid:1000001; rev:1;
</code></pre>
<pre><code class="language-snort">sid:1000001; rev:2;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="classtype"><a class="header" href="#classtype">classtype</a></h1>
<p>The <code>classtype</code> assigns a classification to the rule to indicate the type of attack associated with an event. Snort provides a list of default classifications that rule-writers can use to better organize rule event data.</p>
<p>Note that a rule should only have one <code>classtype</code> declaration.</p>
<p>Attack classifications provided by Snort reside in the <code>snort_defaults.lua</code> configuration file, and they use a table syntax like so with three entries:</p>
<pre><code class="language-lua">{ name = 'attempted-user', priority = 1,
      text = 'Attempted User Privilege Gain' }
</code></pre>
<p>Snort's current default classifications use priority values 1-4, with 1 being the most severe and 4 being the least severe. The following is a table of all default classifications provided by Snort:</p>
<table><thead><tr><th>Classtype</th><th>Description</th><th>Priority</th></tr></thead><tbody>
<tr><td><code>not-suspicious</code></td><td>Not Suspicious Traffic</td><td>3</td></tr>
<tr><td><code>unknown</code></td><td>Unknown Traffic</td><td>3</td></tr>
<tr><td><code>bad-unknown</code></td><td>Potentially Bad Traffic</td><td>2</td></tr>
<tr><td><code>attempted-recon</code></td><td>Attempted Information Leak</td><td>2</td></tr>
<tr><td><code>successful-recon-limited</code></td><td>Information Leak</td><td>2</td></tr>
<tr><td><code>successful-recon-largescale</code></td><td>Large Scale Information Leak</td><td>2</td></tr>
<tr><td><code>attempted-dos</code></td><td>Attempted Denial of Service</td><td>2</td></tr>
<tr><td><code>successful-dos</code></td><td>Denial of Service</td><td>2</td></tr>
<tr><td><code>attempted-user</code></td><td>Attempted User Privilege Gain</td><td>1</td></tr>
<tr><td><code>unsuccessful-user</code></td><td>Unsuccessful User Privilege Gain</td><td>1</td></tr>
<tr><td><code>succesful-user</code></td><td>Successful User Privilege Gain</td><td>1</td></tr>
<tr><td><code>attempted-admin</code></td><td>Attempted Administrator Privilege Gain</td><td>1</td></tr>
<tr><td><code>successful-admin</code></td><td>Successful Administrator Privilege Gain</td><td>1</td></tr>
<tr><td><code>rpc-portmap-decode</code></td><td>Decode of an RPC Query</td><td>2</td></tr>
<tr><td><code>shellcode-detect</code></td><td>Executable code was detected</td><td>1</td></tr>
<tr><td><code>string-detect</code></td><td>A suspicious string was detected</td><td>3</td></tr>
<tr><td><code>suspicious-filename-detect</code></td><td>A suspicious filename was detected</td><td>2</td></tr>
<tr><td><code>suspicious-login</code></td><td>An attempted login using a suspicious username was detected</td><td>2</td></tr>
<tr><td><code>system-call-detect</code></td><td>A system call was detected</td><td>2</td></tr>
<tr><td><code>tcp-connection</code></td><td>A TCP connection was detected</td><td>4</td></tr>
<tr><td><code>trojan-activity</code></td><td>A Network Trojan was detected</td><td>1</td></tr>
<tr><td><code>unusual-client-port-connection</code></td><td>A client was using an unusual port</td><td>2</td></tr>
<tr><td><code>network-scan</code></td><td>Detection of a Network Scan</td><td>3</td></tr>
<tr><td><code>denial-of-service</code></td><td>Detection of a Denial of Service Attack</td><td>2</td></tr>
<tr><td><code>non-standard-protocol</code></td><td>Detection of a non-standard protocol or event</td><td>2</td></tr>
<tr><td><code>protocol-command-decode</code></td><td>Generic Protocol Command Decode</td><td>3</td></tr>
<tr><td><code>web-application-activity</code></td><td>Access to a potentially vulnerable web application</td><td>2</td></tr>
<tr><td><code>web-application-attack</code></td><td>Web Application Attack</td><td>1</td></tr>
<tr><td><code>misc-activity</code></td><td>Misc Activity</td><td>3</td></tr>
<tr><td><code>misc-attack</code></td><td>Misc Attack</td><td>2</td></tr>
<tr><td><code>icmp-event</code></td><td>Generic ICMP event</td><td>3</td></tr>
<tr><td><code>inappropriate-content</code></td><td>Inappropriate Content was Detected</td><td>1</td></tr>
<tr><td><code>policy-violation</code></td><td>Potential Corporate Privacy Violation</td><td>1</td></tr>
<tr><td><code>default-login-attempt</code></td><td>Attempt to login by a default username and password</td><td>2</td></tr>
<tr><td><code>sdf</code></td><td>Sensitive Data</td><td>2</td></tr>
<tr><td><code>file-format</code></td><td>Known malicious file or file based exploit</td><td>1</td></tr>
<tr><td><code>malware-cnc</code></td><td>Known malware command and control traffic</td><td>1</td></tr>
<tr><td><code>client-side-exploit</code></td><td>Known client side exploit attempt</td><td>1</td></tr>
</tbody></table>
<h4 id="format-7"><a class="header" href="#format-7">Format</a></h4>
<pre><code>classtype:<var style="color:slategrey;">classification</var>;</code></pre>
<h4 id="examples-11"><a class="header" href="#examples-11">Examples:</a></h4>
<pre><code class="language-snort">classtype:web-application-attack;
</code></pre>
<pre><code class="language-snort">classtype:attempted-user;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="priority"><a class="header" href="#priority">priority</a></h1>
<p>The <code>priority</code> option assigns a severity level to a given rule to enable appropriate event prioritizing. Although the builtin classifications set with <code>classtype</code> come with their own priority levels, rule writers can override those by using the <code>priority</code> option.</p>
<p>Valid priority levels are 1-2147483647, with 1 being the most severe and 2147483647 being the least severe.</p>
<p>A given rule should only have one <code>priority</code> declaration.</p>
<h4 id="format-8"><a class="header" href="#format-8">Format:</a></h4>
<pre><code>priority:<var style="color:slategrey;">severity_level</var>;</code></pre>
<h4 id="examples-12"><a class="header" href="#examples-12">Examples:</a></h4>
<pre><code class="language-snort">priority:1;
</code></pre>
<pre><code class="language-snort">priority:10;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="metadata"><a class="header" href="#metadata">metadata</a></h1>
<p>The <code>metadata</code> option adds additional and arbitrary information to a rule in the form of key-value pairs. There are a few keys that have special meanings to Snort and Snort products (such as <code>policy</code>), but generally speaking this option is free-form and can contain arbitrary keys and values.</p>
<p>Key-value pairs set in this option are separated by spaces, and rule writers can also include multiple key-value pairs in this option by separating them with commas. It's important to note that a key's value <em>can</em> have spaces in it, but it's that <em>first</em> space that separates the key from the value.</p>
<blockquote>
<p><strong>Note</strong>: Service declarations were made in the <code>metadata</code> option in Snort 2, but Snort 3 has moved these declarations to an entirely new keyword, <code>service</code>. </p>
</blockquote>
<h4 id="format-9"><a class="header" href="#format-9">Format:</a></h4>
<pre><code>metadata:<var style="color:slategrey;">key</var> <var style="color:slategrey;">value</var>[, <var style="color:slategrey;">key</var> <var style="color:slategrey;">value</var>]…;</code></pre>
<h4 id="examples-13"><a class="header" href="#examples-13">Examples:</a></h4>
<pre><code class="language-snort">metadata:policy max-detect-ips drop;
</code></pre>
<pre><code class="language-snort">metadata:policy max-detect-ips drop, policy security-ips drop;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="service"><a class="header" href="#service">service</a></h1>
<p>The <code>service</code> rule option is used to tell Snort what application-layer service or services you want your rule to apply to. When Snort receives traffic, one of the things it will do first is determine the service of the traffic so that it can process and parse it correctly, and rule writers can target those services using this <code>service</code> rule option.</p>
<p>This rule option takes as arguments one or more comma-separated service <em>names</em>. The names of services that can be used here can be found by looking at the wizard entries in the <code>snort_defauls.lua</code> file included in the <code>lua/</code> directory, as well as the curse service names present in the <code>curse_map</code> in <code>src/service_inspectors/wizard/curses.cc</code>.</p>
<p>Note that Snort handles services specified in this rule option differently than how it handles a service specified in the rule <em>header</em> (as seen <a href="rules/headers/protocols.htm">here</a> and <a href="rules/headers/service_rules.htm">here</a>). More specifically, with <em>this</em> rule option, the services specified <strong>do not</strong> have to match the actual service of the traffic <strong>as long as the <a href="rules/headers/ports.htm">ports</a> match</strong>. Additionally, the converse of that statement is true as well; the <em>ports</em> do not have to match as long as the services match. Another way to look at the <code>service</code> option is like an &quot;OR ports&quot; statement.</p>
<p>For instance, if the source or destination ports present in a rule's header match those used in the traffic, but the service specified in the rule does not match the service present in the traffic, the rule can still match as long as the rest of the rule evaluates to true. The following rule, for example, will apply <strong>either</strong> to traffic Snort detects as HTTP or traffic that is destined for TCP port <code>8000</code>:</p>
<pre><code class="language-snort">alert tcp any any -&gt; any any 8000 (
    msg:&quot;HTTP traffic or dst port 8000 please&quot;;
    service:http;
    sid:1000000;
)
</code></pre>
<p>Note that if you are already specifying a service in the rule header or creating a <a href="rules/headers/file_rules.htm">file rule</a>, then you should not include this <code>service</code> rule option in your rule.</p>
<blockquote>
<p><strong>Note:</strong> This rule option should be used instead of placing service declarations in the <code>metadata</code> option like what was done in Snort 2.</p>
</blockquote>
<h4 id="format-10"><a class="header" href="#format-10">Format:</a></h4>
<pre><code>service:<var style="color:slategrey;">service</var>[,<var style="color:slategrey;">service</var>]…;</code></pre>
<h4 id="examples-14"><a class="header" href="#examples-14">Examples:</a></h4>
<pre><code class="language-snort">service:http;
</code></pre>
<pre><code class="language-snort">service:http,imap,pop3;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rem"><a class="header" href="#rem">rem</a></h1>
<p>The <code>rem</code> rule option is used to convey an arbitrary comment in the rule body. This option has no effect on detection and should be used simply to provide meta information about the rule its in.</p>
<p>This option takes in a single argument, a string enclosed in double quotes.</p>
<h4 id="format-11"><a class="header" href="#format-11">Format:</a></h4>
<pre><code>rem:"<var style="color:slategrey;">comment_string</var>";</code></pre>
<h4 id="examples-15"><a class="header" href="#examples-15">Examples:</a></h4>
<pre><code class="language-snort">rem:&quot;check for a malicious URI string&quot;;
http_uri;
content:&quot;/php_backdoor.php&quot;; 
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="file_meta"><a class="header" href="#file_meta">file_meta</a></h1>
<p>The <code>file_meta</code> rule option is used to set the file metadata for a given <a href="rules/headers/file_id_rules.htm">file identification rule</a>. This option sets the type name, numerical id value, category, groups, and version for the file that will be matched.</p>
<p>This rule option has two required arguments:</p>
<ol>
<li><code>type <var>type</var></code>: string to give the file identifier a name</li>
<li><code>id <var>type_id</var></code>: integer value that should be unique to this particular file identifier rule</li>
</ol>
<p>There are also three additional optional arguments that rule-writers can use to add greater specificity to the <code>file_id</code> rule:</p>
<ol>
<li><code>category <var>type_category</var></code>: string that sets the category of the file being identified</li>
<li><code>group <var>type_groups</var></code>: string that contains a list of groups—separated by commas—associated with that particular file type</li>
<li><code>version <var>type_version</var></code>: string that sets the version of the particular file that's being identified</li>
</ol>
<p>Each of these arguments is separated by commas.</p>
<blockquote>
<p><strong>Note</strong>: This rule option should only be used in <code>file_id</code> rules.</p>
</blockquote>
<h4 id="format-12"><a class="header" href="#format-12">Format:</a></h4>
<pre><code>file_meta:type <var style="color:slategrey;">type</var>, id <var style="color:slategrey;">type_id</var>[, category "<var style="color:slategrey;">type_category</var>"] \
          [, group "<var style="color:slategrey;">type_groups</var>"][, version "<var style="color:slategrey;">type_version</var>"];</code></pre>
<h4 id="examples-16"><a class="header" href="#examples-16">Examples:</a></h4>
<pre><code class="language-snort"># defines the parameters for Windows/DOS executable files
file_meta:type MSEXE, id 21, category &quot;Executables,Dynamic Analysis Capable&quot;; 
</code></pre>
<pre><code class="language-snort">file_meta:type PDF, id 282, category &quot;PDF files&quot;, version &quot;1.0&quot;; 
</code></pre>
<pre><code class="language-snort">file_meta:type MOV, id 4, category &quot;Multimedia&quot;, group &quot;video&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="payload-detection-rule-options"><a class="header" href="#payload-detection-rule-options">Payload Detection Rule Options</a></h1>
<p>Snort rules are best at evaluating a network packet's &quot;payload&quot; (e.g., the TCP or UDP data fields), and this chapter covers what are referred to as &quot;payload detection&quot; options. These options tell Snort <em>what</em> kind of packet data to look for, <em>where</em> to look for that data, and lastly <em>how</em> to look for said data. </p>
<p>A single Snort rule can contain multiple options, and those options are evaluated against the packet data in the order they are placed in the rule (except for certain <code>fast_pattern</code> matches).</p>
<h2 id="inspection-buffers"><a class="header" href="#inspection-buffers">Inspection Buffers</a></h2>
<p>When Snort receives network traffic and begins processing, it places the packet data into various &quot;buffers&quot; that rule writers can evaluate payload options against. Snort provides buffers for the raw packet data, normalized packet data, &quot;file&quot; data, individual HTTP elements, like <code>http_header</code> and <code>http_uri</code>, and more. Not all buffers will be available for a given packet, and so rule writers should use table at the end of this page to make sure they are using the appropriate one(s).</p>
<p>As Snort evaluates payload options against a given buffer, it keeps track of its current location there with a detection-offset-end (DOE) pointer (also sometimes referred to as a cursor). By default, this pointer points to the start of the current buffer, but some rule options will &quot;move&quot; this pointer forward and backwards, which allow for the use of relative payload options.</p>
<h3 id="sticky-buffers"><a class="header" href="#sticky-buffers">Sticky buffers</a></h3>
<p>By default, rule options are evaulated against data present in the <code>pkt_data</code> buffer. Looking for data in one of the other buffers is done by using what are called &quot;sticky buffers&quot;, which are rule options that, when set, move the DOE pointer to the start of that particular buffer. Then, all subsequent payload options will be looked for in that buffer unless some other sticky buffer is specified.</p>
<p>One of those sticky buffers, for example, is <code>http_uri</code>, which contains the URI portion of an HTTP request. Setting this buffer and looking for data there might be done like so:</p>
<pre><code class="language-snort">http_uri;
content:&quot;/index.php&quot;;
</code></pre>
<blockquote>
<p><strong>Note</strong>: Depending on one's Snort configuration, Snort will place certain payload data—such as HTTP-specific elements—<strong>only</strong> in their respective buffers. This means, for example, that trying to look for HTTP request elements in the default, normalized packet data buffer will result in a detection failure.</p>
</blockquote>
<p>This section breaks down each of those rule payload options to explain how they are used and how they work, starting with the <code>content</code> option.</p>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<table><thead><tr><th>keyword</th><th>description</th></tr></thead><tbody>
<tr><td><a href="rules/options/payload/content.htm">content</a></td><td><code>content</code> is used to perform basic string and/or hexadecimal pattern matching</td></tr>
<tr><td><a href="rules/options/payload/fast_pattern.htm">fast_pattern</a></td><td><code>fast_pattern</code> is a <code>content</code> modifier that tells Snort to use that particular match to determine if further rule processing should continue against the traffic</td></tr>
<tr><td><a href="rules/options/payload/nocase.htm">nocase</a></td><td><code>nocase</code> is a <code>content</code> modifier that tells Snort to ignore case when looking for a specified pattern</td></tr>
<tr><td><a href="rules/options/payload/oddw.htm#offset">offset</a></td><td><code>offset</code> is a <code>content</code> modifier that specifies where to start searching for a pattern relative to the beginning of the packet or buffer</td></tr>
<tr><td><a href="rules/options/payload/oddw.htm#depth">depth</a></td><td><code>depth</code> is a <code>content</code> modifier that specifies how far into a Snort packet or buffer to look for the specified pattern relative to the beginning of the packet or buffer</td></tr>
<tr><td><a href="rules/options/payload/oddw.htm#distance">distance</a></td><td><code>distance</code> is a <code>content</code> modifier that specifies where to start searching for a pattern relative to the previous content match</td></tr>
<tr><td><a href="rules/options/payload/oddw.htm#within">within</a></td><td><code>within</code> is a <code>content</code> modifier that specifies how far into a Snort packet or buffer to look for the specified pattern relative to the previous content match</td></tr>
<tr><td><a href="rules/options/payload/http/index.htm">HTTP buffers</a></td><td><code>http_*</code> options are sticky buffer declarations that set the detection cursor to the beginning of the various HTTP parts</td></tr>
<tr><td><a href="rules/options/payload/bufferlen.htm">bufferlen</a></td><td><code>bufferlen</code> checks the length of a given buffer</td></tr>
<tr><td><a href="rules/options/payload/isdataat.htm">isdataat</a></td><td><code>isdataat</code> verifies the payload data exists at a specified location</td></tr>
<tr><td><a href="rules/options/payload/dsize.htm">dsize</a></td><td><code>dsize</code> tests packet payload size</td></tr>
<tr><td><a href="rules/options/payload/pcre.htm">pcre</a></td><td><code>pcre</code> is used to create perl compatible regular expressions</td></tr>
<tr><td><a href="rules/options/payload/regex.htm">regex</a></td><td><code>regex</code> is used to create perl compatible regular expressions that are checked against payload data with the hyperscan engine</td></tr>
<tr><td><a href="rules/options/payload/pkt_data.htm">pkt_data</a></td><td><code>pkt_data</code> is a sticky buffer declaration that sets the detection cursor to the beginning of the normalized packet data</td></tr>
<tr><td><a href="rules/options/payload/raw_data.htm">raw_data</a></td><td><code>raw_data</code> is a sticky buffer declaration that sets the detection cursor to the beginning of the raw packet data</td></tr>
<tr><td><a href="rules/options/payload/file_data.htm">file_data</a></td><td><code>file_data</code> is a sticky buffer declaration that sets the detection cursor to either the HTTP response body for HTTP traffic or file data sent via other application protocols that has been processed and captured by Snort's &quot;file API&quot;</td></tr>
<tr><td><a href="rules/options/payload/js_data.htm">js_data</a></td><td><code>js_data</code> is a sticky buffer declaration that sets the detection cursor to the normalized JavaScript data buffer</td></tr>
<tr><td><a href="rules/options/payload/vba_data.htm">vba_data</a></td><td><code>vba_data</code> is a sticky buffer declaration that sets the detection cursor to the buffer containing VBA macro code</td></tr>
<tr><td><a href="rules/options/payload/base64.htm#base64_decode">base64_decode</a></td><td><code>base64_decode</code> is used to decode base64-encoded data in a packet</td></tr>
<tr><td><a href="rules/options/payload/base64.htm#base64_data">base64_data</a></td><td><code>base64_data</code> is a sticky buffer declaration that sets the detection cursor to the beginning of the base64 decoded buffer</td></tr>
<tr><td><a href="rules/options/payload/byte_extract.htm">byte_extract</a></td><td><code>byte_extract</code> reads some number of bytes from packet data and stores the extracted byte or bytes into a named variable</td></tr>
<tr><td><a href="rules/options/payload/byte_test.htm">byte_test</a></td><td><code>byte_test</code> tests a byte or multiple bytes from the packet against a specific value with a specified operator</td></tr>
<tr><td><a href="rules/options/payload/byte_math.htm">byte_math</a></td><td><code>byte_math</code> extracts bytes from the packet and performs a mathematical operation on the extracted value, storing the result in a new variable</td></tr>
<tr><td><a href="rules/options/payload/byte_jump.htm">byte_jump</a></td><td><code>byte_jump</code> reads some number of bytes from the packet, converts them from their numeric representation if necessary, and moves that many bytes forward</td></tr>
<tr><td><a href="rules/options/payload/ber.htm">ber_data and ber_skip</a></td><td><code>ber_*</code> rule options evaluate and work with BER-encoded data</td></tr>
<tr><td><a href="rules/options/payload/ssl.htm">ssl_state and ssl_version</a></td><td><code>ssl_*</code> rule options evaluate and work with SSL/TLS sessions</td></tr>
<tr><td><a href="rules/options/payload/dce.htm">DCE Specific Options</a></td><td><code>dce_*</code> rule options evaluate and work with DCERPC traffic</td></tr>
<tr><td><a href="rules/options/payload/sip.htm">SIP Specific Options</a></td><td><code>sip_*</code> rule options evaluate and work with SIP traffic</td></tr>
<tr><td><a href="rules/options/payload/sd_pattern.htm">sd_pattern</a></td><td><code>sd_pattern</code> detects sensitive data, such as credit card and social security numbers</td></tr>
<tr><td><a href="rules/options/payload/cvs.htm">cvs</a></td><td><code>cvs</code> looks for a specific attack types</td></tr>
<tr><td><a href="rules/options/payload/hash.htm">md5, sha256, and sha512</a></td><td><code>md5</code>, <code>sha256</code>, and <code>sha512</code> check payload data against a specified hash value</td></tr>
<tr><td><a href="rules/options/payload/gtp.htm">GTP Specific Options</a></td><td><code>gtp_*</code> rule options evaluate specific elements of GTP traffic</td></tr>
<tr><td><a href="rules/options/payload/dnp3.htm">DNP3 Specific Options</a></td><td><code>dnp3_*</code> rule options evaluate specific elements of DNP3 traffic</td></tr>
<tr><td><a href="rules/options/payload/cip.htm">CIP Specific Options</a></td><td><code>cip_*</code> rule options evaluate specific elements of CIP traffic</td></tr>
<tr><td><a href="rules/options/payload/iec104.htm">IEC 104 Specific Options</a></td><td><code>iec104_*</code> rule options evaluate specific elements of IEC 104 traffic</td></tr>
<tr><td><a href="rules/options/payload/mms.htm">MMS Specific Options</a></td><td><code>mms_*</code> rule options evaluate specific elements of MMS traffic</td></tr>
<tr><td><a href="rules/options/payload/modbus.htm">Modbus Specific Options</a></td><td><code>modbus_*</code> rule options evaluate specific elements of Modbus traffic</td></tr>
<tr><td><a href="rules/options/payload/s7commplus.htm">S7CommPlus Specific Options</a></td><td><code>s7commplus_*</code> rule options evaluate specific elements of S7CommPlus traffic</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="content"><a class="header" href="#content">content</a></h1>
<p>The first option we will discuss is <code>content</code>, which is used to perform basic pattern matching against packet data. This option is declared with the <code>content</code> keyword, followed by a <code>:</code> character, and lastly followed the content string enclosed in double quotes. Matches can also be &quot;negated&quot; with a <code>!</code> character immediately after the colon, telling Snort only to handle packets that <em>do not</em> contain some string or hex sequence.</p>
<p>Content matches can contain ASCII strings, hex bytes, or a mix of both. Hex bytes must be enclosed in <code>|</code> characters. </p>
<p>A rule can contain multiple content matches, and each match is evaluated in the order they are declared in the rule (except <code>fast_pattern</code> matches, which is discussed in the next chapter). This means of course that Snort will continue checking subsequent matches against packet data as long as the content checks continue to pass. As a result, it's often times beneficial to place the most unique sequence of mathces towards the top of the rule to allow Snort the opportunity to exit processing early.</p>
<h4 id="format-13"><a class="header" href="#format-13">Format:</a></h4>
<pre><code>content:[!]"<var style="color:slategrey;">content_string</var>";</code></pre>
<h4 id="examples-17"><a class="header" href="#examples-17">Examples:</a></h4>
<pre><code class="language-snort"># Simple ascii string match
content:&quot;USER root&quot;;
</code></pre>
<pre><code class="language-snort"># Combining of ascii characters and hex bytes
content:&quot;PK|03 04|&quot;;
</code></pre>
<blockquote>
<p><strong>Note:</strong> Certain characters must be either escaped (with '\' characters) or encoded in hex. These are: ';', '\', and '&quot;'.</p>
</blockquote>
<h3 id="content-match-modifiers"><a class="header" href="#content-match-modifiers">Content match modifiers</a></h3>
<p>Snort content matches can be written with option modifiers to set additional evaluation requirements for a given content match, offering users greater specificity when defining rule parameters.</p>
<p>These modifiers include <code>fast_pattern</code>, <code>nocase</code>, <code>within</code>, <code>distance</code>, <code>offset</code>, and <code>depth</code>, and they are written alongside the content string, separated by commas. Certain modifiers also require &quot;arguments&quot; that define the parameters to go along with them.</p>
<h4 id="format-14"><a class="header" href="#format-14">Format:</a></h4>
<pre><code>, <var style="color:slategrey;">content_modifer</var> [<var style="color:slategrey;">content_modifer_argument</var>]</code></pre>
<h4 id="examples-18"><a class="header" href="#examples-18">Examples:</a></h4>
<pre><code class="language-snort">content:&quot;pizza&quot;, nocase; 
</code></pre>
<pre><code class="language-snort">content:&quot;cheese&quot;;
content:&quot; pizza&quot;, within 6;
</code></pre>
<p>We will talk about each one content match modifier in depth in the ensuing sections, starting with the <code>fast_pattern</code> option.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="fast_pattern"><a class="header" href="#fast_pattern">fast_pattern</a></h1>
<p>Snort's fast pattern matcher is crucial for performance, as it helps determine which packets qualify for the additional processing that comes with rule option evaluation. At a high-level, the fast pattern engine uses a single content match from a rule and evaluates it against the packet to determine if further rule processing should continue against the traffic. The ideal fast pattern is one which, if found, is very likely to result in a rule match. Fast patterns that match frequently against unrelated traffic will cause Snort to work hard with little to show for it.</p>
<p>Fast pattern matches are either explicitly set with the <code>fast_pattern</code> option or set automatically to the longest content match if the option is not specified. However, it's important to keep in mind that the longest pattern is sometimes not the most unique, and so one can add the <code>fast_pattern</code> modifier to a content option to maximize performance.</p>
<p>During rule evaluation, the content string selected as the <code>fast_pattern</code> match will <em>automatically be skipped if possible</em>. This is a change from Snort 2. Previously, users would have to specify <code>fast_pattern:only</code> to evaluate a fast_pattern match only once; Snort 3 now intelligently evaluates the <code>fast_pattern</code> match only once if it is able.</p>
<blockquote>
<p><strong>Note:</strong> Certain buffers are not eligible to contain <code>fast_pattern</code> content matches, and those include the following: <code>http_raw_cookie</code>, <code>http_param</code>, <code>http_raw_body</code>, <code>http_version</code>, <code>http_raw_request</code>, <code>http_raw_status</code>, <code>http_raw_trailer</code>, and <code>http_true_ip</code>.</p>
</blockquote>
<h4 id="format-15"><a class="header" href="#format-15">Format:</a></h4>
<pre><code>fast_pattern
</code></pre>
<h4 id="example-3"><a class="header" href="#example-3">Example:</a></h4>
<pre><code class="language-snort">content:&quot;super_secret_encryption_key&quot;,fast_pattern;
</code></pre>
<h3 id="fast_pattern_offset-fast_pattern_length"><a class="header" href="#fast_pattern_offset-fast_pattern_length">fast_pattern_offset, fast_pattern_length</a></h3>
<p>Users can also specify that only a portion of a content match be used as as <code>fast_pattern</code>. This is specified with two modifiers, <code>fast_pattern_offset</code> and <code>fast_pattern_length</code>. The former sets the number of leading characters of this content the fast pattern should exclude, while the latter sets the number of characters from this content to include in the fast pattern matcher. Valid values are 0:65535 and 1:65535 for offset and length, respectively.</p>
<h4 id="format-16"><a class="header" href="#format-16">Format:</a></h4>
<pre><code>fast_pattern_offset <var style="color:slategrey;">offset</var>, fast_pattern_length <var style="color:slategrey;">length</var></code></pre>
<h4 id="example-4"><a class="header" href="#example-4">Example:</a></h4>
<pre><code class="language-snort"># Only the &quot;/not_a_cnc_endpoint.php&quot; portion of the match is used as the fast pattern
content:&quot;/index/not_a_cnc_endpoint.php&quot;,fast_pattern_offset 6,fast_pattern_length 23;
</code></pre>
<p>This above option will, however, still evaluate the full content match normally as long as the fast pattern check is successful.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="nocase"><a class="header" href="#nocase">nocase</a></h1>
<p>Content matches are case-sensitive by default, but the <code>nocase</code> content modifier tells Snort to ignore case and look for the specified string match case-insensitively.</p>
<h4 id="format-17"><a class="header" href="#format-17">Format:</a></h4>
<pre><code>nocase
</code></pre>
<h4 id="examples-19"><a class="header" href="#examples-19">Examples:</a></h4>
<pre><code class="language-snort">content:&quot;/index/vulnerable_endpoint.php&quot;,nocase;
</code></pre>
<pre><code class="language-snort"># It is common to see nocase used with `fast_pattern` 
content:&quot;super_secret_encryption_key&quot;,fast_pattern,nocase;
</code></pre>
<blockquote>
<p><strong>Note:</strong> The <code>nocase</code> option also applies to hex bytes; specifying <code>content:&quot;|41|&quot;,nocase;</code> will look for either 'A' <em>or</em> 'a' in the packet.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="offset-depth-distance-and-within"><a class="header" href="#offset-depth-distance-and-within">offset, depth, distance, and within</a></h2>
<p>These four content modifiers, <code>depth</code>, <code>offset</code>, <code>distance</code>, and <code>within</code>, let rule writers specify where to look for a given pattern relative to either the start of a packet or a previous content match. These four options, however, let users write nuanced rules to look for matches at specific locations. More specifically, <code>depth</code> and <code>offset</code> are used to look for a match relative to the start of a packet or buffer, whereas <code>distance</code> and <code>within</code> are instead relative to a previous content match. </p>
<h3 id="offset"><a class="header" href="#offset">offset</a></h3>
<p>The <code>offset</code> modifier allows the rule writer to specify where to start searching for a pattern relative to the beginning of the packet or buffer. So, an offset of 5 would tell Snort to look for the specified pattern after the first 5 bytes of the payload.</p>
<p>This keyword allows values from -65535 to 65535, and it can also be set to a string value referencing a variable extracted by the <code>byte_extract</code> keyword in the same rule.</p>
<h4 id="format-18"><a class="header" href="#format-18">Format:</a></h4>
<pre><code>offset {<var style="color:slategrey;">offset</var>|<var style="color:slategrey;">variable_name</var>}</code></pre>
<h4 id="example-5"><a class="header" href="#example-5">Example:</a></h4>
<pre><code class="language-snort">content:&quot;|FE|SMB&quot;, offset 4; 
</code></pre>
<h3 id="depth"><a class="header" href="#depth">depth</a></h3>
<p>The <code>depth</code> modifier allows the rule writer the ability to specify how far into a Snort packet or buffer to look for the specified pattern. For example, setting <code>depth</code> to 5 would tell Snort to only look for the pattern within the first 5 bytes of the payload. </p>
<p>Specifying <code>depth</code> without offset will implicitly look at the start of the payload (offset 0), so there's no need to specify an additional <code>offset 0</code> option in those cases.</p>
<p>The value chosen must be greater than or equal to the length of the content string, and the max value is 65535. It can also be set to a string value referencing a variable extracted by the <code>byte_extract</code> keyword in the same rule.</p>
<h4 id="format-19"><a class="header" href="#format-19">Format:</a></h4>
<pre><code>depth {<var style="color:slategrey;">depth</var>|<var style="color:slategrey;">variable_name</var>}</code></pre>
<h4 id="examples-20"><a class="header" href="#examples-20">Examples:</a></h4>
<pre><code class="language-snort"># Can combine depth and offset for a single content match
content:&quot;|FE|SMB&quot;, depth 4, offset 4; 
</code></pre>
<pre><code class="language-snort">content:&quot;PK|03 04|&quot;, depth 4; 
</code></pre>
<h3 id="distance"><a class="header" href="#distance">distance</a></h3>
<p>The <code>distance</code> keyword is similar to <code>offset</code> but is relative to a preceding content match instead of the start of the payload/buffer. It tells Snort to look skip <em>X</em> number of bytes after the last content match before looking for this one.</p>
<p>This keyword allows values from -65535 to 65535, and it can also be set to a string value referencing a variable extracted by the <code>byte_extract</code> keyword in the same rule.</p>
<h4 id="format-20"><a class="header" href="#format-20">Format:</a></h4>
<pre><code>distance {<var style="color:slategrey;">distance</var>|<var style="color:slategrey;">variable_name</var>}</code></pre>
<h4 id="example-6"><a class="header" href="#example-6">Example:</a></h4>
<pre><code class="language-snort">content:&quot;ABC&quot;; 
content:&quot;EFG&quot;, distance 1;
</code></pre>
<blockquote>
<p><strong>Note:</strong> To put this example in the context of cursors, the &quot;ABC&quot; match moves the detection cursor to point to the byte immediately after the 'C' character. And then the <code>distance 1</code> modifier in the very next match tells Snort not to reset the cursor back to the beginning of the buffer, but to instead increase the cursor by 1 so that it points to second byte in the buffer after the 'C' character.</p>
</blockquote>
<h3 id="within"><a class="header" href="#within">within</a></h3>
<p>The <code>within</code> keyword is similar to <code>depth</code> but is relative to a preceding content match instead of the start of the payload. It tells Snort to look this content match within <em>X</em> number of bytes of the last one.</p>
<p>Specifying <code>within</code> without distance will implicitly look immediately after the last content match, so there's no need to specify an additional <code>distance 0</code> option in those cases.</p>
<p>The value chosen must be greater than or equal to the length of the content string, and the max value is 65535. It can also be set to a string value referencing a variable extracted by the <code>byte_extract</code> keyword in the same rule.</p>
<h4 id="format-21"><a class="header" href="#format-21">Format:</a></h4>
<pre><code>within {<var style="color:slategrey;">within</var>|<var style="color:slategrey;">variable_name</var>}</code></pre>
<h4 id="examples-21"><a class="header" href="#examples-21">Examples:</a></h4>
<pre><code class="language-snort">content:&quot;ABC&quot;; 
content:&quot;EFG&quot;, within 10;
</code></pre>
<pre><code class="language-snort"># Distance and within can be used together
content:&quot;ABC&quot;; 
content:&quot;EFG&quot;, distance 1, within 3;
</code></pre>
<pre><code class="language-snort">content:&quot;DEF&quot;; 
content:&quot;GHI&quot;, within 3;
</code></pre>
<blockquote>
<p><strong>Note:</strong> Content matches specified without any of these four modifiers will always be looked for starting from the beginning of (1) the default buffer or (2) an explicitly-set sticky buffer. </p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> Rule writers are free to use all four options in a single rule, but only <code>distance</code> and <code>within</code> and <code>offset</code> and <code>depth</code> can appear together attached a single content match. For example, the second content option in <code>content:&quot;DEF&quot;; content:&quot;GHI&quot;, offset 6, within 3;</code> is not valid due to the combination of <code>offset</code> and <code>within</code>. </p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http-specific-options"><a class="header" href="#http-specific-options">HTTP Specific Options</a></h1>
<p>Snort operates with a bevy of &quot;service inspectors&quot; that can identify specific TCP/UDP applications and divide the application data into distinct buffers. One of those service inspectors that does exactly this is the &quot;HTTP inspector&quot;. </p>
<p>Whenever HTTP traffic is detected in a packet, the HTTP service inspector scans the payload data to parse the different HTTP elements (e.g., URIs, headers, methods, etc.) and populates individual buffers with those different pieces. This powerful inspector allows rule writers to then develop rules with content matches targeting only specific parts of an HTTP packet.</p>
<p>Most HTTP options in Snort 3 rules are &quot;sticky buffers&quot;, as opposed to content-modifiers like they were in Snort 2, meaning they should be placed <em>before</em> a content match option to set the desired buffer (e.g., <code>http_uri; content:&quot;/pizza.php&quot;;</code>). In addition to these sticky buffers, there are also a few non-sticky-buffer HTTP rule options that are used to run checks on specific parts of an HTTP message. </p>
<p>This section goes over each of these rule options in great detail, describing how to use each one, what HTTP data is included in each sticky buffer, and how that data gets formatted in the different buffers.</p>
<h4 id="quick-reference-1"><a class="header" href="#quick-reference-1">Quick Reference</a></h4>
<table><thead><tr><th>keyword</th><th>description</th></tr></thead><tbody>
<tr><td><a href="rules/options/payload/http/uri.htm#http_uri">http_uri</a></td><td>Normalized HTTP URI</td></tr>
<tr><td><a href="rules/options/payload/http/uri.htm#http_raw_uri">http_raw_uri</a></td><td>Unnormalized HTTP URI</td></tr>
<tr><td><a href="rules/options/payload/http/header.htm#http_header">http_header</a></td><td>Normalized HTTP headers</td></tr>
<tr><td><a href="rules/options/payload/http/header.htm#http_raw_header">http_raw_header</a></td><td>Unnormalized HTTP headers</td></tr>
<tr><td><a href="rules/options/payload/http/cookie.htm#http_cookie">http_cookie</a></td><td>Normalized HTTP cookies</td></tr>
<tr><td><a href="rules/options/payload/http/cookie.htm#http_raw_cookie">http_raw_cookie</a></td><td>Unnormalized HTTP cookies</td></tr>
<tr><td><a href="rules/options/payload/http/body.htm#http_client_body">http_client_body</a></td><td>Normalized HTTP request body</td></tr>
<tr><td><a href="rules/options/payload/http/body.htm#http_raw_body">http_raw_body</a></td><td>Unnormalized HTTP request body and response data</td></tr>
<tr><td><a href="rules/options/payload/http/param.htm">http_param</a></td><td>Specific HTTP parameter values</td></tr>
<tr><td><a href="rules/options/payload/http/method.htm">http_method</a></td><td>HTTP request methods</td></tr>
<tr><td><a href="rules/options/payload/http/version.htm">http_version</a></td><td>HTTP request and response versions</td></tr>
<tr><td><a href="rules/options/payload/http/stat_code.htm">http_stat_code</a></td><td>HTTP response status codes</td></tr>
<tr><td><a href="rules/options/payload/http/stat_msg.htm">http_stat_msg</a></td><td>HTTP response status messages</td></tr>
<tr><td><a href="rules/options/payload/http/raw_req-raw_status.htm#http_raw_request">http_raw_request</a></td><td>Unnormalized HTTP start lines</td></tr>
<tr><td><a href="rules/options/payload/http/raw_req-raw_status.htm#http_raw_status">http_raw_status</a></td><td>Unnormalized HTTP status lines</td></tr>
<tr><td><a href="rules/options/payload/http/trailer.htm#http_trailer">http_trailer</a></td><td>Normalized HTTP trailers</td></tr>
<tr><td><a href="rules/options/payload/http/trailer.htm#http_raw_trailer">http_raw_trailer</a></td><td>Unnormalized HTTP trailers</td></tr>
<tr><td><a href="rules/options/payload/http/true_ip.htm">http_true_ip</a></td><td>Original client IP address as stored in various request proxy headers</td></tr>
<tr><td><a href="rules/options/payload/http/version_match.htm">http_version_match</a></td><td>Non-sticky buffer option used to test an HTTP message's version against a list of versions</td></tr>
<tr><td><a href="rules/options/payload/http/num_headers.htm">http_num_headers</a></td><td>Non-sticky buffer option used to test the number of HTTP headers against a specific value or a range of values</td></tr>
<tr><td><a href="rules/options/payload/http/num_trailers.htm">http_num_trailers</a></td><td>Non-sticky buffer option used to test the number of HTTP trailers against a specific value or a range of values</td></tr>
<tr><td><a href="rules/options/payload/http/num_cookies.htm">http_num_cookies</a></td><td>Non-sticky buffer option used to test the number of HTTP cookies against a specific value or a range of values</td></tr>
<tr><td><a href="rules/options/payload/http/req_resp_detection.htm">Combining Request and Response Detection</a></td><td>Explains how to create rules that examine an HTTP response and the HTTP request associated with that response</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_uri-and-http_raw_uri"><a class="header" href="#http_uri-and-http_raw_uri">http_uri and http_raw_uri</a></h1>
<p>These two sticky buffers, <code>http_uri</code> and <code>http_raw_uri</code>, look for data in HTTP request URIs. The <code>http_uri</code> buffer contains the full <em>normalized</em> URI whereas the <code>http_raw_uri</code> contains the <em>unnormalized</em> URI.</p>
<p>Snort 3 also parses HTTP URIs into six individual components and makes them available as optional selectors to these two buffers. Those six components are <code>path</code>, <code>query</code>, <code>fragment</code>, <code>host</code>, <code>port</code>, and <code>scheme</code>. </p>
<p>The following HTTP request line contains an absolute URI with all six components, and they are broken down below it:</p>
<pre><code>GET https://www.samplehost.com:287/basic/example/of/path?with-query=value#and-fragment HTTP/1.1\r\n
</code></pre>
<ol>
<li>path -&gt; <code>/basic/example/of/path</code></li>
<li>query -&gt; <code>with-query=value</code></li>
<li>fragment -&gt; <code>#and-fragment</code></li>
<li>host -&gt; <code>www.samplehost.com</code></li>
<li>port -&gt; <code>287</code></li>
<li>scheme -&gt; <code>https</code></li>
</ol>
<p>The contents of the general URI buffer and each individual component depend on request URI type. There are four main URI types that Snort can parse. These include <em>asterisk</em> URIs, which contain just a '*' character, <em>absolute URI</em> URIs, which contain all six components (if they're all present), <em>absolute path</em> URIs, which contain the path, query, and fragment (which is not often sent over the network), and lastly <em>authority</em> URIs, which contain the host and port. </p>
<p>Specifying an optional URI selector is done with a colon after <code>http_uri</code> or <code>http_raw_uri</code> followed by the selector name.</p>
<h2 id="http_uri"><a class="header" href="#http_uri">http_uri</a></h2>
<p>As mentioned above, <code>http_uri</code> sticky buffer searches proceeding payload options in the normalized URI. Snort parses an HTTP request, normalizes anything in the URI that needs normalization, and then places the end-result in the <code>http_uri</code> buffer. This normalization does things like decode percent-encoded values (e.g., &quot;%41%41&quot; -&gt; &quot;AA&quot;), replace backslashes with forward slashes, replace plus characters with spaces, remove path directory traversals, simplify paths (e.g., &quot;/nothing/../to/././././see//////detour/to/nowhere/../.././../example&quot; -&gt; &quot;/very/easy/example&quot;), and more. </p>
<p>There is not an exhaustive list, and some are disabled by default, but the full list can be found in the <a href="https://github.com/snort3/snort3/blob/master/doc/user/http_inspect.txt">http_inspect documentation</a>.</p>
<blockquote>
<p><strong>Note:</strong> Any data in URIs that are not &quot;unnormalized&quot; will of course be left intact and included in the <code>http_uri</code> buffer as-is.</p>
</blockquote>
<h4 id="format-22"><a class="header" href="#format-22">Format:</a></h4>
<pre><code>http_uri[:{scheme|host|port|path|query|fragment}];
</code></pre>
<h4 id="examples-22"><a class="header" href="#examples-22">Examples:</a></h4>
<pre><code class="language-snort">http_uri;
content:&quot;/basic/example/of/path?query=value&quot;,fast_pattern,nocase;
</code></pre>
<pre><code class="language-snort">http_uri;
content:&quot;/basic/example/of/path&quot;,fast_pattern,nocase;
http_uri:query;
content:&quot;query=value&quot;,nocase;
</code></pre>
<h2 id="http_raw_uri"><a class="header" href="#http_raw_uri">http_raw_uri</a></h2>
<p>The <code>http_raw_uri</code> sticky buffer searches proceeding content matches in the <em>unnormalized</em> URI. Testing against this buffer is often useful when one wants to explicitly look for things like percent-encoded data and directory traversal attempts.</p>
<p>Consider the following raw absolute path URI:</p>
<pre><code>/%63%68%6F%63%6F%6C%61%74%65/%63%61%6B%65
</code></pre>
<p>Snort will normalize this data and put the percent-decoded values in the <code>http_uri</code> buffer. However, the <code>http_raw_uri</code> buffer will still contain the URI in its raw form, allowing us to check for this percent-encoded string.</p>
<h4 id="format-23"><a class="header" href="#format-23">Format:</a></h4>
<pre><code>http_raw_uri[:{scheme|host|port|path|query|fragment}];
</code></pre>
<h4 id="examples-23"><a class="header" href="#examples-23">Examples:</a></h4>
<pre><code class="language-snort">http_raw_uri;
content:&quot;/%63%68%6F%63%6F%6C%61%74%65/%63%61%6B%65&quot;;
</code></pre>
<pre><code class="language-snort">http_raw_uri;
content:&quot;../&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_header-and-http_raw_header"><a class="header" href="#http_header-and-http_raw_header">http_header and http_raw_header</a></h1>
<p>Snort makes HTTP request and response headers available in two sticky buffers, <code>http_header</code> and <code>http_raw_header</code>. The <code>http_header</code> buffer contains the <em>normalized</em> request/response headers, whereas the <code>http_raw_header</code> buffer contains <em>unnormalized</em> ones.</p>
<p>The header normalization that occurs is similar to the URI normalization and includes things like percent-decoding and path-simplification.</p>
<p>Snort 3 also allows users the ability to look for content matches in specific HTTP header fields with the optional <code>field <var>header_name</var></code> argument. This option is specified with a colon character after <code>http_header</code>, followed by the word &quot;field&quot;, and lastly followed by the specific header field name (which is case-insensitive). For example:</p>
<pre><code>http_header:field user-agent;
</code></pre>
<p>Specifying individual headers like this creates a more efficient and accurate rule.</p>
<p><code>http_header</code> and <code>http_raw_header</code> also allow for an optional <code>request</code> argument, which is useful if writing detection that looks at both an HTTP client request and the HTTP server response to that request. More specifically, this <code>request</code> argument is used to signify that the <code>http_header</code> or <code>http_raw_header</code> match or matches should apply to the headers from the <em>request</em> if other parts of the rule are examining the <em>response</em>. More information on this topic can be found on <a href="rules/options/payload/http/req_resp_detection.htm">this page</a>.</p>
<h2 id="http_header"><a class="header" href="#http_header">http_header</a></h2>
<h4 id="format-24"><a class="header" href="#format-24">Format:</a></h4>
<pre><code>http_header[:field <var style="color:slategrey;">header_name</var>][,request];</code></pre>
<h4 id="examples-24"><a class="header" href="#examples-24">Examples:</a></h4>
<pre><code class="language-snort">http_header;
content:&quot;User-Agent: abcip&quot;,fast_pattern,nocase;
content:&quot;Accept-Language: en-us&quot;,nocase,distance 0;
</code></pre>
<pre><code class="language-snort"># http_header field name arguments are case-insensitive
http_header:field user-agent;
content:&quot;abcip&quot;;
</code></pre>
<h2 id="http_raw_header"><a class="header" href="#http_raw_header">http_raw_header</a></h2>
<h4 id="format-25"><a class="header" href="#format-25">Format:</a></h4>
<pre><code>http_raw_header[:field <var style="color:slategrey;">header_name</var>][,request];</code></pre>
<h4 id="examples-25"><a class="header" href="#examples-25">Examples:</a></h4>
<pre><code class="language-snort">http_raw_header;
content:&quot;Accept-Language: en-us&quot;,fast_pattern,nocase;
</code></pre>
<pre><code class="language-snort">http_raw_header;
content:&quot;Accept-Language:&quot;,fast_pattern,nocase;
content:&quot;%60whoami&quot;,within 30;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_cookie-and-http_raw_cookie"><a class="header" href="#http_cookie-and-http_raw_cookie">http_cookie and http_raw_cookie</a></h1>
<p>HTTP request and response Cookie values are placed into two sticky buffers, <code>http_cookie</code> and <code>http_raw_cookie</code>. The <code>http_cookie</code> buffer contains the normalized Cookie header values, whereas the <code>http_raw_cookie</code> buffer contains unnormalized ones.</p>
<p>The cookie normalization that occurs is also similar to the URI normalization and includes things like percent-decoding and path-simplification.</p>
<p>Snort 3 has also made <code>http_cookie</code> matches eligible for fast patterns. </p>
<p>If an HTTP request contains multiple Cookie headers, then each Cookie header value is extracted and placed into the two <code>*_cookie</code> buffers, with each full header value separated by commas.</p>
<p>For example, consider the following request with two Cookie headers:</p>
<pre><code>Cookie: name=value; name2=value2; name3=value3
Cookie: name4=value4; name5=value5; name6=value6
</code></pre>
<p>Snort 3 will combine the two Cookie values and place them in the two buffers like so:</p>
<pre><code>[http_cookie]
00000000  6E 61 6D 65 3D 76 61 6C 75 65 3B 20 6E 61 6D 65  name=value; name
00000010  32 3D 76 61 6C 75 65 32 3B 20 6E 61 6D 65 33 3D  2=value2; name3=
00000020  76 61 6C 75 65 33 2C 6E 61 6D 65 34 3D 76 61 6C  value3,name4=val
00000030  75 65 34 3B 20 6E 61 6D 65 35 3D 76 61 6C 75 65  ue4; name5=value
00000040  35 3B 20 6E 61 6D 65 36 3D 76 61 6C 75 65 36     5; name6=value6
</code></pre>
<p>and</p>
<pre><code>[http_raw_cookie]
00000000  6E 61 6D 65 3D 76 61 6C 75 65 3B 20 6E 61 6D 65  name=value; name
00000010  32 3D 76 61 6C 75 65 32 3B 20 6E 61 6D 65 33 3D  2=value2; name3=
00000020  76 61 6C 75 65 33 2C 6E 61 6D 65 34 3D 76 61 6C  value3,name4=val
00000030  75 65 34 3B 20 6E 61 6D 65 35 3D 76 61 6C 75 65  ue4; name5=value
00000040  35 3B 20 6E 61 6D 65 36 3D 76 61 6C 75 65 36     5; name6=value6
</code></pre>
<p>The same is also true for Set-Cookie headers.</p>
<p><code>http_cookie</code> and <code>http_raw_cookie</code> also allow for an optional <code>request</code> argument, which is useful if writing detection that looks at both an HTTP client request and the HTTP server response to that request. More specifically, this <code>request</code> argument is used to signify that the <code>http_cookie</code> or <code>http_raw_cookie</code> match or matches should apply to the cookies from the <em>request</em> if other parts of the rule are examining the <em>response</em>. More information on this topic can be found on <a href="rules/options/payload/http/req_resp_detection.htm">this page</a>.</p>
<blockquote>
<p><strong>Note:</strong> <code>http_cookie</code> matches <em>are</em> eligible for fast patterns, which is a change new to Snort 3. </p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> The &quot;Cookie:&quot; and &quot;Set-Cookie:&quot; portions of these headers are not included in either of the two <code>*_cookie</code> buffers.</p>
</blockquote>
<h2 id="http_cookie"><a class="header" href="#http_cookie">http_cookie</a></h2>
<h4 id="format-26"><a class="header" href="#format-26">Format:</a></h4>
<pre><code>http_cookie[:request];
</code></pre>
<h4 id="examples-26"><a class="header" href="#examples-26">Examples:</a></h4>
<pre><code class="language-snort">http_cookie;
content:&quot;name=value&quot;,depth 10;
</code></pre>
<pre><code class="language-snort">http_cookie;
content:&quot;name=value&quot;,fast_pattern;
content:&quot;name6=value6&quot;,distance 0;
</code></pre>
<h2 id="http_raw_cookie"><a class="header" href="#http_raw_cookie">http_raw_cookie</a></h2>
<h4 id="format-27"><a class="header" href="#format-27">Format:</a></h4>
<pre><code>http_raw_cookie[:request];
</code></pre>
<h4 id="examples-27"><a class="header" href="#examples-27">Examples:</a></h4>
<pre><code class="language-snort">http_raw_cookie;
content:&quot;name=value&quot;;
</code></pre>
<pre><code class="language-snort">http_raw_cookie; 
content:&quot;name=&quot;;
content:&quot;%60whoami&quot;,nocase,within 25;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_client_body-and-http_raw_body"><a class="header" href="#http_client_body-and-http_raw_body">http_client_body and http_raw_body</a></h1>
<p>Snort places HTTP message data into two sticky buffers, <code>http_client_body</code> and <code>http_raw_body</code>. The former contains normalized message <em>request</em> data, while the latter contains unnormalized request <em>and response</em> message data.</p>
<p>The request data normalization that occurs is also similar to the URI normalization and includes things like percent-decoding and path-simplification.</p>
<p>Snort is also able to decompress request and response data (e.g., gzip-compression), and so it will, depending on one's configuration, place the decompressed data in both the <code>http_client_body</code> and <code>http_raw_body</code> buffers. Furthermore, the <code>http_raw_body</code> will contain de-chunked and decompressed data if applicable, but it will not be modified/normalized in any other way.</p>
<h2 id="http_client_body"><a class="header" href="#http_client_body">http_client_body</a></h2>
<h4 id="format-28"><a class="header" href="#format-28">Format:</a></h4>
<pre><code>http_client_body;
</code></pre>
<h4 id="examples-28"><a class="header" href="#examples-28">Examples:</a></h4>
<pre><code class="language-snort">http_client_body;
content:&quot;user=root&quot;,fast_pattern,nocase;
</code></pre>
<pre><code class="language-snort">http_client_body;
content:&quot;pizza_type=&quot;,fast_pattern,nocase;
content:&quot;../&quot;,within 20;
</code></pre>
<h2 id="http_raw_body"><a class="header" href="#http_raw_body">http_raw_body</a></h2>
<h4 id="format-29"><a class="header" href="#format-29">Format:</a></h4>
<pre><code>http_raw_body;
</code></pre>
<h4 id="examples-29"><a class="header" href="#examples-29">Examples:</a></h4>
<pre><code class="language-snort">http_raw_body;
content:&quot;user=root&quot;,nocase;
</code></pre>
<pre><code class="language-snort">http_raw_body; 
content:&quot;pizza_type=&quot;,nocase;
content:&quot;%2e%2e&quot;,nocase,distance 0; 
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_param"><a class="header" href="#http_param">http_param</a></h1>
<p>Rule writers can access the value of a specific HTTP parameter with the <code>http_param</code> sticky buffer. This buffer will contain only the value of the specified parameter. This option is perfect for when rule-writers want to match a particular parameter's value but aren't sure if that parameter is sent via the URI or the client body.</p>
<p>The <code>http_param</code> buffer will be populated with the specified parameter's value whenever that parameter appears in either a query string sent via the URL or in a urlencoded form (key-value pair) sent in the client body. <code>http_param</code> currently <strong>does not</strong> support multipart/form-data requests, and so a separate rule that does not use <code>http_param</code> would be needed in order to detect a parameter sent using a multipart request.</p>
<p>The parameter value <em>will</em> be URL decoded but not path normalized. The parameter name argument is case-sensitive by default, but Snort can be instructed to ignore case by adding <code>,nocase</code> after the param name.</p>
<p>For example, given a request like <code>/food.php?favoriteFood=pizza</code>, users can set the <code>http_param</code> argument to <code>favoriteFood</code> to look only at that param's value.</p>
<p>It is also recommended that rule writers make the first rule option used after <code>http_param</code> &quot;relative&quot; by adding either <code>distance 0</code> to a content match or adding the <code>R</code> flag to a pcre. This is because <code>http_param</code> by default will look at only the first instance of the specified parameter in the request, even if that parameter &quot;key&quot; appears multiple times. Making the first option relative instructs Snort to look at <em>all</em> instances of that parameter.</p>
<blockquote>
<p><strong>Note:</strong> <code>http_param</code> matches <em>are not</em> eligible to be used as fast patterns.</p>
</blockquote>
<h4 id="format-30"><a class="header" href="#format-30">Format:</a></h4>
<pre><code>http_param:"<var style="color:slategrey;">param_name</var>"[,nocase];</code></pre>
<h3 id="examples-30"><a class="header" href="#examples-30">Examples:</a></h3>
<pre><code class="language-snort">http_param:&quot;favoriteFood&quot;,nocase;
# note the &quot;distance 0&quot; relative modifier used to make the option relative
content:&quot;pizza&quot;,nocase,distance 0;
</code></pre>
<pre><code class="language-snort">http_uri;
content:&quot;/food.php&quot;,fast_pattern,nocase;
http_param:&quot;favoriteFood&quot;,nocase;
# note the 'R' flag used to make the option relative
pcre:&quot;/([\x27\x22\x3b\x23\x28]|\x2f\x2a|\x2d\x2d)/R&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_method"><a class="header" href="#http_method">http_method</a></h1>
<p>The HTTP request method is accessible to rule writers via the <code>http_method</code> sticky buffer. Common  values are <code>GET</code>, <code>POST</code>, <code>OPTIONS</code>, <code>HEAD</code>, <code>DELETE</code>, <code>PUT</code>, <code>TRACE</code>, and <code>CONNECT</code>.</p>
<blockquote>
<p><strong>Note:</strong> <code>http_method</code> matches <em>are</em> eligible for fast patterns, which is a change new to Snort 3. </p>
</blockquote>
<h4 id="format-31"><a class="header" href="#format-31">Format:</a></h4>
<pre><code>http_method;
</code></pre>
<h4 id="examples-31"><a class="header" href="#examples-31">Examples:</a></h4>
<pre><code class="language-snort">http_method;
content:&quot;POST&quot;;
</code></pre>
<pre><code class="language-snort">http_method;
content:&quot;GET&quot;,fast_pattern;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_version"><a class="header" href="#http_version">http_version</a></h1>
<p>Snort parses the HTTP version from request and response start/status lines and makes it accessible to rule-writers via the <code>http_version</code> sticky buffer. This is usually <code>HTTP/1.0</code> or <code>HTTP/1.1</code>.</p>
<p><code>http_version</code> also allows for an optional <code>request</code> argument, which is useful if writing detection that looks at both an HTTP client request and the HTTP server response to that request. More specifically, this <code>request</code> argument is used to signify that the <code>http_version</code> match or matches should apply to the HTTP version from the <em>request</em> if other parts of the rule are examining the <em>response</em>. More information on this topic can be found on <a href="rules/options/payload/http/req_resp_detection.htm">this page</a>.</p>
<h4 id="format-32"><a class="header" href="#format-32">Format:</a></h4>
<pre><code>http_version[:request];
</code></pre>
<h4 id="examples-32"><a class="header" href="#examples-32">Examples:</a></h4>
<pre><code class="language-snort">http_version;
content:&quot;HTTP/1.1&quot;;
</code></pre>
<pre><code class="language-snort">http_version;
content:&quot;HTTP/1.0&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_stat_code"><a class="header" href="#http_stat_code">http_stat_code</a></h1>
<p>The <code>http_stat_code</code> sticky buffer contains the status code field of an HTTP response status line. This includes values such as <code>200</code>, <code>403</code>, and <code>404</code>.</p>
<h4 id="format-33"><a class="header" href="#format-33">Format:</a></h4>
<pre><code>http_stat_code;
</code></pre>
<h4 id="examples-33"><a class="header" href="#examples-33">Examples:</a></h4>
<pre><code class="language-snort">http_stat_code;
content:&quot;200&quot;;
</code></pre>
<pre><code class="language-snort">http_stat_code;
content:&quot;403&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_stat_msg"><a class="header" href="#http_stat_msg">http_stat_msg</a></h1>
<p>The <code>http_stat_msg</code> sticky buffer contains the status text field of an HTTP response status line. This includes values such as <code>OK</code>, <code>Forbidden</code>, and <code>Not Found</code>.</p>
<h4 id="format-34"><a class="header" href="#format-34">Format:</a></h4>
<pre><code>http_stat_msg;
</code></pre>
<h4 id="examples-34"><a class="header" href="#examples-34">Examples:</a></h4>
<pre><code class="language-snort">http_stat_msg;
content:&quot;OK&quot;;
</code></pre>
<pre><code class="language-snort">http_stat_msg;
content:&quot;Forbidden&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_raw_request-and-http_raw_status"><a class="header" href="#http_raw_request-and-http_raw_status">http_raw_request and http_raw_status</a></h1>
<p>The sticky buffers <code>http_raw_request</code> and <code>http_raw_status</code> contain the unmodified first line of HTTP request and HTTP response messages, respectively. These rule options are a safety valve in case one needs to do something that can't otherwise be done with the specific start and status-line buffers.</p>
<h2 id="http_raw_request"><a class="header" href="#http_raw_request">http_raw_request</a></h2>
<h4 id="format-35"><a class="header" href="#format-35">Format:</a></h4>
<pre><code>http_raw_request;
</code></pre>
<h4 id="examples-35"><a class="header" href="#examples-35">Examples:</a></h4>
<pre><code class="language-snort">http_raw_request; content:&quot;GET /robots.txt HTTP/1.1&quot;;
</code></pre>
<pre><code class="language-snort">http_raw_request; content:&quot;POST /totally_not_vulnerable.php HTTP/1.1&quot;;
</code></pre>
<h2 id="http_raw_status"><a class="header" href="#http_raw_status">http_raw_status</a></h2>
<h4 id="format-36"><a class="header" href="#format-36">Format:</a></h4>
<pre><code>http_raw_status;
</code></pre>
<h4 id="examples-36"><a class="header" href="#examples-36">Examples:</a></h4>
<pre><code class="language-snort">http_raw_status; content:&quot;HTTP/1.1 200 OK&quot;;
</code></pre>
<pre><code class="language-snort">http_raw_status; content:&quot;HTTP/1.1 404 Not Found&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_trailer-and-http_raw_trailer"><a class="header" href="#http_trailer-and-http_raw_trailer">http_trailer and http_raw_trailer</a></h1>
<p>HTTP allows header lines to appear after a chunked body ends, and those are referred to as &quot;trailers&quot;. Snort makes these trailers available via the <code>http_trailer</code> and <code>http_raw_trailer</code> sticky buffers. These are identical to their <code>*_header</code> counterparts but apply to end headers instead.</p>
<p>Take the following chunked response, for example:</p>
<pre><code>HTTP/1.1 200 OK
Host:abcip-host.local
Content-Type: text/plain
Transfer-Encoding: chunked
Trailer: Expires

7
Mozilla
9
Developer
7
Network
0
Expires: Wed, 21 Oct 2015 07:28:00 GMT
</code></pre>
<p>The <code>http_trailer</code> and <code>http_raw_trailer</code> buffers will set to the first Trailer header, which in this case is <code>Expires</code>:</p>
<pre><code>[http_trailer]
00000000  45 78 70 69 72 65 73 3A 20 57 65 64 2C 20 32 31  Expires: Wed, 21
00000010  20 4F 63 74 20 32 30 31 35 20 30 37 3A 32 38 3A   Oct 2015 07:28:
00000020  30 30 20 47 4D 54                                00 GMT
</code></pre>
<p>Like with <code>http_header</code>, users can tell Snort to look at only a particular trailer field, with the optional <code>field</code> argument.</p>
<p><code>http_trailer</code> and <code>http_raw_trailer</code> also allow for an optional <code>request</code> argument, which is useful if writing detection that looks at both an HTTP client request and the HTTP server response to that request. More specifically, this <code>request</code> argument is used to signify that the <code>http_trailer</code> or <code>http_raw_trailer</code> match or matches should apply to the HTTP trailers from the <em>request</em> if other parts of the rule are examining the <em>response</em>. More information on this topic can be found on <a href="rules/options/payload/http/req_resp_detection.htm">this page</a>.</p>
<h2 id="http_trailer"><a class="header" href="#http_trailer">http_trailer</a></h2>
<h4 id="format-37"><a class="header" href="#format-37">Format:</a></h4>
<pre><code>http_trailer[:field <var style="color:slategrey;">field_name</var>][,request];</code></pre>
<h4 id="examples-37"><a class="header" href="#examples-37">Examples:</a></h4>
<pre><code class="language-snort">http_trailer;
content:&quot;Expires:&quot;;
</code></pre>
<pre><code class="language-snort">http_trailer; 
content:&quot;Expires:&quot;;
content:&quot;2015&quot;, within 30;
</code></pre>
<h2 id="http_raw_trailer"><a class="header" href="#http_raw_trailer">http_raw_trailer</a></h2>
<h4 id="format-38"><a class="header" href="#format-38">Format:</a></h4>
<pre><code>http_raw_trailer[:field <var style="color:slategrey;">field_name</var>][,request];</code></pre>
<h4 id="examples-38"><a class="header" href="#examples-38">Examples:</a></h4>
<pre><code class="language-snort">http_raw_trailer;
content:&quot;Expires:&quot;;
</code></pre>
<pre><code class="language-snort">http_raw_trailer; 
content:&quot;Expires:&quot;;
content:&quot;2015&quot;, within 30;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_true_ip"><a class="header" href="#http_true_ip">http_true_ip</a></h1>
<p>The <code>http_true_ip</code> sticky buffer provides the original IP address of the client sending the request as it's stored by a proxy in the request message headers. Specifically, it is the last IP address listed in the &quot;X-Forwarded-For&quot; and &quot;True-Client-IP&quot; headers, or any other custom &quot;X-Forwarded-For-type&quot; header. If a request contains multiple headers of this type, then the preference defined in the <code>xff_headers</code> configuration variable is taken into account when determining which header value to include in this buffer.</p>
<h4 id="format-39"><a class="header" href="#format-39">Format:</a></h4>
<pre><code>http_true_ip;
</code></pre>
<h4 id="examples-39"><a class="header" href="#examples-39">Examples:</a></h4>
<pre><code class="language-snort">http_true_ip;
content:&quot;192.168.1.2&quot;;
</code></pre>
<pre><code class="language-snort">http_true_ip;
content:&quot;150.172.238.178&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_version_match"><a class="header" href="#http_version_match">http_version_match</a></h1>
<p>The <code>http_version_match</code> rule option is used to match the HTTP version of an HTTP message against one from a <em>list</em> of versions. This option will check the version present in an HTTP request or status line and use that for comparision.</p>
<p>Valid values to include in the version list include <code>1.0</code>, <code>1.1</code>, <code>2.0</code>, <code>3.0</code>, <code>0.9</code>, <code>malformed</code>, and <code>other</code>. The list of versions should be wrapped in double quotes, and specifying multiple versions is done by separating each one with a space character.</p>
<p>The first five values mentioned above are used to match specific version numbers, while a <code>malformed</code> version is any version present in the request or status line that is not formatted like <code>[0-9].[0-9]</code> (i.e., single digit followed by a dot, followed by another single digit). An example of a malformed HTTP version would be <code>1.a</code>.</p>
<p>A version value that is <code>other</code> is a value that is formatted correctly but is not one of the five specific version values listed above. For example, an HTTP message that specifies HTTP version <code>8.4</code> would be considered <code>other</code>. </p>
<p>Additionally, HTTP messages that <em>falsely claim</em> to be one version via their request or status lines are also considered <code>other</code>. For example, an HTTP request that follows the <code>1.1</code> format but has <code>0.9</code> in its request line would be <code>other</code>.</p>
<p>Note that you can also optionally add <code>,request</code> to the rule option to match only against the version found in the <em>request</em> message, even when examining the response.</p>
<h4 id="format-40"><a class="header" href="#format-40">Format:</a></h4>
<pre><code>http_version_match:"<var style="color:slategrey;">version</var>[ <var style="color:slategrey;">version</var>]…"[,request];</code></pre>
<h4 id="examples-40"><a class="header" href="#examples-40">Examples:</a></h4>
<pre><code class="language-snort">http_version_match:&quot;0.9 1.0 1.1&quot;;
</code></pre>
<pre><code class="language-snort">http_version_match:&quot;2.0 3.0&quot;;
</code></pre>
<pre><code class="language-snort">http_version_match:&quot;other&quot;;
</code></pre>
<pre><code class="language-snort">http_version_match:&quot;malformed&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_num_headers"><a class="header" href="#http_num_headers">http_num_headers</a></h1>
<p>The <code>http_num_headers</code> rule option is used to compare the number of HTTP headers present in an HTTP packet against a specific value. </p>
<p>Users can check whether the total number of headers present is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value.</p>
<p>Additionally, users can also use <code>http_num_headers</code> to look for a count value that is between two numbers. This is done by setting the sign to <code>&lt;&gt;</code> or <code>&lt;=&gt;</code> and putting the minimum count to the left of the sign and the maximum count to the right of it. The <code>&lt;&gt;</code> case is for an exclusive min-max check, while the <code>&lt;=&gt;</code> is for an inclusive min-max check.</p>
<p>Valid <code>http_num_headers</code> number values are 0 through 65535 (inclusive).</p>
<p>Note that you can also optionally add <code>,request</code> to the rule option to only count the number of <em>request</em> headers, even when examining the response.</p>
<h4 id="format-41"><a class="header" href="#format-41">Format:</a></h4>
<h5 id="single-value-comparison"><a class="header" href="#single-value-comparison">Single value comparison:</a></h5>
<pre><code>http_num_headers:[<|>|=|!|<=|>=]<var style="color:slategrey;">count</var>[,request];</code></pre>
<h5 id="range-comparison"><a class="header" href="#range-comparison">Range comparison:</a></h5>
<pre><code>http_num_headers:<var style="color:slategrey;">min_count</var>{<>|<=>}<var style="color:slategrey;">max_count</var>[,request];</code></pre>
<h2 id="examples-41"><a class="header" href="#examples-41">Examples:</a></h2>
<pre><code class="language-snort"># Look for an HTTP packet containing more than 100 headers
http_num_headers:&gt;100;
</code></pre>
<pre><code class="language-snort"># Look for an HTTP packet containing exactly 100 headers
http_num_headers:100;
</code></pre>
<pre><code class="language-snort"># Look for an HTTP packet containing somewhere between
# 50 and 100 headers (exclusive)
http_num_headers:50&lt;&gt;100;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_num_trailers"><a class="header" href="#http_num_trailers">http_num_trailers</a></h1>
<p>The <code>http_num_trailers</code> rule option is used to compare the number of HTTP trailers present in an HTTP packet against a specific value. </p>
<p>Users can check whether the total number of trailers present is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value.</p>
<p>Additionally, users can also use <code>http_num_trailers</code> to look for a count value that is between two numbers. This is done by setting the sign to <code>&lt;&gt;</code> or <code>&lt;=&gt;</code> and putting the minimum count to the left of the sign and the maximum count to the right of it. The <code>&lt;&gt;</code> case is for an exclusive min-max check, while the <code>&lt;=&gt;</code> is for an inclusive min-max check.</p>
<p>Valid <code>http_num_trailers</code> number values are 0 through 65535 (inclusive).</p>
<h4 id="format-42"><a class="header" href="#format-42">Format:</a></h4>
<h5 id="single-value-comparison-1"><a class="header" href="#single-value-comparison-1">Single value comparison:</a></h5>
<pre><code>http_num_trailers:[<|>|=|!|<=|>=]<var style="color:slategrey;">count</var>;</code></pre>
<h5 id="range-comparison-1"><a class="header" href="#range-comparison-1">Range comparison:</a></h5>
<pre><code>http_num_trailers:<var style="color:slategrey;">min_count</var>{<>|<=>}<var style="color:slategrey;">max_count</var>;</code></pre>
<h2 id="examples-42"><a class="header" href="#examples-42">Examples:</a></h2>
<pre><code class="language-snort"># Look for an HTTP packet containing more than 100 trailers
http_num_trailers:&gt;100;
</code></pre>
<pre><code class="language-snort"># Look for an HTTP packet containing exactly 100 trailers
http_num_trailers:100;
</code></pre>
<pre><code class="language-snort"># Look for an HTTP packet containing somewhere between
# 50 and 100 trailers (exclusive)
http_num_trailers:50&lt;&gt;100;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_num_cookies"><a class="header" href="#http_num_cookies">http_num_cookies</a></h1>
<p>The <code>http_num_cookies</code> rule option is used to compare the number of HTTP cookies present in an HTTP packet against a specific value. </p>
<p>This rule option works against HTTP requests and HTTP responses, and users can check for the number of cookies present in a <code>Cookie:</code> header or in a <code>Set-Cookie:</code> header.</p>
<p>For example, the following <code>Cookie:</code> header has two cookies:</p>
<pre><code>GET /cookies HTTP/1.1
Host: www.cookie-store.com
Cookie: SID=31d4d96e407aad42; lang=en-US
</code></pre>
<p>Users can check whether the total number of cookies present is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value.</p>
<p>Additionally, users can also use <code>http_num_cookies</code> to look for a count value that is between two numbers. This is done by setting the sign to <code>&lt;&gt;</code> or <code>&lt;=&gt;</code> and putting the minimum count to the left of the sign and the maximum count to the right of it. The <code>&lt;&gt;</code> case is for an exclusive min-max check, while the <code>&lt;=&gt;</code> is for an inclusive min-max check.</p>
<p>Valid <code>http_num_cookies</code> number values are 0 through 65535 (inclusive).</p>
<p>Note that you can also optionally add <code>,request</code> to the rule option to only count the number of <em>request</em> cookies, even when examining the response.</p>
<h4 id="format-43"><a class="header" href="#format-43">Format:</a></h4>
<h5 id="single-value-comparison-2"><a class="header" href="#single-value-comparison-2">Single value comparison:</a></h5>
<pre><code>http_num_cookies:[<|>|=|!|<=|>=]<var style="color:slategrey;">count</var>[,request];</code></pre>
<h5 id="range-comparison-2"><a class="header" href="#range-comparison-2">Range comparison:</a></h5>
<pre><code>http_num_cookies:<var style="color:slategrey;">min_count</var>{<>|<=>}<var style="color:slategrey;">max_count</var>[,request];</code></pre>
<h2 id="examples-43"><a class="header" href="#examples-43">Examples:</a></h2>
<pre><code class="language-snort"># Look for an HTTP packet containing more than 100 cookies
http_num_cookies:&gt;100;
</code></pre>
<pre><code class="language-snort"># Look for an HTTP packet containing exactly 100 cookies
http_num_cookies:100;
</code></pre>
<pre><code class="language-snort"># Look for an HTTP packet containing somewhere between
# 50 and 100 cookies (exclusive)
http_num_cookies:50&lt;&gt;100;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_header_test"><a class="header" href="#http_header_test">http_header_test</a></h1>
<p>The <code>http_header_test</code> rule option is used to perform various tests on a specific HTTP header field. The tests that can be performed in this option include a test to see whether the header field's value is numeric or not, a check to see whether a header field's value is within a given range, and a check to see whether a given field is absent. </p>
<p>This rule option takes a few different arguments, one of which is the name of the header field to run the tests against. Specifying this field is done with the <code>field</code> argument followed by the name of the field we want to test. The subsequent arguments are the specific tests to run against that particular field, and rule writers can specify multiple tests at once by separating them with commas.</p>
<p>As mentioned above, there are three tests that can be performed on a given header. First is the <code>numeric</code> test to check if a given field is numeric or not. This argument requires specifying either <code>true</code> or <code>false</code> after it to look for numeric headers and non-numeric headers, respectively.</p>
<p>Next is the <code>check</code> argument, which is used to check a numeric header against a given number range. This range is specified after <code>check</code>, and the format for specifying a range is described below.</p>
<p>Last is the <code>absent</code> argument, which simply checks if a given field is absent.</p>
<p>Note that you can also optionally add <code>,request</code> to the rule option to only perform tests against the <em>request</em> headers, even when examining the response.</p>
<h4 id="format-44"><a class="header" href="#format-44">Format:</a></h4>
<pre><code>http_header_test:field <var style="color:slategrey;">header_name</var>[,numeric {true|false}][,check <var style="color:slategrey;">range</var>][,absent][,request];</code></pre>
<p>A range can either be a single value comparison:</p>
<pre><code>[<|>|=|!|<=|>=]<var style="color:slategrey;">number</var></code></pre>
<p>Or it can be a range between two integer values:</p>
<pre><code><var style="color:slategrey;">min_number</var>{<>|<=>}<var style="color:slategrey;">max_number</var></code></pre>
<h4 id="examples-44"><a class="header" href="#examples-44">Examples:</a></h4>
<pre><code class="language-snort"># check that the Content-Length header value is numeric
# and that its value is &gt;40000000
http_header_test:field content-length,numeric true,check &gt;40000000;
</code></pre>
<pre><code class="language-snort"># check that the Content-Length header value is not numeric 
http_header_test:field content-length,numeric false;
</code></pre>
<pre><code class="language-snort"># check that the User-Agent field is absent
http_header_test:field user-agent,absent;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http_trailer_test"><a class="header" href="#http_trailer_test">http_trailer_test</a></h1>
<p>The <code>http_trailer_test</code> rule option is used to perform various tests on a specific HTTP trailer field. The tests that can be performed in this option include a test to see whether the trailer field's value is numeric or not, a check to see whether a trailer field's value is within a given range, and a check to see whether a given field is absent. </p>
<p>This rule option takes a few different arguments, one of which is the name of the trailer field to run the tests against. Specifying this field is done with the <code>field</code> argument followed by the name of the field we want to test. The subsequent arguments are the specific tests to run against that particular field, and rule writers can specify multiple tests at once by separating them with commas.</p>
<p>As mentioned above, there are three tests that can be performed on a given trailer. First is the <code>numeric</code> test to check if a given field is numeric or not. This argument requires specifying either <code>true</code> or <code>false</code> after it to look for numeric trailers and non-numeric trailers, respectively.</p>
<p>Next is the <code>check</code> argument, which is used to check a numeric trailer against a given number range. This range is specified after <code>check</code>, and the format for specifying a range is described below.</p>
<p>Last is the <code>absent</code> argument, which simply checks if a given field is absent.</p>
<h4 id="format-45"><a class="header" href="#format-45">Format:</a></h4>
<pre><code>http_trailer_test:field <var style="color:slategrey;">trailer_name</var>[,numeric {true|false}][,check <var style="color:slategrey;">range</var>][,absent];</code></pre>
<p>A range can either be a single value comparison:</p>
<pre><code>[<|>|=|!|<=|>=]<var style="color:slategrey;">number</var></code></pre>
<p>Or it can be a range between two integer values:</p>
<pre><code><var style="color:slategrey;">min_number</var>{<>|<=>}<var style="color:slategrey;">max_number</var></code></pre>
<h4 id="examples-45"><a class="header" href="#examples-45">Examples:</a></h4>
<pre><code class="language-snort"># check that Expires trailer value is numeric 
http_trailer_test:field expires,numeric true;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rules-examining-http-request-and-response-messages"><a class="header" href="#rules-examining-http-request-and-response-messages">Rules Examining HTTP Request and Response Messages</a></h1>
<p>The stateful nature of the Snort 3 HTTP inspector provides the ability for rule writers to create detection that targets both an HTTP client request and the HTTP server response to that request. Creating detection to do this simply requires including options that target both data from an HTTP response as well as data from an associated HTTP request.</p>
<p>The following Snort rule is a simple example showcasing what this might look like:</p>
<pre><code class="language-snort">alert http (
    msg:&quot;Rule examining a response and the request associated with that response&quot;;
    flow:to_client,established;
    file_data;
    content:&quot;pizza&quot;,fast_pattern;
    http_uri;
    content:&quot;/index.php&quot;;
    classtype:misc-activity;
)
</code></pre>
<p>Here the <code>to_client</code> and <code>file_data</code> declarations tell us that the rule is targeting an HTTP response message, and the <code>http_uri</code> declaration tells Snort to get the request message associated with that response and see if the URI contains that content string.</p>
<p>Note that these kinds of rules must have the <code>fast_pattern</code> set on a response-specific rule option since Snort will always check the response before examining the associated request.</p>
<p>The following is a list of request-specific <code>http_*</code> buffers that can be used in this manner:</p>
<ul>
<li><code>http_uri</code></li>
<li><code>http_raw_uri</code></li>
<li><code>http_cookie</code></li>
<li><code>http_raw_cookie</code></li>
<li><code>http_header</code></li>
<li><code>http_raw_header</code></li>
<li><code>http_trailer</code></li>
<li><code>http_raw_trailer</code></li>
<li><code>http_version</code></li>
<li><code>http_true_ip</code></li>
</ul>
<h2 id="the-optional-request-argument"><a class="header" href="#the-optional-request-argument">The optional &quot;request&quot; argument</a></h2>
<p>Certain HTTP rule options can apply to either an HTTP request or an HTTP response. For example, the <code>http_header</code> rule option can be used to match HTTP request headers <em>or</em> HTTP response headers. As a result, these rule options also allow for an optional <code>request</code> argument that signifies that the given rule option should apply to the HTTP <em>request</em> if the rule contains other options that examine the HTTP response.</p>
<p>For example, the following rule looks for the string &quot;pizza&quot; in an HTTP response message:</p>
<pre><code class="language-snort">alert http (
    msg:&quot;Rule examining just a response message&quot;;
    flow:to_client,established;
    file_data;
    content:&quot;pizza&quot;,fast_pattern;
    classtype:misc-activity;
)
</code></pre>
<p>If we were to add an <code>http_header</code> match, then Snort would see that we are examining the HTTP response message and thus apply <code>http_header</code> to the response headers:</p>
<pre><code class="language-snort">alert http (
    msg:&quot;Rule examining just a response message&quot;;
    flow:to_client,established;
    file_data;
    content:&quot;pizza&quot;,fast_pattern;
    http_header;
    content:&quot;User-Agent: bad&quot;;
    classtype:misc-activity;
)
</code></pre>
<p>The above rule would look for a User-Agent string in the response headers, which likely would not match since &quot;User-Agent&quot; is a request header. However, by adding the <code>request</code> argument to <code>http_header</code>, we tell Snort to instead look at the <em>request headers</em> in the request associated with that particular response:</p>
<pre><code class="language-snort">alert http (
    msg:&quot;Rule examining a response and the request associated with that response&quot;;
    flow:to_client,established;
    file_data;
    content:&quot;pizza&quot;,fast_pattern;
    http_header:request;
    content:&quot;User-Agent: bad&quot;;
    classtype:misc-activity;
)
</code></pre>
<blockquote>
<p>Note that the <code>request</code> argument is not needed for the <code>http_uri</code> rule shown above because a URI will only apply to request messages.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="bufferlen"><a class="header" href="#bufferlen">bufferlen</a></h1>
<p>The <code>bufferlen</code> option enables rule-writers to check the length of a given buffer. Users can check that the length of a buffer equals an exact size, or they can use a mathematical equality/inequality sign to compare a buffer's length to a given size or sizes.</p>
<p>Declaring a <code>bufferlen</code> option is done with the <code>bufferlen</code> keyword, followed by a colon character, optionally followed by an equality/inequality sign, and lastly followed by the number to compare against. A <code>bufferlen</code> check can also be made relative to a previous cursor move by adding <code>,relative</code> after the number.</p>
<p>Users can also use <code>bufferlen</code> to look for a length value that is between two numbers. This is done by setting the sign to <code>&lt;&gt;</code> or <code>&lt;=&gt;</code> and putting the minimum number the left of the sign and the maximum number to the right of it. The <code>&lt;&gt;</code> case is for an <em>exclusive</em> min-max check, while the <code>&lt;=&gt;</code> is for an <em>inclusive</em> min-max check.</p>
<p>Valid <code>bufferlen</code> number values are 0 through 65535 (inclusive).</p>
<p><code>bufferlen</code> will be tested against the <code>pkt_data</code> buffer unless some other sticky buffer is specified before it.</p>
<blockquote>
<p><strong>Note:</strong> Snort 2's <code>urilen</code> option has been removed, and Snort 3 rule-writers should use the <code>http_uri</code> sticky buffer + <code>bufferlen</code> to check URI lengths.</p>
</blockquote>
<h4 id="format-46"><a class="header" href="#format-46">Format:</a></h4>
<h5 id="single-value-comparison-3"><a class="header" href="#single-value-comparison-3">Single value comparison:</a></h5>
<pre><code>bufferlen:[<|>|=|!|<=|>=]<var style="color:slategrey;">length</var>[,relative];</code></pre>
<h5 id="range-comparison-3"><a class="header" href="#range-comparison-3">Range comparison:</a></h5>
<pre><code>bufferlen:<var style="color:slategrey;">min_length</var>{<>|<=>}<var style="color:slategrey;">max_length</var>[,relative];</code></pre>
<h4 id="examples-46"><a class="header" href="#examples-46">Examples:</a></h4>
<pre><code class="language-snort"># check that the packet payload contains more than 100 bytes
bufferlen:&gt;100;
</code></pre>
<pre><code class="language-snort">http_uri;
content:&quot;/pizza.php?&quot;;
# check that the http_uri buffer contains exactly 10 bytes of data after the content match
bufferlen:10,relative;
</code></pre>
<pre><code class="language-snort">http_client_body;
# check that the client body contains between 2 and 10 bytes (inclusive) 
bufferlen:2&lt;=&gt;10;
</code></pre>
<pre><code class="language-snort">http_client_body;
# check that the client body contains between 2 and 10 bytes (exclusive) 
bufferlen:2&lt;&gt;10;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="isdataat"><a class="header" href="#isdataat">isdataat</a></h1>
<p>The <code>isdataat</code> rule option verifies the payload data exists at a specified location.</p>
<p><code>isdataat</code> is specified with the <code>isdataat</code> keyword, followed by a colon character, followed by a number that signals where to look for packet data, and lastly followed optionally by <code>,relative</code> to tell Snort to look for data starting from a previous cursor move.</p>
<p>Users can also specify a negated <code>isdataat</code> check with <code>!</code> placed before the number to check that certain amount of data is not present at a specified location in the payload.</p>
<p>Valid <code>isdataat</code> numbers are 0 through 65535 (inclusive). This means that <code>isdataat:0</code> checks that there is at least one byte present after the current cursor location.</p>
<h4 id="format-47"><a class="header" href="#format-47">Format:</a></h4>
<pre><code>isdataat:[!]<var style="color:slategrey;">location</var>[,relative];</code></pre>
<h4 id="examples-47"><a class="header" href="#examples-47">Examples:</a></h4>
<pre><code class="language-snort">isdataat:100;
</code></pre>
<pre><code class="language-snort">content:&quot;USER&quot;; 
# checks for at least 30 bytes after &quot;USER&quot; since valid isdataat numbers start at 0
isdataat:29,relative; 
content:!&quot;|0a|&quot;, within 30;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dsize"><a class="header" href="#dsize">dsize</a></h1>
<p>The <code>dsize</code> rule option is used to test a packet's payload size. This option can be specified to look for a packet size that is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also be used to check that a payload size is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<p>The valid <code>dsize</code> number range is 0-65535.</p>
<h4 id="format-48"><a class="header" href="#format-48">Format:</a></h4>
<h5 id="single-value-comparison-4"><a class="header" href="#single-value-comparison-4">Single value comparison:</a></h5>
<pre><code>dsize:[<|>|=|!|<=|>=]<var style="color:slategrey;">size</var>;</code></pre>
<h5 id="range-comparison-4"><a class="header" href="#range-comparison-4">Range comparison:</a></h5>
<pre><code>dsize:<var style="color:slategrey;">min_size</var>{<>|<=>}<var style="color:slategrey;">max_size</var>;</code></pre>
<h4 id="examples-48"><a class="header" href="#examples-48">Examples:</a></h4>
<pre><code class="language-snort">dsize:300&lt;&gt;400;
</code></pre>
<pre><code class="language-snort">dsize:&gt;10000;
</code></pre>
<pre><code class="language-snort">dsize:&lt;10;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pcre"><a class="header" href="#pcre">pcre</a></h1>
<p>The <code>pcre</code> rule option matches regular expression strings against packet data. </p>
<p>Regular expressions written for these two options use perl-compatible regular expression (PCRE) syntax, which can be read about <a href="https://www.pcre.org/original/doc/html/pcrepattern.html">here</a>. </p>
<p>The regular expression written is enclosed in double quotes and must start and end with forward slashes. Users can specify optional &quot;flags&quot; after the ending forward slash to denote pcre modifiers. A table of these flags/modifiers can be found below in the two &quot;Format&quot; sections. </p>
<blockquote>
<p><strong>Note:</strong> Snort 3 no longer contains HTTP-specific pcre flags since HTTP buffers are now sticky. Simply specify the <code>http_*</code> buffer before declaring <code>pcre</code> to evaluate the regular expression there.</p>
</blockquote>
<p>A <code>pcre</code> rule option can be negated to tell Snort to alert only if that regular expression is not matched.</p>
<h4 id="format-49"><a class="header" href="#format-49">Format:</a></h4>
<pre><code>pcre:[!]"/<var style="color:slategrey;">pcre_string</var>/[<var style="color:slategrey;">flag</var>…]";</code></pre>
<table><thead><tr><th>Flag</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>i</code></td><td>case insensitive</td></tr>
<tr><td><code>s</code></td><td>include newlines in the dot metacharacter</td></tr>
<tr><td><code>m</code></td><td>By default, a pcre string is treated as one big line of characters, and '^' and '$' match at the beginning and ending of the string. When <code>m</code> is set, '^' and '$' match immediately following or immediately before any newline in the buffer, as well as the very start and very end of the buffer.</td></tr>
<tr><td><code>x</code></td><td>specifies that whitespace data characters in the pattern are ignored except when escaped or inside a character class</td></tr>
<tr><td><code>A</code></td><td>specifies the pattern must match only at the start of the buffer (same as specifying the '^' character)</td></tr>
<tr><td><code>E</code></td><td>sets '$' to match only at the end of the subject string</td></tr>
<tr><td><code>G</code></td><td>inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by '?'</td></tr>
<tr><td><code>O</code></td><td>overrides the configured pcre match limit and pcre match limit recursion for this expression</td></tr>
<tr><td><code>R</code></td><td>start the regex search from the end of the last match instead of start of buffer</td></tr>
</tbody></table>
<h4 id="examples-49"><a class="header" href="#examples-49">Examples:</a></h4>
<pre><code class="language-snort">pcre:&quot;/^file\x3a\x2f\x2f[^\n]{400}/mi&quot;;
</code></pre>
<pre><code class="language-snort">http_uri;
content:&quot;/vulnerable_endpoint.php&quot;,fast_pattern,nocase;
# pcre gets evaluated against data in the specified sticky buffer
pcre:&quot;/[?&amp;]interface=[\x60\x3b]/i&quot;;
</code></pre>
<blockquote>
<p><strong>Note:</strong> Because regular expressions are relatively costly from a performance standpoint, rules that use a <code>pcre</code> should also have at least one <code>content</code> match to take advantage of Snort's fast-pattern engine.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="regex"><a class="header" href="#regex">regex</a></h1>
<p>The <code>regex</code> rule option matches regular expressions against payload data via the hyperscan search engine.</p>
<p>One of the main advantages to using <code>regex</code> options over <code>pcre</code> options is the ability to use <code>regex</code> regular expressions as <code>fast_pattern</code> matches. Doing so, however, requires that the hyperscan libraries are installed and hyperscan is enabled in the Snort 3 Lua configuration like so:</p>
<pre><code class="language-lua">search_engine = { search_method = &quot;hyperscan&quot; } 
</code></pre>
<p>Like the <code>pcre</code> option, these regular expressions follow the perl-compatible regular expression (PCRE) syntax, are enclosed in double quotes, and must start and end with forward slashes.</p>
<p>Similar to <code>pcre</code>, <code>regex</code> options are evaluated against any sticky buffer that precedes it.</p>
<p>Regular expressions written for <code>regex</code> options have access to only a limited set of flags/modifiers, and those compatible flags are shown below.</p>
<h4 id="format-50"><a class="header" href="#format-50">Format:</a></h4>
<pre><code>regex:"/<var style="color:slategrey;">regex_string</var>/[<var style="color:slategrey;">flag</var>…]"[,fast_pattern][,nocase];</code></pre>
<table><thead><tr><th>Flag</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>i</code></td><td>case insensitive</td></tr>
<tr><td><code>s</code></td><td>include newlines in the dot metacharacter</td></tr>
<tr><td><code>m</code></td><td>By default, a pcre string is treated as one big line of characters, and '^' and '$' match at the beginning and ending of the string. When <code>m</code> is set, '^' and '$' match immediately following or immediately before any newline in the buffer, as well as the very start and very end of the buffer.</td></tr>
<tr><td><code>R</code></td><td>start the regex search from the end of the last match instead of start of buffer</td></tr>
</tbody></table>
<h4 id="examples-50"><a class="header" href="#examples-50">Examples:</a></h4>
<pre><code class="language-snort">regex:&quot;/^file\x3a\x2f\x2f[^\n]{400}/mi&quot;,fast_pattern;
</code></pre>
<pre><code class="language-snort">http_uri;
# regex gets evaluated against data in the specified sticky buffer
regex:&quot;/\x2fvulnerable_endpoint\x2ephp?interface=[\x60\x3b]/i&quot;,fast_pattern;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pkt_data"><a class="header" href="#pkt_data">pkt_data</a></h1>
<p>The <code>pkt_data</code> rule option sets the detection cursor to the start of normalized packet data. </p>
<p>Rules that do not include any buffer specifiers will check payload options against the <code>pkt_data</code> buffer by default. However, one might want to use the <code>pkt_data</code> buffer explicitly either for clarification purposes, or to return the cursor to normalized packet data after using some other sticky buffer.</p>
<p>It's important to note that unless <code>search_engine.detect_raw_tcp</code> is set to <code>true</code> in one's Snort configuration, not everything from a packet's payload gets placed in the <code>pkt_data</code> buffer. For example, if Snort detects traffic as HTTP, then elements like the URI and headers would not placed in a <code>pkt_data</code> buffer. Therefore, users will want to use this buffer to detect normalized packet payload bytes that are not available for detection in other buffers (such as <code>http_*</code> buffers).</p>
<p>This <code>search_engine.detect_raw_tcp</code> configuration option is set to <code>false</code> by default for performance reasons.</p>
<h4 id="format-51"><a class="header" href="#format-51">Format:</a></h4>
<pre><code>pkt_data;
</code></pre>
<h4 id="examples-51"><a class="header" href="#examples-51">Examples:</a></h4>
<pre><code class="language-snort">pkt_data;
content:&quot;pizza&quot;, depth 5;
</code></pre>
<pre><code class="language-snort">pkt_data;
content:&quot;AAAAAA&quot;;
bufferlen:&gt;1000;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="raw_data"><a class="header" href="#raw_data">raw_data</a></h1>
<p>The <code>raw_data</code> rule option in Snort 3 replaces the old <code>rawbytes</code> keyword from Snort 2, and it sets the cursor to raw packet data. It is different from <code>pkt_data</code> in that it will ignore certain preprocessing and normalization done by Snort.</p>
<blockquote>
<p><strong>Note:</strong> This option will likely not be used often as it was introduced in Snort 2 to remediate Telnet-related issues back in the day.</p>
</blockquote>
<h4 id="format-52"><a class="header" href="#format-52">Format:</a></h4>
<pre><code>raw_data;
</code></pre>
<h4 id="examples-52"><a class="header" href="#examples-52">Examples:</a></h4>
<pre><code class="language-snort"># telnet NOP
raw_data;
content:&quot;|FF F1|&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="file_data"><a class="header" href="#file_data">file_data</a></h1>
<p>The <code>file_data</code> option sets the detection cursor to either the HTTP response body for HTTP traffic or file data sent via other application protocols that has been processed and captured by Snort's &quot;file API&quot;. Data in this buffer can contain normalized and decoded data depending on the service used to send the file data, as well as the specific configurations enabled for the different service inspectors included in Snort.</p>
<p>Using this option to detect file data is as simple as specifying <code>file_data;</code> before any and and all payload options one wants to match there.</p>
<p>This rule option can be used several times in a rule if desired.</p>
<p>Services that support the <code>file_data</code> buffer include:</p>
<ul>
<li><code>http</code></li>
<li><code>pop3</code></li>
<li><code>imap</code></li>
<li><code>smtp</code></li>
<li><code>ftp-data</code></li>
<li><code>netbios-ssn</code></li>
</ul>
<p>The following sub-sections explain what the <code>file_data</code> buffer <em>could</em> contain for each of the above services. One should refer to each inspector's default configurations, and adjust them accordingly in the Snort Lua configuration.</p>
<h4 id="http"><a class="header" href="#http">HTTP</a></h4>
<p>For HTTP traffic, the <code>file_data</code> buffer points to the normalized HTTP response body, and the specific normalizations that occur depend on one's Snort configuration. This includes things like the decompression of ZIP, SWF, and PDF files, the decoding of UTF-* encodings, JavaScript normalization, and deflate and gzip decompression. Additionally, Snort can also de-chunk chunked messages and place the de-chunked message body in the <code>file_data</code> buffer. </p>
<p>The default configurations can be seen with the following Snort command:</p>
<pre><code>$ snort --help-module http_inspect
</code></pre>
<h4 id="pop3imapsmtp"><a class="header" href="#pop3imapsmtp">POP3/IMAP/SMTP</a></h4>
<p>The <code>file_data</code> buffer for mail traffic also depends on one's specific configuration. By default, Snort will place email headers, decoded MIME attachments, and non-decoded MIME attachments in the <code>file_data</code> buffer. The decoders enabled by default in Snort include base64, quoted-printable, MIME, and Unix-to-Unix. </p>
<p>Note that if MIME decoding is disabled, then Snort will place the unencoded MIME data in the <code>file_data</code> buffer.</p>
<p>The default configurations can be seen with the following commands:</p>
<pre><code>$ snort --help-module pop
$ snort --help-module imap
$ snort --help-module smtp
</code></pre>
<h4 id="ftp-data"><a class="header" href="#ftp-data">FTP data</a></h4>
<p>For FTP traffic, the <code>file_data</code> buffer will contain any raw files sent over an FTP-data session.</p>
<h4 id="smb"><a class="header" href="#smb">SMB</a></h4>
<p>Snort 3's DCE/RPC service inspector is aware of SMB request and response command codes and will process files seen in <code>SMB2 READ</code> responses and <code>SMB2 WRITE</code> requests. The <code>file_data</code> buffer is then set to the raw files processed in both of these two SMB message types.</p>
<p>The default configurations can be seen with the following commands:</p>
<pre><code>$ snort --help-module dce_smb
</code></pre>
<h4 id="format-53"><a class="header" href="#format-53">Format:</a></h4>
<pre><code>file_data;
</code></pre>
<h4 id="examples-53"><a class="header" href="#examples-53">Examples:</a></h4>
<pre><code class="language-snort">alert http (
  …
  flow:to_client,established;
  file_data;
  content:&quot;&lt;script&gt;var aaaaaaa&quot;;
  …
)
</code></pre>
<pre><code class="language-snort">alert file (
  …
  flow:to_client,established;
  file_data;
  content:&quot;MZ&quot;,depth 2;
  …
)
</code></pre>
<pre><code class="language-snort">alert tcp $EXTERNAL_NET any -&gt; $HOME_NET 25 (
  …
  file_data;
  content:&quot;decoded SMTP file here&quot;
  …
)
</code></pre>
<pre><code class="language-snort">alert tcp $EXTERNAL_NET any -&gt; $HOME_NET 445 (
  …
  content:&quot;|FE|SMB&quot;;
  content:&quot;|08|&quot;, distance 8, within 1;
  file_data;
  content:&quot;MALWARE&quot;;
  …
)
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="js_data"><a class="header" href="#js_data">js_data</a></h1>
<p>The <code>js_data</code> option sets the detection cursor to the normalized JavaScript data buffer, which contains data normalized by the new &quot;Enhanced Normalizer&quot;. Snort can detect whether JavaScript is present in the message body and then perform normalization on it if so. </p>
<p>Snort's &quot;Enhanced Normalizer&quot; is able to perform the following normalizations:</p>
<ul>
<li>Normalize whitespace</li>
<li>Concatenate string literals</li>
<li>Unify identifier and property names</li>
<li>Expand escaped text</li>
</ul>
<p>To see the default normalizations enabled, run the following command and look at the <code>http_inspect.js_*</code> configurations:</p>
<pre><code>$ snort --help-module http_inspect
</code></pre>
<p>For example, consider the following JavaScript code:</p>
<pre><code class="language-js">&lt;script&gt;var o = {};

o.__defineGetter__('vuln');&lt;/script&gt;
</code></pre>
<p>The Enhanced Normalizer will normalize the whitespace as well as unify the variable name to something predictable. If we look at the <code>js_data</code> buffer, we can see exactly that:</p>
<pre><code>[js_data]
00000000  76 61 72 20 76 61 72 5F 30 30 30 30 3D 7B 7D 3B  var var_0000={};
00000010  76 61 72 5F 30 30 30 30 2E 5F 5F 64 65 66 69 6E  var_0000.__defin
00000020  65 47 65 74 74 65 72 5F 5F 28 27 76 75 6C 6E 27  eGetter__('vuln'
00000030  29 3B                                            );
</code></pre>
<p>Note that to use this buffer, the <code>http_inspect.js_normalization_depth</code> field must be set in one's Snort configuration:</p>
<code>
http_inspect = { js_normalization_depth = <var>depth</var> }
</code>
<blockquote>
<p><strong>Note:</strong> The <code>js_data</code> option is still under active development, so rule-writers should use caution when using it in their rules.</p>
</blockquote>
<h4 id="format-54"><a class="header" href="#format-54">Format:</a></h4>
<pre><code>js_data;
</code></pre>
<h4 id="examples-54"><a class="header" href="#examples-54">Examples:</a></h4>
<pre><code class="language-snort">js_data;
content:&quot;=new Uint32Array(-1)|3B|&quot;;
</code></pre>
<pre><code class="language-snort">js_data;
content:&quot;var var_0000={}|3B|o.__defineGetter__(&quot;;
</code></pre>
<pre><code class="language-snort">js_data;
content:&quot;0xFFFFFFFF&quot;;
content:&quot;-1&quot;;
bufferlen:&lt;200;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="vba_data"><a class="header" href="#vba_data">vba_data</a></h1>
<p>The <code>vba_data</code> rule option is used to set the detection cursor to the Microsoft Office Visual Basic for Applications (VBA) macros buffer.</p>
<p>VBA macros can be included in documents and spreadsheets to automate common Office tasks and operations, but they unfortunately can also be used by malicious actors to execute arbitrary code on an unsuspecting victim's machine. To be able to protect against malicious macros, Snort provides the <code>vba_data</code> sticky buffer to look at VBA macros present in Office documents that are sent over the wire. </p>
<p>Note that because VBA macros and Office documents are usually compressed, this option requires that the <code>decompress_zip</code> and <code>decompress_vba</code> options are enabled in one's Snort configuration. For example to enable it for the HTTP inspector, you would add the following lines to your configuration:</p>
<pre><code class="language-lua">http_inspect.decompress_zip = true
http_inspect.decompress_vba = true
</code></pre>
<h4 id="format-55"><a class="header" href="#format-55">Format:</a></h4>
<pre><code>vba_data;
</code></pre>
<h4 id="examples-55"><a class="header" href="#examples-55">Examples:</a></h4>
<pre><code class="language-snort">vba_data;
content:&quot;URLDownloadToFileA&quot;,nocase;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="base64_decode-and-base64_data"><a class="header" href="#base64_decode-and-base64_data">base64_decode and base64_data</a></h1>
<p>Snort can decode base64-encoded data present in a packet's payload via the <code>base64_decode</code> option. If base64-encoded data is found, it gets decoded and the base64-decoded data is then placed in the <code>base64_data</code> sticky buffer.</p>
<h2 id="base64_decode"><a class="header" href="#base64_decode">base64_decode</a></h2>
<p>The <code>base64_decode</code> option tells Snort exactly which bytes to decode as base64. It can be declared by itself with just <code>base64_decode;</code>, or it can take any combination of three optional arguments after <code>base64_decode:</code>. Those optional arguments are:</p>
<table><thead><tr><th><div style="width:190px">Argument</div></th><th>Description</th></tr></thead><tbody>
<tr><td><code>bytes <var>bytes</var></code></td><td>How many bytes to decode</td></tr>
<tr><td><code>offset <var>offset</var></code></td><td>Where in the payload to look for the base64 data to decode</td></tr>
<tr><td><code>relative</code></td><td>Applies the offset relative to cursor instead of start of buffer</td></tr>
</tbody></table>
<p>As noted above, all three arguments are optional. Omitting the <code>bytes</code> argument tells Snort to decode any base64-encoded data present until either the end of the buffer or the end of a present base64-encoded string. If the <code>offset</code> argument is omitted, Snort will look for base64 data either at the start of the buffer or the current cursor position (i.e., it implicitly sets <code>offset</code> to 0). And lastly, omitting <code>relative</code> tells Snort to look for the bytes relative to beginning of the currently-set buffer rather than the current cursor position.</p>
<h4 id="format-56"><a class="header" href="#format-56">Format:</a></h4>
<pre><code>base64_decode[:[bytes <var style="color:slategrey;">bytes</var>][, offset <var style="color:slategrey;">offset</var>][, relative]];</code></pre>
<h4 id="examples-56"><a class="header" href="#examples-56">Examples:</a></h4>
<pre><code class="language-snort">base64_decode;
</code></pre>
<pre><code class="language-snort">base64_decode:relative;
</code></pre>
<pre><code class="language-snort">http_header;
content:&quot;Authorization:&quot;,nocase;
base64_decode:bytes 12, offset 6, relative;
</code></pre>
<h2 id="base64_data"><a class="header" href="#base64_data">base64_data</a></h2>
<p>The <code>base64_data</code> options sets the detection cursor to the beginning of the base64 decoded—provided <code>base64_decode</code> was in fact able to decode data.</p>
<p>This option does not take any arguments but requires that <code>base64_decode</code> be specified before it.</p>
<blockquote>
<p><strong>Note:</strong> If matching content at the beginning of a base64 data buffer, users can use either <code>depth</code>/<code>offset</code> or <code>distance</code>/<code>within</code>.</p>
</blockquote>
<h4 id="format-57"><a class="header" href="#format-57">Format:</a></h4>
<pre><code>base64_data;
</code></pre>
<h4 id="examples-57"><a class="header" href="#examples-57">Examples:</a></h4>
<pre><code class="language-snort">base64_decode:relative;
base64_data;
content:&quot;AAAA&quot;;
</code></pre>
<pre><code class="language-snort">http_header;
content:&quot;Authorization:&quot;,nocase;
base64_decode:bytes 12, offset 6, relative;
base64_data;
content:&quot;NTLMSSP&quot;, within 8;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="byte_extract"><a class="header" href="#byte_extract">byte_extract</a></h1>
<p>The <code>byte_extract</code> keyword is used to read a some number of bytes from packet data and store the extracted byte or bytes into a named variable. This option does nothing by itself, and the extracted value should be used with other options later in the rule. The named variable can be used as arguments to any of the following options:</p>
<ul>
<li><code>distance</code>, <code>within</code>, <code>offset</code>, or <code>depth</code> modifiers</li>
<li><code>byte_test</code></li>
<li><code>byte_jump</code></li>
<li><code>isdataat</code></li>
</ul>
<p><code>byte_extract</code> is declared with the keyword, followed by a colon character, followed by three required arguments separated by commas: (1) number of bytes to extract, (2) the offset of the bytes to extract, and (3) the name of variable that will receive the extracted value. These three arguments MUST be specified in this exact order.</p>
<p>There are also a few additional optional arguments that can be added after the three required arguments, which are also separated by commas, and they are listed and described below in the formatting section.</p>
<blockquote>
<p><strong>Note:</strong> The <code>byte_extract</code> option moves the detection cursor forward the number of bytes extracted.</p>
</blockquote>
<h4 id="format-58"><a class="header" href="#format-58">Format:</a></h4>
<pre><code>byte_extract:<var style="color:slategrey;">count</var>, <var style="color:slategrey;">offset</var>, <var style="color:slategrey;">name</var>[, relative][, multiplier <var style="color:slategrey;">multiplier</var>] \
             [, <var style="color:slategrey;">endian</var>][, string[, {dec|hex|oct}]][, align <var style="color:slategrey;">align</var>][, dce] \
             [, bitmask <var style="color:slategrey;">bitmask</var>];</code></pre>
<table><thead><tr><th><div style="width:200px">Argument</div></th><th>Description</th></tr></thead><tbody>
<tr><td><code><var>count</var><code></code></code></td><td>Number of bytes to pick up from the buffer (valid values include <code>1:10</code> if <code>string</code> argument is used and <code>1:4</code> if <code>string</code> argument is not used)</td></tr>
<tr><td><code>offset</code></td><td>Number of bytes into the buffer to start processing (valid values include <code>-65535:65535</code>)</td></tr>
<tr><td><code>name</code></td><td>Name of the variable to be used in other rule options</td></tr>
<tr><td><code>relative</code></td><td>Offset from cursor instead of start of buffer</td></tr>
<tr><td><code>multiplier <var>multiplier</var></code></td><td>Multiply the extracted value by the specified amount (valid values include <code>1:65535</code>)</td></tr>
<tr><td><code>align <var>align</var></code></td><td>Round the number of converted bytes up to the next 2- or 4-byte boundary (valid values may be <code>2</code> or <code>4</code>)</td></tr>
<tr><td><code><var>endian</var></code></td><td>Set to either <code>big</code> or <code>little</code> to specify whether to process the data as little-endian or big-endian (extracted data is processed as big-endian by default)</td></tr>
<tr><td><code>dce</code></td><td>Use the DCE/RPC 2 inspector engine to determine the byte endianness</td></tr>
<tr><td><code>string</code></td><td>Extract bytes from packet that are stored in string format</td></tr>
<tr><td><code>hex</code></td><td>Convert the string bytes in the packet from a hexadecimal string (must be accompanied by <code>string</code>)</td></tr>
<tr><td><code>oct</code></td><td>Convert the string bytes in the packet from an octal string (must be accompanied by <code>string</code>)</td></tr>
<tr><td><code>dec</code></td><td>Convert the string bytes in the packet from a decimal string (the default option when <code>string</code> is set)</td></tr>
<tr><td><code>bitmask <var>bitmask</var></code></td><td>Perform an AND bitwise operation with the specified bitmask on the extracted value before storing it in <code>name</code> (valid values are <code>1:<var>count</var></code>)</td></tr>
</tbody></table>
<h4 id="examples-58"><a class="header" href="#examples-58">Examples:</a></h4>
<pre><code class="language-snort">byte_extract:1, 0, str_offset;
byte_extract:1, 1, str_depth;
content:&quot;bad stuff&quot;, offset str_offset, depth str_depth;
</code></pre>
<pre><code class="language-snort"># multiplies the extracted byte by 8 and stores the result in &quot;multiplier_ex1&quot;
byte_extract:1, 0, multiplier_ex1, multiplier 8;
content:&quot;AAAAA&quot;, within multiplier_ex1;
</code></pre>
<pre><code class="language-snort">content:&quot;MAGIC&quot;;
# extracts 4 bytes after &quot;MAGIC&quot;, processes those bytes as little-endian, 
# and stores the value in &quot;field_sz&quot;
byte_extract:4, 0, field_sz, relative, little;
content:&quot;next field&quot;, distance field_sz;
</code></pre>
<pre><code class="language-snort">http_header;
content:&quot;Content-Length: &quot;;
# extracts 4 bytes represented as a decimal string 
# from the packet immediately after &quot;Content-Length: &quot; 
byte_extract:4, 0, content_len, relative, string;
isdataat:!content_len;
</code></pre>
<pre><code class="language-snort"># extracts 4 bytes represented as a hexadecimal string 
# from the beginning of the packet
byte_extract:4, 0, hex_string_var, string, hex;
content:&quot;BBBBB&quot;, distance hex_string_var;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="byte_test"><a class="header" href="#byte_test">byte_test</a></h1>
<p>The <code>byte_test</code> rule option tests a byte field against a specific value with a specified operator. This option is able to test binary values right from the packet, and it can also convert string-representations of numbers (e.g., decimal, hexadecimal, and octal-representations) for testing purposes as well.</p>
<p><code>byte_test</code> is declared with the keyword, followed by a colon character, followed by four required arguments separated by commas: (1) number of bytes to grab from the packet, (2) the operator to test against the bytes in the packet, (3) the value to test the bytes in the packet against, and (4) the offset of the bytes to grab. These four arguments MUST be specified in this exact order.</p>
<p>There are also a few optional arguments that can be declared after the four required arguments, which are also separated by commas. They are listed and described below.</p>
<p>Snort uses C operators for testing, and valid ones include <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code>, <code>&amp;</code>, and <code>^</code>.</p>
<p>The <code>&amp;</code> operator does an AND bitwise test:</p>
<pre><code>if (packet_data_bytes &amp; value)
</code></pre>
<p>Conversely, the <code>^</code> does an XOR bitwise test:</p>
<pre><code>if (packet_data_bytes ^ value)
</code></pre>
<p>A <code>byte_test</code> operator can also look for the negation of the test result by adding <code>!</code> before the selected operator.</p>
<blockquote>
<p><strong>Note:</strong> A <code>byte_test</code> option <em>does not</em> move the detection cursor.</p>
</blockquote>
<h4 id="format-59"><a class="header" href="#format-59">Format:</a></h4>
<pre><code>byte_test:<var style="color:slategrey;">count</var>, [!]<var style="color:slategrey;">operator</var>, <var style="color:slategrey;">compare</var>, <var style="color:slategrey;">offset</var>[, relative][, <var style="color:slategrey;">endian</var>] \
          [, string[, {dec|hex|oct}]][, dce][, bitmask <var style="color:slategrey;">bitmask</var>];</code></pre>
<table><thead><tr><th><div style="width:150px">Argument</div></th><th>Description</th></tr></thead><tbody>
<tr><td><code><var>count</var></code></td><td>Number of bytes to pick up from the buffer (valid values include <code>1:10</code>)</td></tr>
<tr><td><code><var>operator</var></code></td><td>Operation to test against the bytes in the packet (valid operators include <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code>, <code>&amp;</code>, and <code>^</code>)</td></tr>
<tr><td><code><var>compare</var></code></td><td>Variable name or value to test the converted result against (valid values include <code>0:4294967295</code> and can be represented as decimal or hexadecimal)</td></tr>
<tr><td><code><var>offset</var></code></td><td>Variable name or number of bytes into the payload to start processing (valid values include <code>-65535:65535</code>)</td></tr>
<tr><td><code>relative</code></td><td>Offset from cursor instead of start of buffer</td></tr>
<tr><td><code><var>endian</var></code></td><td>Set to either <code>big</code> or <code>little</code> to specify whether to process the data as little-endian or big-endian (packet bytes are processed as big-endian by default)</td></tr>
<tr><td><code>dce</code></td><td>Use the DCE/RPC 2 inspector engine to determine the byte endianness</td></tr>
<tr><td><code>string</code></td><td>Pick up bytes from packet that are stored in string format</td></tr>
<tr><td><code>hex</code></td><td>Grab the string bytes in the packet from a hexadecimal string (must be accompanied by <code>string</code>)</td></tr>
<tr><td><code>oct</code></td><td>Grab the string bytes in the packet from an octal string (must be accompanied by <code>string</code>)</td></tr>
<tr><td><code>dec</code></td><td>Grab the string bytes in the packet from a decimal string (the default option when <code>string</code> is set)</td></tr>
<tr><td><code>bitmask <var>bitmask</var></code></td><td>Perform an AND bitwise operation with the specified bitmask on the picked-up bytes before testing it against <code><var>value</var></code> (valid values are <code>1:<var>count</var></code>)</td></tr>
</tbody></table>
<blockquote>
<p><strong>Note:</strong> The <code>bitmask</code> argument result will be right-shifted by the number of bits equal to the number of trailing zeros in the mask.</p>
</blockquote>
<h4 id="examples-59"><a class="header" href="#examples-59">Examples:</a></h4>
<pre><code class="language-snort">content:&quot;ABCD&quot;, depth 4;
# grabs the 2 bytes immediately after &quot;ABCD&quot;
# that are represented as little-endian
# and checks that those bytes are greater than 0x7fff
byte_test:2, &gt;, 0x7fff, 0, relative, little;
</code></pre>
<pre><code class="language-snort"># grabs 2 bytes at offset 0, performs a
# bitwise AND with 0x3FF0, right-shifts the result by 4 bits,
# and compares the final result to 568 to see if they are equal
byte_test:2, =, 568, 0, bitmask 0x3FF0;
</code></pre>
<pre><code class="language-snort"># grabs 4 bytes af offset 0, converts those bytes 
# as a decimal string, and tests that the converted number
# is greater than 1234
byte_test:4, &gt;, 1234, 0, string, dec;
</code></pre>
<pre><code class="language-snort">content:&quot;AAAA&quot;;
byte_extract:4, 0, a_sz, relative;
content:&quot;BBBB&quot;;
# grabs 4 bytes right after &quot;BBBB&quot;
# and tests if those bytes are greater than 
# the extracted bytes from earlier
byte_test:4, &gt;, a_sz, 0, relative;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="byte_math"><a class="header" href="#byte_math">byte_math</a></h1>
<p>The <code>byte_math</code> operation extracts bytes from the packet, performs a mathematical operation on the extracted value with specified value or existing variable, and stores the outcome in a new variable. These variables can be referenced later in the rule in the same places that <code>byte_extract</code> variables can be used.</p>
<p><code>byte_math</code> is declared with the keyword, followed by a colon character, followed by five required arguments separated by commas: (1) &quot;bytes&quot; followed by the number of bytes to extract from the packet, (2) &quot;offset&quot; followed by the offset of the bytes to extract, (3) &quot;oper&quot; followed by the mathematical operation to perform on the extracted value, (4) &quot;rvalue&quot; followed by the value to use with the mathematical operation on the extracted value, and (5) &quot;result&quot; followed by the name of variable that will receive the final result. </p>
<p>There are also a few additional optional arguments that are listed and described below in the formatting section.</p>
<p>Valid math operations that can be used in this option include <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code>. </p>
<blockquote>
<p><strong>Note:</strong> The <code>byte_math</code> option <em>does not</em> move the detection cursor forward.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> <code>byte_math</code> operations are performed on unsigned 32-bit values, and this should be taken into consideration when writing rules to avoid integer wrap arounds.</p>
</blockquote>
<h4 id="format-60"><a class="header" href="#format-60">Format:</a></h4>
<pre><code>byte_math:bytes <var style="color:slategrey;">count</var>, offset <var style="color:slategrey;">offset</var>, oper <var style="color:slategrey;">operator</var>, rvalue <var style="color:slategrey;">rvalue</var>, result <var style="color:slategrey;">result</var> \
          [, relative][, endian <var style="color:slategrey;">endian</var>][, string[, {dec|hex|oct}]][, dce] \
          [, bitmask <var style="color:slategrey;">bitmask</var>];</code></pre>
<table><thead><tr><th>Argument</th><th>Description</th></tr></thead><tbody>
<tr><td><code><var>count</var></code></td><td>Number of bytes to pick up from the buffer (valid values include <code>1:10</code> if <code>string</code> argument is used and <code>1:4</code> if <code>string</code> argument is not used)</td></tr>
<tr><td><code><var>offset</var></code></td><td>Variable name or number of bytes into the buffer to start processing (valid values include (valid values include <code>-65535:65535</code>)</td></tr>
<tr><td><code><var>operator</var><code></code></code></td><td>Mathematical operation to perform on the extracted value (valid operations include <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code>)</td></tr>
<tr><td><code><var>rvalue</var></code></td><td>Value to use the mathematical operation with the extracted bytes (valid values include <code>1:4294967295</code> or an extracted <code>byte_extract</code> variable)</td></tr>
<tr><td><code><var>result</var></code></td><td>Name of the variable to store the result in</td></tr>
<tr><td><code>relative</code></td><td>Offset relative from cursor instead of start of buffer</td></tr>
<tr><td><code>endian <var>endian</var></code></td><td>Set to either <code>big</code> or <code>little</code> to specify whether to process the data as little-endian or big-endian (packet bytes are processed as big-endian by default)</td></tr>
<tr><td><code>dce</code></td><td>Use the DCE/RPC 2 inspector engine to determine the byte endianness</td></tr>
<tr><td><code>string</code></td><td>Pick up bytes from packet that are stored in string format (must be followed by <code>, hex</code>, <code>, oct</code>, or  <code>, dec</code>)</td></tr>
<tr><td><code>hex</code></td><td>Extract the string bytes in the packet from a hexadecimal string (must be accompanied by <code>string</code>)</td></tr>
<tr><td><code>oct</code></td><td>Extract the string bytes in the packet from an octal string (must be accompanied by <code>string</code>)</td></tr>
<tr><td><code>dec</code></td><td>Extract the string bytes in the packet from a decimal string (must be accompanied by <code>string</code>)</td></tr>
<tr><td><code>bitmask <var>bitmask</var></code></td><td>Perform an AND bitwise operation with the specified bitmask on the extracted bytes <em>before</em> executing the math operation (valid values are <code>1:<var>count</var></code>)</td></tr>
</tbody></table>
<blockquote>
<p><strong>Note:</strong> If using either the <code>&lt;&lt;</code> or <code>&gt;&gt;</code> operation, then (1) the <code><var>count</var></code> value must be between 1 and 4 bytes, and (2) the <code><var>rvalue</var></code> must be less than 32.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> The <code>bitmask</code> argument result will be right-shifted by the number of bits equal to the number of trailing zeros in the mask.</p>
</blockquote>
<h4 id="examples-60"><a class="header" href="#examples-60">Examples:</a></h4>
<pre><code class="language-snort"># extracts 2 bytes at offset 0, multiplies the extracted number by 10,
# and stores the result in the variable &quot;area&quot;, and then uses
# the resulting variable in a `byte_test` option
byte_math:bytes 2, offset 0, oper *, rvalue 10, result area;
byte_test:2, &gt;, area, 16;
</code></pre>
<pre><code class="language-snort">http_header; 
content:&quot;Content-Length: &quot;,nocase;
# extracts 8 decimal string bytes immediately after &quot;Content-Length: &quot; (if they exist), multiplies
# the value by 10, and stores the result in &quot;content_length&quot;
byte_math:bytes 8, offset 0, oper *, rvalue 10, result content_length, relative, string dec;
</code></pre>
<pre><code class="language-snort">content:&quot;ABCD&quot;;
# this is a valid byte_math option despite the odd ordering of the arguments
# extracts a single byte 10 bytes from the previous match, adds 10 to it,
# performs on it a bitwise AND with 0x12, and stores the result in &quot;var&quot;
byte_math:oper +, rvalue 10, offset 10, result var, bytes 1, bitmask 0x12, relative;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="byte_jump"><a class="header" href="#byte_jump">byte_jump</a></h1>
<p>The <code>byte_jump</code> rule option reads some number of bytes from the packet, converts them from their numeric representation if necessary, and moves that many bytes forward. By having an option that reads the length of a portion of data, rules can be written that skip over specific portions of length-encoded protocols and perform detection in very specific locations.</p>
<p><code>byte_jump</code> is declared with the keyword, followed by a colon character, followed by just two required arguments separated by commas: (1) the number of bytes to grab from the packet and (2) the offset of the bytes to grab. These two arguments must be specified in this order, and there are also a few optional arguments that can be declared afterwards, which are also separated by commas. They are listed and described below. </p>
<h4 id="format-61"><a class="header" href="#format-61">Format:</a></h4>
<pre><code>byte_jump:<var style="color:slategrey;">count</var>, <var style="color:slategrey;">offset</var>[, relative][, multiplier <var style="color:slategrey;">multiplier</var>][,<var style="color:slategrey;">endian</var>] \
          [, string[, {dec|hex|oct}]][, align][, from_beginning][, from_end] \
          [, post_offset <var style="color:slategrey;">adjustment_value</var>][, dce][, bitmask <var style="color:slategrey;">bitmask</var>];
</code></pre>
<table><thead><tr><th><div style="width:250px">Argument</div></th><th>Description</th></tr></thead><tbody>
<tr><td><code><var>count</var></code></td><td>Number of bytes to pick up from the buffer (valid values include <code>0:10</code> if <code>string</code> argument is used and 0:4 if <code>string</code> argument is not used)</td></tr>
<tr><td><code><var>offset</var></code></td><td>Variable name or number of bytes into the buffer to start processing (valid values include <code>-65535:65535</code>)</td></tr>
<tr><td><code>relative</code></td><td>Offset from cursor instead of start of buffer</td></tr>
<tr><td><code>multiplier <var>multiplier</var></code></td><td>Multiply the grabbed value by the given amount (valid values include <code>1:65535</code>)</td></tr>
<tr><td><code><var>endian</var></code></td><td>Set to either <code>big</code> or <code>little</code> to specify whether to process the data as little-endian or big-endian (extracted data is processed as big-endian by default)</td></tr>
<tr><td><code>align</code></td><td>Round the number of converted bytes up to the next 32-bit boundary</td></tr>
<tr><td><code>dce</code></td><td>Use the DCE/RPC 2 inspector engine to determine the byte endianness</td></tr>
<tr><td><code>string</code></td><td>Pick up bytes from the packet that are stored in string format</td></tr>
<tr><td><code>hex</code></td><td>Grab the string bytes in the packet from a hexadecimal string (must be accompanied by <code>string</code>)</td></tr>
<tr><td><code>oct</code></td><td>Grab the string bytes in the packet from an octal string (must be accompanied by <code>string</code>)</td></tr>
<tr><td><code>dec</code></td><td>Grab the string bytes in the packet from a decimal string (the default option when <code>string</code> is set)</td></tr>
<tr><td><code>from_beginning</code></td><td>Jump from the beginning of the packet payload instead of the current cursor location</td></tr>
<tr><td><code>from_end</code></td><td>Jump from the end of the packet payload instead of the current cursor location</td></tr>
<tr><td><code>post_offset <var>adjustment_value</var></code></td><td>Number of bytes to skip forward or backward after the jump (valid values include a variable name or an integer in the following range: <code>-65535:65535</code> )</td></tr>
<tr><td><code>bitmask <var>bitmask</var></code></td><td>Perform an AND bitwise operation with the specified bitmask on the grabbed value before jumping (valid values are <code>1:<var>count</var></code>)</td></tr>
</tbody></table>
<blockquote>
<p><strong>Note:</strong> The <code>bitmask</code> argument result will be right-shifted by the number of bits equal to the number of trailing zeros in the mask.</p>
</blockquote>
<h4 id="examples-61"><a class="header" href="#examples-61">Examples:</a></h4>
<pre><code class="language-snort"># grab the 2 bytes at offset 0 and
# jump that many bytes forward
byte_jump:2,0;
</code></pre>
<pre><code class="language-snort">content:&quot;START&quot;;
byte_extract:1, 0, myvar, relative;
# grab a single byte 3 bytes after the previous 
# byte_extract location, jump forward that number
# of bytes, and then adjust forward &quot;myvar&quot;
# number of bytes after the jump
byte_jump:1,3,relative,post_offset myvar;
content:&quot;END&quot;, distance 6, within 3;
</code></pre>
<pre><code class="language-snort"># grab 2 bytes at offset 1 from the current cursor location,
# bitmask AND the grabbed bytes by 0x03f0, jump the 
# resulting number of bytes, and then adjust forward
# 2 number of bytes after the jump
byte_jump:2,1,relative,post_offset 2,bitmask 0x03f0;
byte_test:2,=,968,0,relative;
</code></pre>
<pre><code class="language-snort"># this grabs 0 bytes so that it can
# jump backwards 6 bytes from the end of the
# current payload
byte_jump:0,0,from_end,post_offset -6;
content:&quot;end..&quot;, distance 0, within 5;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ber_data-and-ber_skip"><a class="header" href="#ber_data-and-ber_skip">ber_data and ber_skip</a></h1>
<p>Snort 3 introduces two new rule options that are useful when writing detection for ASN.1 Basic Encoding Rules (BER), <code>ber_data</code> and <code>ber_skip</code>. Both options move the detection cursor with respect to BER data, but the difference lies in <em>where</em> the cursor is moved.</p>
<p>BER is a type-length-value (TLV) encoding format that encodes data elements in a stream containing (in this order):</p>
<ul>
<li><strong>Type</strong>: typically a single byte that identifies the kind of data being represented</li>
<li><strong>Length</strong>: one or more bytes identifying the size of the value field</li>
<li><strong>Value</strong>: <em>length</em>-number of bytes of the specified type's data</li>
</ul>
<p>For example, consider the following BER-encoded element (assume the below bytes are hex):</p>
<pre><code>02 03 01 00 01
</code></pre>
<p>The <em>type</em> is <code>0x02</code>, which corresponds an <code>INTEGER</code> type. The <em>length</em> is <code>0x03</code>, which tells us that the <em>value</em> is 3-bytes long. Then we just parse those three bytes after the <em>length</em> field to get the integer <em>value</em>:</p>
<pre><code>01 00 01
</code></pre>
<h2 id="encoded-length-fields"><a class="header" href="#encoded-length-fields">Encoded length fields</a></h2>
<p>As mentioned above, the <em>length</em> field can either be a single byte, or it can span <em>multiple</em> bytes. More specifically, the <em>length</em> field will span multiple bytes if the <em>value</em> field contains more than 128 bytes. If that's the case, then bit 7 of the <em>length</em> field will be set, and bits 0-6 will indicate <em>how many</em> length bytes follow. For example, consider the start of this element:</p>
<pre><code>30 82 04 9A 41 41 41 41 …
</code></pre>
<p>The first byte tells us the <em>type</em>, which in this case is <code>0x30</code>. However, notice that our <em>length</em> field is <code>&gt; 0x7f</code>. This means that bit 7 of the length field is set to 1, which means that the <em>length</em> field requires more than one byte. So, we can look at the binary of <code>0x82</code> to figure out what bits 0-6 give us:</p>
<pre><code>10000010
</code></pre>
<p>As we can see, we get <em>2</em> from reading bytes 0-6, and so we know that <strong>two</strong> length bytes follow. We then grab those two bytes ‒ <code>0x049A</code> ‒ to get the <em>length</em> of the subsequent <em>value</em>. Then we can just parse <em>length</em>-number of bytes as we normally would to get the <em>value</em>.</p>
<p>Now let's look at how Snort 3's <code>ber_data</code> and <code>ber_skip</code> rule options are used to work with this kind of data.</p>
<h2 id="ber_data"><a class="header" href="#ber_data">ber_data</a></h2>
<p>The <code>ber_data</code> option moves the detection cursor to the <em>value</em> portion of a specified BER element.</p>
<p>Using this option is done with <code>ber_data:</code> followed by the element's <em>type</em> code. The code can be written in decimal (e.g., 1, 2, 3, 4) or in a hexadecimal (e.g., 0x1, 0x2, 0x3, 0x4), and the valid range of codes is <code>0:255</code>.</p>
<p>For example, let's assume we are looking at a packet starting with <code>02 03 01 00 01</code>. We can move to the <em>value</em> portion of the element with <code>ber_data:0x02;</code>.</p>
<ul>
<li>Detection cursor before the <code>ber_data:0x02;</code>: 
<pre><code>00000000  02 03 01 00 01
</code></pre>
</li>
<li>Detection cursor after the <code>ber_data:0x02;</code>:
<pre><code>00000000 01 00 01 
</code></pre>
</li>
</ul>
<p>Note that <code>ber_data</code> works relative to the cursor's current location in a given buffer. This means that if you don't move the cursor (for example with a <code>content</code> match) prior to using this option, then <code>ber_data</code> will try to pick up bytes at the start of the buffer.</p>
<h4 id="format-62"><a class="header" href="#format-62">Format:</a></h4>
<pre><code>ber_data:<var style="color:slategrey;">type</var>;</code></pre>
<h4 id="examples-62"><a class="header" href="#examples-62">Examples:</a></h4>
<pre><code class="language-snort">ber_data:0x02;
content:&quot;|01 00 01|&quot;, within 3;
</code></pre>
<p>BER elements are commonly nested such that one element's <em>value</em> is the start of another element. Multiple <code>ber_data</code> options can be used to verify that a specific element is present in another:</p>
<pre><code class="language-snort">ber_data:0x30;
# checks that 0x02 is the first element present in 0x30's value
ber_data:0x02;
</code></pre>
<h2 id="ber_skip"><a class="header" href="#ber_skip">ber_skip</a></h2>
<p>The <code>ber_skip</code> option skips an entire BER element. It reads in the <em>length</em> value of the specified <em>type</em>, and jumps that many bytes, moving the cursor to the data immediately following the specified element.</p>
<p>Using this option is done with <code>ber_skip:</code> followed by the <em>type</em> code of the element to skip. The code can be written in decimal (e.g., 1, 2, 3, 4) or in hexadecimal (e.g., 0x1, 0x2, 0x3, 0x4), and the valid range of elements is <code>0:255</code>.</p>
<p>For example, let's assume we are looking an <code>INTEGER</code> element (identified by 0x02) followed by a <code>BOOLEAN</code> element (identified by 0x01): <code>02 01 FF 01 01 05</code>. We can skip the <code>INTEGER</code> element with <code>ber_skip:0x02;</code> to move the cursor to the start of the very next element, the <code>BOOLEAN</code>.</p>
<ul>
<li>Detection cursor before the <code>ber_skip:0x02;</code>: 
<pre><code>00000000  02 01 FF 01 01 05
</code></pre>
</li>
<li>Detection cursor after the <code>ber_skip:0x02;</code>:
<pre><code>00000000  01 01 05
</code></pre>
</li>
</ul>
<p>By default, this rule option will return false if the specified BER element is not found. However, you can specify <code>,optional</code> after the element number to tell Snort that the BER element you want to skip is <em>optional</em>.</p>
<p>Note that <code>ber_skip</code> works relative to the cursor's current location in a given buffer. This means that if you don't move the cursor (for example with a <code>content</code> match) prior to using this option, then <code>ber_skip</code> will try to pick up bytes at the start of the buffer.</p>
<h4 id="format-63"><a class="header" href="#format-63">Format:</a></h4>
<pre><code>ber_skip:<var style="color:slategrey;">type</var>[,optional];</code></pre>
<h4 id="examples-63"><a class="header" href="#examples-63">Examples:</a></h4>
<pre><code class="language-snort">ber_skip:0x02;
content:&quot;|01 01 05|&quot;, within 3;
</code></pre>
<pre><code class="language-snort"># will still continue evaluating even if the 0x02 is not present
ber_skip:0x02,optional;
content:&quot;|01 01 05|&quot;, within 3;
</code></pre>
<h2 id="using-ber_data-and-ber_skip-together"><a class="header" href="#using-ber_data-and-ber_skip-together">Using ber_data and ber_skip together</a></h2>
<p><code>ber_data</code> and <code>ber_skip</code> will often be used together to iterate through BER-encoded structures. LDAP traffic is one common use case. For the below example, consider the following LDAP packet:</p>
<pre><code>00000000  30 33 02 01 02 63 2E 04 00 0A 01 02 0A 01 00 02  03...c..........
00000010  01 00 02 01 00 01 01 00 A0 19 A4 0C 04 02 63 6E  ..............cn
00000020  30 06 81 04 66 72 65 64 A3 09 04 02 64 6E 04 03  0...fred....dn..
00000030  6A 6F 65 30 00                                   joe0.
</code></pre>
<p>The below example will iterate through the various elements to get to the data of the first <code>0x0A</code> tag:</p>
<pre><code class="language-snort"># LDAP is a common example
ber_data:0x30;
ber_skip:0x02,optional;
ber_data:0x63;
ber_skip:0x04;
ber_data:0x0a;
content:&quot;|02|&quot;, within 1;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ssl_state-and-ssl_version"><a class="header" href="#ssl_state-and-ssl_version">ssl_state and ssl_version</a></h1>
<p>Snort features an SSL/TLS service inspector that inspects stream reassembled SSL and TLS traffic and keeps track of the records sent throughout a given session. It provides two options to rule writers, <code>ssl_state</code> and <code>ssl_version</code>, which enable checking for a specific SSL/TLS state and a specific SSL/TLS version, respectively. </p>
<p>These options are declared with the keyword, followed by a ':' character, and then lastly followed by one or more identifiers that are the states or versions to match. The valid identifiers are listed below in their respective sections. </p>
<p>Both options can also be &quot;negated&quot; by placing <code>!</code> after the colon to check that a given SSL/TLS packet does <em>not</em> match a version or state.</p>
<h2 id="ssl_state"><a class="header" href="#ssl_state">ssl_state</a></h2>
<p>The <code>ssl_state</code> rule option tracks the <strong>state</strong> of the SSL/TLS session. The list of states that can be matched are <code>client_hello</code>, <code>server_hello</code>, <code>client_keyx</code>, <code>server_keyx</code>, and <code>unknown</code>. Multiple states can be specified in a single option, via a comma separated list, and are <code>OR</code>-ed together, meaning that if any of them match, the rule option evaluates to true.</p>
<h4 id="format-64"><a class="header" href="#format-64">Format:</a></h4>
<pre><code>ssl_state:[!]{client_hello|server_hello|client_keyx|server_keyx|unknown}
          [,{client_hello|server_hello|client_keyx|server_keyx|unknown}]…;</code></pre>
<h4 id="examples-64"><a class="header" href="#examples-64">Examples</a></h4>
<pre><code class="language-snort">ssl_state:client_hello;
</code></pre>
<pre><code class="language-snort"># client_keyx OR server_keyx
ssl_state:client_keyx,server_keyx;
</code></pre>
<pre><code class="language-snort"># NOT server_hello
ssl_state:!server_hello;
</code></pre>
<h2 id="ssl_version"><a class="header" href="#ssl_version">ssl_version</a></h2>
<p>The <code>ssl_version</code> rule option tracks the specific SSL/TLS version agreed upon by the two parties. The list of versions that can be matched are <code>sslv2</code>, <code>sslv3</code>, <code>tls1.0</code>, <code>tls1.1</code>, and <code>tls1.2</code>. More than one identifier can be specified, via a comma separated list, and are <code>OR</code>-ed together, meaning that if any of them match, the rule option matches.</p>
<h4 id="format-65"><a class="header" href="#format-65">Format:</a></h4>
<pre><code>ssl_version:[!]{sslv2|sslv3|tls1.0|tls1.1|tls1.2}
            [,{sslv2|sslv3|tls1.0|tls1.1|tls1.2}]…;</code></pre>
<h4 id="examples-65"><a class="header" href="#examples-65">Examples</a></h4>
<pre><code class="language-snort">ssl_version:sslv3;
</code></pre>
<pre><code class="language-snort"># TLS 1.0, TLS 1.1, OR TLS 1.2
ssl_version:tls1.0,tls1.1,tls1.2;
</code></pre>
<pre><code class="language-snort"># NOT SSLv2
ssl_version:!sslv2;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dce-specific-options"><a class="header" href="#dce-specific-options">DCE Specific Options</a></h1>
<p>Snort features a DCE-RPC service inspector that keeps track of the DCE-RPC sessions, staying aware of (1) the DCE-RPC interfaces bound to, (2) the specific operation numbers (opnums) invoked, and (3) the stub data associated with DCE-RPC requests and responses. This service inspector also provides three rule options for each of these components, <code>dce_iface</code>, <code>dce_opnum</code>, and <code>dce_stub_data</code>, that are used to check packets against specific DCE-RPC requests or responses.</p>
<h2 id="dce_iface"><a class="header" href="#dce_iface">dce_iface</a></h2>
<p>The <code>dce_iface</code> option is used to specify an interface UUID that a client has bound to. It is declared with <code>dce_iface:</code>, followed by <code>uuid </code>, and lastly followed by the actual UUID to match. Users can also optionally specify an interface version and operator to check that the DCE-RPC version is less than (<code>&lt;</code>), greater than (<code>&gt;</code>), equal to (<code>=</code>) or not equal to (<code>!</code>) the version specified. Valid version numbers include <code>0:65535</code>.</p>
<p>Also, by default the rule will only be evaluated against a first fragment (or the full request if not fragmented) since most rules are written to start at the beginning of a request. However, rule-writers can specify the optional <code>any_frag</code> argument to evaluate against middle and last fragments as well.</p>
<h4 id="format-66"><a class="header" href="#format-66">Format:</a></h4>
<p>DCE-RPC interface versions are not required, but there are two ways to check for a specific version or versions. Both formats are below.</p>
<blockquote>
<p>Note: UUIDs are formatted like: <code><var style="color:slategrey;">4hexbytes</var>-<var style="color:slategrey;">2hexbytes</var>-<var style="color:slategrey;">2hexbytes</var>-<var style="color:slategrey;">2hexbytes</var>-<var style="color:slategrey;">6hexbytes</var></code></p>
</blockquote>
<h5 id="single-value-version-comparison"><a class="header" href="#single-value-version-comparison">Single value version comparison:</a></h5>
<pre><code>dce_iface:uuid <var style="color:slategrey;">uuid</var> [, version [<|>|=|!|<=|>=]<var style="color:slategrey;">version</var>][, any_frag];</code></pre>
<h5 id="range-of-versions-comparison"><a class="header" href="#range-of-versions-comparison">Range of versions comparison:</a></h5>
<pre><code>dce_iface:uuid <var style="color:slategrey;">uuid</var> [, version <var style="color:slategrey;">min_version</var>{<>|<=>}<var style="color:slategrey;">max_version</var>][, any_frag];</code></pre>
<h4 id="examples-66"><a class="header" href="#examples-66">Examples:</a></h4>
<pre><code class="language-snort">dce_iface:uuid 4b324fc8-1670-01d3-1278-5a47bf6ee188;
</code></pre>
<pre><code class="language-snort">dce_iface:uuid 4b324fc8-1670-01d3-1278-5a47bf6ee188, version &lt;2;
</code></pre>
<pre><code class="language-snort">dce_iface:uuid 4b324fc8-1670-01d3-1278-5a47bf6ee188, any_frag;
</code></pre>
<pre><code class="language-snort">dce_iface:uuid 4b324fc8-1670-01d3-1278-5a47bf6ee188, version =1, any_frag;
</code></pre>
<h2 id="dce_opnum"><a class="header" href="#dce_opnum">dce_opnum</a></h2>
<p>The <code>dce_opnum</code> option enables users to check that a packet belongs to a specific DCE-RPC operation invocation. It is declared with <code>dce_opnum:</code> followed by either a single opnum number, an opnum number range, or an opnum list containing a combination of opnums and/or opnum ranges, and the entire argument is enclosed in double quotes. The rule option option matches if <em>any one</em> of the opnums specified match the opnum associated with a DCE/RPC request or response.</p>
<p>An opnum range is declared with a hyphen between the two numbers of the range (e.g., <code>1-10</code>), and multiple opnums or opnum ranges are separated by spaces.</p>
<blockquote>
<p><strong>Note:</strong> Multiple opnums and/or opnum ranges were previously separated by commas. Separating them by spaces is a change new to Snort 3.</p>
</blockquote>
<h4 id="format-67"><a class="header" href="#format-67">Format:</a></h4>
<pre><code>dce_opnum:"{<var style="color:slategrey;">opnum</var>|<var style="color:slategrey;">min_opnum</var>-<var style="color:slategrey;">max_opnum</var>}[ {<var style="color:slategrey;">opnum</var>|<var style="color:slategrey;">min_opnum</var>-<var style="color:slategrey;">max_opnum</var>}]…";</code></pre>
<blockquote>
<p><strong>Note</strong>: Valid opnum numbers are <code>0-65535</code>.</p>
</blockquote>
<h4 id="examples-67"><a class="header" href="#examples-67">Examples:</a></h4>
<pre><code class="language-snort">dce_opnum:&quot;15&quot;;
dce_opnum:&quot;15-18&quot;;
dce_opnum:&quot;15 18-20&quot;;
dce_opnum:&quot;15 17 20-22&quot;;
</code></pre>
<h2 id="dce_stub_data"><a class="header" href="#dce_stub_data">dce_stub_data</a></h2>
<p>The <code>dce_stub_data</code> option is a sticky buffer that is used to set the detection cursor to the beginning of the DCE/RPC stub data, regardless of preceding rule options. All ensuing rule options are checked for in this stub data buffer, and the first rule option following <code>dce_stub_data</code> should use absolute location modifiers if it is position-dependent.</p>
<p>This option takes no arguments and is set just with the keyword itself.</p>
<blockquote>
<p><strong>Note:</strong> To leave the stub data buffer and return to the main payload buffer, use the &quot;pkt_data&quot; rule option after done inspecting <code>dce_stub_data</code> data.</p>
</blockquote>
<h4 id="format-68"><a class="header" href="#format-68">Format:</a></h4>
<pre><code>dce_stub_data;
</code></pre>
<h4 id="examples-68"><a class="header" href="#examples-68">Examples:</a></h4>
<pre><code class="language-snort">dce_stub_data;
byte_test:4,&gt;,128,8,dce;
</code></pre>
<pre><code class="language-snort">dce_stub_data; 
pcre:&quot;/^(\x00\x00\x00\x00|.{12})/s&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="sip-specific-options"><a class="header" href="#sip-specific-options">SIP Specific Options</a></h1>
<p>Snort 3's Session Initiation Protocol (SIP) inspector keeps track of SIP request and response messages, and it provides four rule options that let rule-writers look for specific SIP components: <code>sip_method</code>, <code>sip_header</code>, <code>sip_body</code>, and <code>sip_stat_code</code>.</p>
<h2 id="sip_method"><a class="header" href="#sip_method">sip_method</a></h2>
<p>The <code>sip_method</code> rule option enables rule writers to check packets against a specific SIP method or multiple SIP methods. The list of methods that can be matched include <code>invite</code>, <code>cancel</code>, <code>ack</code>, <code>bye</code>, <code>register</code>, <code>options</code>, <code>refer</code>, <code>subscribe</code>, <code>update</code>, <code>join</code>, <code>info</code>, <code>message</code>, <code>notify</code>, and <code>prack</code>. </p>
<p>It's declared with <code>sip_method:</code> followed by one or more methods to look for. Multiple methods are specified via a comma separated list, and evaluation checks for any of the specified methods against any SIP methods extracted from a given packet. </p>
<p>This option can also be &quot;negated&quot; by placing <code>!</code> after the colon to check that a given SIP method does not match a particular method.</p>
<h4 id="format-69"><a class="header" href="#format-69">Format:</a></h4>
<pre><code>sip_method:[!]<var style="color:slategrey;">method</var>[,<var style="color:slategrey;">method</var>]…;</code></pre>
<h4 id="examples-69"><a class="header" href="#examples-69">Examples:</a></h4>
<pre><code class="language-snort">sip_method:invite, cancel;
</code></pre>
<pre><code class="language-snort">sip_method:!invite;
</code></pre>
<pre><code class="language-snort"># check that a SIP message is not an INVITE AND also not a BYE
sip_method:!invite; 
sip_method:!bye;
</code></pre>
<blockquote>
<p><strong>Note:</strong> While SIP methods are case-sensitive, the arguments for this option are case-insensitive.</p>
</blockquote>
<h2 id="sip_header"><a class="header" href="#sip_header">sip_header</a></h2>
<p>The <code>sip_header</code> rule option is a sticky buffer that sets the detection cursor to the buffers containing extracted SIP headers from a SIP message request or response. This option takes no arguments and is declared before all other payload options that one wants to match against the SIP header portion of a message. </p>
<h4 id="format-70"><a class="header" href="#format-70">Format:</a></h4>
<pre><code>sip_header;
</code></pre>
<h4 id="examples-70"><a class="header" href="#examples-70">Examples:</a></h4>
<pre><code class="language-snort">sip_header; 
content:&quot;CSeq&quot;;
</code></pre>
<h2 id="sip_body"><a class="header" href="#sip_body">sip_body</a></h2>
<p>The <code>sip_body</code> rule option is a sticky buffer that sets the detection cursor to a SIP message body. This option takes no arguments and is declared before all other payload options that one wants to match against the SIP body portion of a message.</p>
<h4 id="format-71"><a class="header" href="#format-71">Format:</a></h4>
<pre><code>sip_body;
</code></pre>
<h4 id="examples-71"><a class="header" href="#examples-71">Examples:</a></h4>
<pre><code class="language-snort">sip_body; 
content:&quot;v=0|0D 0A|&quot;, within 5;
</code></pre>
<h2 id="sip_stat_code"><a class="header" href="#sip_stat_code">sip_stat_code</a></h2>
<p>The <code>sip_stat_code</code> option is used to check the status code of a SIP response packet.</p>
<p>This option is declared with <code>sip_stat_code:</code> followed by a status code or status codes to match. Multiple status codes are specified via a comma separated list, and evaluation checks for any of the specified codes are present in a given SIP response packet.</p>
<p>Valid stat codes are <code>1-9</code> and <code>100-999</code>.</p>
<h4 id="format-72"><a class="header" href="#format-72">Format:</a></h4>
<pre><code>sip_stat_code:<var style="color:slategrey;">stat_code</var>[,<var style="color:slategrey;">stat_code</var>]…;</code></pre> 
<blockquote>
<p><strong>Note:</strong> <code>1-9</code> codes mean to check for <code>1xx</code>, <code>2xx</code>, <code>3xx</code>, <code>4xx</code>, etc. responses.</p>
</blockquote>
<h4 id="examples-72"><a class="header" href="#examples-72">Examples:</a></h4>
<pre><code class="language-snort">sip_stat_code:200;
</code></pre>
<pre><code class="language-snort"># match any 2xx SIP status codes
sip_stat_code:2;  
</code></pre>
<pre><code class="language-snort"># match a SIP status code of 200 or 180
sip_stat_code:200, 180;
</code></pre>
<pre><code class="language-snort"># match any 2xx SIP status codes or any 4xx SIP status codes
sip_stat_code:200, 180;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="sd_pattern"><a class="header" href="#sd_pattern">sd_pattern</a></h1>
<p>The <code>sd_pattern</code> rule option detects and filters Personally Identifiable Information (PII) and other sensitive information, such as credit card numbers, U.S. Social Security numbers, and email addresses. </p>
<p>This rule option has just one required argument, which is the specific pattern to detect. Snort has three built-in patterns:</p>
<ul>
<li><code>&quot;credit_card&quot;</code>, </li>
<li><code>&quot;us_social&quot;</code></li>
<li><code>&quot;us_social_nodashes&quot;</code>, </li>
</ul>
<p>If used in the rule option, Snort will replace those strings with the actual patterns themselves.</p>
<p>Snort users can also define their own patterns by including a PCRE-compatible regular expression as the argument instead. The pattern argument will be enclosed in double quotes, regardless if it's a built-in pattern or not. If a built-in one is used, however, Snort will replace it with the appropriate pattern and then validate that data in the packet matches it.</p>
<p>There exists also one optional argument that can be added after the pattern string: <code>threshold</code>. By default, <code>sd_pattern</code> looks for just one instance of the pattern before firing, but users can specify the <code>threshold</code> argument to require that there are multiple hits on that pattern in a single packet before firing. The format of this option can be seen in the format section below.</p>
<blockquote>
<p><strong>Note</strong>: The <code>sd_pattern</code> rule option uses the hyperscan engine to perform pattern matching, meaning Snort must be built with the hyperscan libraries to use it.</p>
</blockquote>
<h4 id="obfuscating-pii"><a class="header" href="#obfuscating-pii">Obfuscating PII</a></h4>
<p>By default, Snort will not obfuscate credit card and social security numbers when outputting packet data to logs. However, users can enable obfuscation with the <code>ips.obfuscate_pii</code> configuration, which will mask all but the last four characaters of credit card and social security numbers. Enabling this is as easy as setting this configuration option to <code>true</code>, either in a Snort config or on the command line.</p>
<p>Here's an example showcasing how this works. Consider a credit card number that is &quot;5555555555554444&quot;. Looking for <code>sd_pattern:&quot;credit_card&quot;;</code> in a rule and outputting the alerts as <code>cmg</code> will produce the following output:</p>
<pre><code>$ snort -q -r cc.pcap -R local.rules -A cmg
10/19-10:29:55.494550 [**] [1:1:0] &quot;credit card found&quot; [**] [Priority: 0] {TCP} 10.1.2.3:50284 -&gt; 10.9.8.7:1234
02:01:02:03:04:05 -&gt; 02:09:08:07:06:05 type:0x800 len:0x46
10.1.2.3:50284 -&gt; 10.9.8.7:1234 TCP TTL:64 TOS:0x0 ID:3 IpLen:20 DgmLen:56
***A**** Seq: 0x2  Ack: 0x2  Win: 0x2000  TcpLen: 20

snort.raw[16]:
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
35 35 35 35 35 35 35 35  35 35 35 35 34 34 34 34  55555555 55554444
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
</code></pre>
<p>However, we can enable obfuscation and conceal the credit card number with the above configuration setting:</p>
<pre><code>$ snort -q -r cc.pcap -R local.rules -A cmg --lua 'ips.obfuscate_pii = true'
10/19-10:29:55.494550 [**] [1:1:0] &quot;credit card found&quot; [**] [Priority: 0] {TCP} 10.1.2.3:50284 -&gt; 10.9.8.7:1234
02:01:02:03:04:05 -&gt; 02:09:08:07:06:05 type:0x800 len:0x46
10.1.2.3:50284 -&gt; 10.9.8.7:1234 TCP TTL:64 TOS:0x0 ID:3 IpLen:20 DgmLen:56
***A**** Seq: 0x2  Ack: 0x2  Win: 0x2000  TcpLen: 20

snort.raw[16]:
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
58 58 58 58 58 58 58 58  58 58 58 58 34 34 34 34  XXXXXXXX XXXX4444
- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
</code></pre>
<p>We should note, however, that log obfuscation is only applicable to CMG and Unified2 logging formats and that it doesn't support user defined PII patterns.</p>
<h4 id="format-73"><a class="header" href="#format-73">Format:</a></h4>
<pre><code>sd_pattern:"<var style="color:slategrey;">pattern</var>"[, threshold <var style="color:slategrey;">count</var>];</code></pre>
<h4 id="examples-73"><a class="header" href="#examples-73">Examples</a></h4>
<pre><code class="language-snort"># matches all credit card patterns 
sd_pattern:&quot;credit_card&quot;;
</code></pre>
<pre><code class="language-snort"># matches likely email addresses for the site &quot;ourdomain.com&quot;
sd_pattern:&quot;\b\w+@ourdomain\.com\b&quot;;
</code></pre>
<pre><code class="language-snort"># look for that string literal 300 times before firing
sd_pattern:&quot;This is a string literal&quot;, threshold 300;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cvs"><a class="header" href="#cvs">cvs</a></h1>
<p>The <code>cvs</code> rule option is used to detect CVS vulnerabilities, and currently only one vulnerability is able to be detected: &quot;Malformed Entry Modified and Unchanged flag insertion&quot;. This optional specifically looks for attempts to exploit a heap buffer overflow in CVS via malformed &quot;Entry lines&quot;.</p>
<p>Each CVS vulnerability corresponds to an option name in Snort, and that option name is what's passed to the <code>cvs</code> option as an argument. But because there's currently only one CVS vulnerability that Snort can detect, there's only one option available: <code>invalid-entry</code>.</p>
<h4 id="format-74"><a class="header" href="#format-74">Format:</a></h4>
<pre><code>cvs:<var style="color:slategrey;">option</var>;</code></pre>
<h4 id="examples-74"><a class="header" href="#examples-74">Examples:</a></h4>
<pre><code class="language-snort">cvs:invalid-entry;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="md5-sha256-and-sha512"><a class="header" href="#md5-sha256-and-sha512">md5, sha256, and sha512</a></h1>
<p>There exists three &quot;hash&quot; options that are each used to check some payload data against a hash value: <code>md5</code>, <code>sha256</code>, and <code>sha512</code>. </p>
<p>Each option requires two arguments: the actual hash enclosed in double quotes and the number of bytes from the payload to get the hash of. Additionally, users can also specify an <code>offset <var>offset</var></code> argument to check for bytes at a specific location and/or the <code>relative</code> argument to hash the bytes relative to the current cursor location. </p>
<p>The offset value can be either an integer from <code>-65535:65535</code>, or it can be the name of a variable extracted with <code>byte_extract</code>.</p>
<p>Lastly, each hash option can be negated by placing a <code>!</code> before the hash value.</p>
<p>All three options are structured the same with the only difference being the option name.</p>
<blockquote>
<p><strong>Note</strong>: Because hash values are typically represented in hex format, the hash values should also be enclosed in vertical bars (<code>|</code>) inside the quotes.</p>
</blockquote>
<h2 id="md5"><a class="header" href="#md5">md5</a></h2>
<h4 id="format-75"><a class="header" href="#format-75">Format:</a></h4>
<pre><code>md5:[!]"|<var style="color:slategrey;">hash</var>|", length <var style="color:slategrey;">length</var>[, offset <var style="color:slategrey;">offset</var>][, relative];</code></pre>
<h4 id="examples-75"><a class="header" href="#examples-75">Examples:</a></h4>
<pre><code class="language-snort">md5:&quot;|7cf2db5ec261a0fa27a502d3196a6f60|&quot;, length 100, offset 0, relative;
</code></pre>
<h2 id="sha256"><a class="header" href="#sha256">sha256</a></h2>
<h4 id="format-76"><a class="header" href="#format-76">Format:</a></h4>
<pre><code>sha256:[!]"|<var style="color:slategrey;">hash</var>|", length <var style="color:slategrey;">length</var>[, offset <var style="color:slategrey;">offset</var>][, relative];</code></pre>
<h4 id="examples-76"><a class="header" href="#examples-76">Examples:</a></h4>
<pre><code class="language-snort">sha256:&quot;|9ed1515819dec61fd361d5fdabb57f41ecce1a5fe1fe263b98c0d6943b9b232e|&quot;, \
       length 100, offset 0, relative;
</code></pre>
<h2 id="sha512"><a class="header" href="#sha512">sha512</a></h2>
<h4 id="format-77"><a class="header" href="#format-77">Format:</a></h4>
<pre><code>sha512:[!]"|<var style="color:slategrey;">hash</var>|", length <var style="color:slategrey;">length</var>[, offset <var style="color:slategrey;">offset</var>][, relative];</code></pre>
<h4 id="examples-77"><a class="header" href="#examples-77">Examples:</a></h4>
<pre><code class="language-snort">sha512:&quot;|d8fefb4255686e6bf365b0f4763fad983f624beb7cbbb59b617c745c346b8db51a870fe0a89cfba036cfbf2d011686b881acd8ab3278b318a304227ac2a99072|&quot;, \
       length 100, offset 0, relative;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="gtp-specific-options"><a class="header" href="#gtp-specific-options">GTP Specific Options</a></h1>
<p>There exists a general-packet-radio-service tunneling protocol (GTP) service inspector that enables GTP control channel inspection in Snort. There are three GTP-specific rule options: <code>gtp_info</code>, <code>gtp_type</code>, and <code>gtp_version</code>.</p>
<h2 id="gtp_info"><a class="header" href="#gtp_info">gtp_info</a></h2>
<p>The <code>gtp_info</code> rule option is used to check the &quot;Information Element&quot; field of GTP packets. This option takes in a single argument that can be either an integer or a string that maps to one of the info elements defined in the <a href="https://github.com/snort3/snort3/blob/1e6e7f0b735e53367ac5498ad033ea68d5e186a4/lua/snort_defaults.lua#L775">snort_defaults.lua file</a>. Please note that the information element values do vary depending on the GTP version. </p>
<blockquote>
<p><strong>Note</strong>: Both the integer and string info values should <em>not</em> be enclosed in double quotes when supplied to this option.</p>
</blockquote>
<h4 id="format-78"><a class="header" href="#format-78">Format:</a></h4>
<pre><code>gtp_info:<var style="color:slategrey;">info_element</var>;</code></pre>
<h4 id="examples-78"><a class="header" href="#examples-78">Examples:</a></h4>
<pre><code class="language-snort">gtp_info:16;
</code></pre>
<pre><code class="language-snort">gtp_info:packet_flow_id;
</code></pre>
<h2 id="gtp_type"><a class="header" href="#gtp_type">gtp_type</a></h2>
<p>The <code>gtp_type</code> rule option is used to check for specific GTP Message Type values. This rule option takes in a &quot;type list&quot; that is one or more type values separated by spaces. The type values can either be an integer or a string that corresponds to one of the table entries in the <a href="https://github.com/snort3/snort3/blob/1e6e7f0b735e53367ac5498ad033ea68d5e186a4/lua/snort_defaults.lua#L556">snort_defaults.lua file</a>. Please note that the type values do vary depending on the GTP version. </p>
<p>Additionally, the entire type list should also be enclosed in double quotes.</p>
<p>If more than one type is provided, Snort will trigger an event if <em>any</em> one of them is seen on the wire.</p>
<h4 id="format-79"><a class="header" href="#format-79">Format:</a></h4>
<pre><code>gtp_type:"<var style="color:slategrey;">type</var>[ <var style="color:slategrey;">type</var>]…";</code></pre>
<h4 id="examples-79"><a class="header" href="#examples-79">Examples:</a></h4>
<pre><code class="language-snort">gtp_type:&quot;255 16&quot;;
</code></pre>
<pre><code class="language-snort">gtp_type:&quot;255 create_pdp_context_request&quot;;
</code></pre>
<h2 id="gtp_version"><a class="header" href="#gtp_version">gtp_version</a></h2>
<p>The <code>gtp_version</code> option is used to check GTP version numbers. This option takes just a single option—an integer that is the version to look for. Valid version number arguments include <code>0</code>, <code>1</code>, and <code>2</code>.</p>
<h4 id="format-80"><a class="header" href="#format-80">Format:</a></h4>
<pre><code>gtp_version:<var style="color:slategrey;">version_num</var>;</code></pre>
<h4 id="examples-80"><a class="header" href="#examples-80">Examples:</a></h4>
<pre><code class="language-snort">gtp_version:1;
</code></pre>
<pre><code class="language-snort">gtp_version:2;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dnp3-specific-options"><a class="header" href="#dnp3-specific-options">DNP3 Specific Options</a></h1>
<p>The DNP3 service inspector in Snort 3 provides anomaly detection and IPS rule options for matching on data, functions, indications and objects in DNP3 messages. Configuration of the ports is handled by the binder. This service inspector offers four IPS rule options: <code>dnp3_func</code>, <code>dnp3_ind</code>, <code>dnp3_obj</code>, and <code>dnp3_data</code>.</p>
<h2 id="dnp3_func"><a class="header" href="#dnp3_func">dnp3_func</a></h2>
<p>The <code>dnp3_func</code> rule option is used to check for DNP3 function codes. This rule option takes in either a function code number or a function code string. The supported function codes and their string and number mappings are defined in Snort's <a href="https://github.com/snort3/snort3/blob/35b6804f4506993029221450769a76e6281ae4ec/src/service_inspectors/dnp3/dnp3_map.cc#L39">dnp3_map.cc file</a>.</p>
<h4 id="format-81"><a class="header" href="#format-81">Format:</a></h4>
<pre><code>dnp3_func:<var style="color:slategrey;">function_code</var>;</code></pre>
<h4 id="examples-81"><a class="header" href="#examples-81">Examples:</a></h4>
<pre><code class="language-snort">dnp3_func:0;
</code></pre>
<pre><code class="language-snort">dnp3_func:confirm;
</code></pre>
<h2 id="dnp3_ind"><a class="header" href="#dnp3_ind">dnp3_ind</a></h2>
<p>The <code>dnp3_ind</code> rule option is used to check DNP3 indicator flags. This rule option takes in a &quot;indicator flag list&quot; that is one or more indicator flag values separated by spaces. The indicator flag values are string values corresponding to the table defined in Snort's <a href="https://github.com/snort3/snort3/blob/35b6804f4506993029221450769a76e6281ae4ec/src/service_inspectors/dnp3/dnp3_map.cc#L81">dnp3_map.cc file</a>.</p>
<p>Additionally, the entire flag list should also be enclosed in double quotes.</p>
<p>If more than one flag is provided, Snort will trigger an event if any one of them is seen on the wire.</p>
<h4 id="format-82"><a class="header" href="#format-82">Format:</a></h4>
<pre><code>dnp3_ind:"<var style="color:slategrey;">indicator_flag</var>[ <var style="color:slategrey;">indicator_flag</var> ]…";</code></pre>
<h4 id="examples-82"><a class="header" href="#examples-82">Examples:</a></h4>
<pre><code class="language-snort">dnp3_ind:&quot;config_corrupt event_buffer_overflow need_time&quot;;
</code></pre>
<pre><code class="language-snort">dnp3_ind:&quot;need_time&quot;;
</code></pre>
<h2 id="dnp3_obj"><a class="header" href="#dnp3_obj">dnp3_obj</a></h2>
<p>The <code>dnp3_obj</code> rule option is used to check DNP3 object headers. This rule option enables users the ability to check for specific DNP3 data object types by checking for a specific <strong>object group</strong> and a specific <strong>object group variation</strong>. Thus, this option takes as arguments two things: a group number and a variation number.</p>
<h4 id="format-83"><a class="header" href="#format-83">Format:</a></h4>
<pre><code>dnp3_obj:group <var style="color:slategrey;">group_number</var>, var <var style="color:slategrey;">varation_number</var>;</code></pre>
<h4 id="examples-83"><a class="header" href="#examples-83">Examples:</a></h4>
<pre><code class="language-snort">dnp3_obj:group 80, var 1;
</code></pre>
<pre><code class="language-snort">dnp3_obj:group 60, var 2;
</code></pre>
<h2 id="dnp3_data"><a class="header" href="#dnp3_data">dnp3_data</a></h2>
<p>The <code>dnp3_data</code> rule option sets the cursor to the beginning of DNP3 Application Layer data. This is a sticky buffer, so once set, all subsequent rule options will be evaluated against <code>dnp3_data</code> unless the cursor is reset or moved to another buffer.</p>
<h4 id="format-84"><a class="header" href="#format-84">Format:</a></h4>
<pre><code>dnp3_data;
</code></pre>
<h4 id="examples-84"><a class="header" href="#examples-84">Examples:</a></h4>
<pre><code class="language-snort">dnp3_data; 
content:&quot;badstuff&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cip-specific-options"><a class="header" href="#cip-specific-options">CIP Specific Options</a></h1>
<p>Snort 3 features a Common Industrial Protocol (CIP) service inspector that does CIP decoding and enables detection of various CIP fields. This service inspector is also able to decode Ethernet/IP (ENIP) protocols as well.</p>
<p>The CIP inspector provides 11 different rule options: <code>cip_attribute</code>, <code>cip_class</code>, <code>cip_conn_path_class</code>, <code>enip_command</code>, <code>enip_req</code>, <code>enip_rsp</code>, <code>cip_instance</code>, <code>cip_req</code>, <code>cip_rsp</code>, <code>cip_service</code>, and <code>cip_status</code>. Each of these options is broken down below.</p>
<p>This inspector is disabled by default, and so you will need to enable the <code>cip</code> service inspector and add entries to the binder in your Snort config to tell Snort which traffic to run the <code>cip</code> service inspector on. Below is a snippet of a Snort config showing these two things:</p>
<pre><code class="language-lua">-- enable the CIP inspector
cip = { }
-- add CIP binder entries
binder = 
{
    { when = { proto = 'tcp', ports = '44818', role = 'server' }, use = { type = 'cip' } },
    { when = { proto = 'udp', ports = '22222', role = 'server' }, use = { type = 'cip' } },
</code></pre>
<h2 id="cip_attribute"><a class="header" href="#cip_attribute">cip_attribute</a></h2>
<p>The <code>cip_attribute</code> rule option is used to look for a single CIP attribute or multiple CIP attributes.</p>
<p>This rule option takes in one argument, which is either a single attribute value used with an optional comparison operator sign, or a range of attributes using one of two range operator signs. The range comparison is done by including either the <code>&lt;&gt;</code> or <code>&lt;=&gt;</code> sign and putting the minimum number the left of the sign and the maximum number to the right of it. The <code>&lt;&gt;</code> case is for an <em>exclusive</em> min-max check, while the <code>&lt;=&gt;</code> is for an <em>inclusive</em> min-max check.</p>
<h4 id="format-85"><a class="header" href="#format-85">Format:</a></h4>
<h5 id="single-value-comparison-5"><a class="header" href="#single-value-comparison-5">Single value comparison:</a></h5>
<pre><code>cip_attribute:[<|>|=|!|<=|>=]<var style="color:slategrey;">attribute</var>;</code></pre>
<h5 id="range-comparison-5"><a class="header" href="#range-comparison-5">Range comparison:</a></h5>
<pre><code>cip_attribute:<var style="color:slategrey;">min_attribute</var>{<>|<=>}<var style="color:slategrey;">max_attribute</var>;</code></pre>
<h4 id="examples-85"><a class="header" href="#examples-85">Examples:</a></h4>
<pre><code class="language-snort">cip_attribute:5;
</code></pre>
<pre><code class="language-snort">cip_attribute:&gt;5;
</code></pre>
<h2 id="cip_class"><a class="header" href="#cip_class">cip_class</a></h2>
<p>The <code>cip_class</code> rule option is used to look for a single CIP class or multiple CIP classes.</p>
<p>This rule option takes in one argument, which is either a single class value used with an optional comparison operator sign, or a range of classes using one of two range operator signs. The range comparison is done by including either the <code>&lt;&gt;</code> or <code>&lt;=&gt;</code> sign and putting the minimum number the left of the sign and the maximum number to the right of it. The <code>&lt;&gt;</code> case is for an <em>exclusive</em> min-max check, while the <code>&lt;=&gt;</code> is for an <em>inclusive</em> min-max check.</p>
<h4 id="format-86"><a class="header" href="#format-86">Format:</a></h4>
<h5 id="single-value-comparison-6"><a class="header" href="#single-value-comparison-6">Single value comparison:</a></h5>
<pre><code>cip_class:[<|>|=|!|<=|>=]<var style="color:slategrey;">class</var>;</code></pre>
<h5 id="range-comparison-6"><a class="header" href="#range-comparison-6">Range comparison:</a></h5>
<pre><code>cip_class:<var style="color:slategrey;">min_class</var>{<>|<=>}<var style="color:slategrey;">max_class</var>;</code></pre>
<h4 id="examples-86"><a class="header" href="#examples-86">Examples:</a></h4>
<pre><code class="language-snort">cip_class:2;
</code></pre>
<pre><code class="language-snort">cip_class:2&lt;&gt;5;
</code></pre>
<h2 id="cip_conn_path_class"><a class="header" href="#cip_conn_path_class">cip_conn_path_class</a></h2>
<p>The <code>cip_conn_path_class</code> rule option is used to match a single CIP connection path class or multiple CIP connection path classes.</p>
<p>This rule option takes in one argument, which is either a single connection path class value used with an optional comparison operator sign, or a range of connection path class using one of two range operator signs. The range comparison is done by including either the <code>&lt;&gt;</code> or <code>&lt;=&gt;</code> sign and putting the minimum number the left of the sign and the maximum number to the right of it. The <code>&lt;&gt;</code> case is for an <em>exclusive</em> min-max check, while the <code>&lt;=&gt;</code> is for an <em>inclusive</em> min-max check.</p>
<h4 id="format-87"><a class="header" href="#format-87">Format:</a></h4>
<h5 id="single-value-comparison-7"><a class="header" href="#single-value-comparison-7">Single value comparison:</a></h5>
<pre><code>cip_conn_path_class:[<|>|=|!|<=|>=]<var style="color:slategrey;">conn_path_class</var>;</code></pre>
<h5 id="range-comparison-7"><a class="header" href="#range-comparison-7">Range comparison:</a></h5>
<pre><code>cip_conn_path_class:<var style="color:slategrey;">min_conn_path_class</var>{<>|<=>}<var style="color:slategrey;">max_conn_path_class</var>;</code></pre>
<p>The chosen <code><var style="color:slategrey;">conn_path_class</var></code> values must be in the following range: <code>0:65535</code>.</p>
<h4 id="examples-87"><a class="header" href="#examples-87">Examples:</a></h4>
<pre><code class="language-snort">cip_conn_path_class:10;
</code></pre>
<pre><code class="language-snort">cip_conn_path_class:!0;
</code></pre>
<h2 id="cip_instance"><a class="header" href="#cip_instance">cip_instance</a></h2>
<p>The <code>cip_instance</code> rule option is used to match a single CIP instance value or multiple CIP instance values.</p>
<p>This rule option takes in one argument, which is either a single instance value used with an optional comparison operator sign, or a range of instance values using one of two range operator signs. The range comparison is done by including either the <code>&lt;&gt;</code> or <code>&lt;=&gt;</code> sign and putting the minimum number the left of the sign and the maximum number to the right of it. The <code>&lt;&gt;</code> case is for an <em>exclusive</em> min-max check, while the <code>&lt;=&gt;</code> is for an <em>inclusive</em> min-max check.</p>
<h4 id="format-88"><a class="header" href="#format-88">Format:</a></h4>
<h5 id="single-value-comparison-8"><a class="header" href="#single-value-comparison-8">Single value comparison:</a></h5>
<pre><code>cip_instance:[<|>|=|!|<=|>=]<var style="color:slategrey;">cip_instance</var>;</code></pre>
<h5 id="range-comparison-8"><a class="header" href="#range-comparison-8">Range comparison:</a></h5>
<pre><code>cip_instance:<var style="color:slategrey;">min_cip_instance</var>{<>|<=>}<var style="color:slategrey;">max_cip_instance</var>;</code></pre>
<p>The chosen <code><var style="color:slategrey;">cip_instance</var></code> values must be in the following range: <code>0:4294967295</code>.</p>
<h4 id="examples-88"><a class="header" href="#examples-88">Examples:</a></h4>
<pre><code class="language-snort">cip_instance:33;
</code></pre>
<pre><code class="language-snort">cip_instance:!33;
</code></pre>
<h2 id="cip_req"><a class="header" href="#cip_req">cip_req</a></h2>
<p>The <code>cip_req</code> rule option is used to match CIP request packets.</p>
<p>This rule option takes no arguments.</p>
<h4 id="format-89"><a class="header" href="#format-89">Format:</a></h4>
<pre><code>cip_req;
</code></pre>
<h4 id="examples-89"><a class="header" href="#examples-89">Examples:</a></h4>
<pre><code class="language-snort">cip_req;
</code></pre>
<h2 id="cip_rsp"><a class="header" href="#cip_rsp">cip_rsp</a></h2>
<p>The <code>cip_rsp</code> rule option is used to match CIP response packets. </p>
<p>This rule option takes no arguments.</p>
<h4 id="format-90"><a class="header" href="#format-90">Format:</a></h4>
<pre><code class="language-snort">cip_rsp;
</code></pre>
<h4 id="examples-90"><a class="header" href="#examples-90">Examples:</a></h4>
<pre><code class="language-snort">cip_rsp;
</code></pre>
<h2 id="cip_service"><a class="header" href="#cip_service">cip_service</a></h2>
<p>The <code>cip_service</code> rule option is used to match a single CIP service value or multiple CIP service values.</p>
<p>This rule option takes in one argument, which is either a single service value used with an optional comparison operator sign, or a range of service values using one of two range operator signs. The range comparison is done by including either the <code>&lt;&gt;</code> or <code>&lt;=&gt;</code> sign and putting the minimum number the left of the sign and the maximum number to the right of it. The <code>&lt;&gt;</code> case is for an <em>exclusive</em> min-max check, while the <code>&lt;=&gt;</code> is for an <em>inclusive</em> min-max check.</p>
<h4 id="format-91"><a class="header" href="#format-91">Format:</a></h4>
<h5 id="single-value-comparison-9"><a class="header" href="#single-value-comparison-9">Single value comparison:</a></h5>
<pre><code>cip_service:[<|>|=|!|<=|>=]<var style="color:slategrey;">service</var>;</code></pre>
<h5 id="range-comparison-9"><a class="header" href="#range-comparison-9">Range comparison:</a></h5>
<pre><code>cip_service:<var style="color:slategrey;">min_service</var>{<>|<=>}<var style="color:slategrey;">max_service</var>;</code></pre>
<blockquote>
<p>Note: The chosen <code><var style="color:slategrey;">service</var></code> values must be in the following range: <code>0:127</code>.</p>
</blockquote>
<h4 id="examples-91"><a class="header" href="#examples-91">Examples:</a></h4>
<pre><code class="language-snort">cip_service:10;
</code></pre>
<pre><code class="language-snort">cip_service:127;
</code></pre>
<h2 id="cip_status"><a class="header" href="#cip_status">cip_status</a></h2>
<p>The <code>cip_status</code> rule option is used to match a single CIP status value or multiple CIP status values.</p>
<p>This rule option takes in one argument, which is either a single status value used with an optional comparison operator sign, or a range of status values using one of two range operator signs. The range comparison is done by including either the <code>&lt;&gt;</code> or <code>&lt;=&gt;</code> sign and putting the minimum number the left of the sign and the maximum number to the right of it. The <code>&lt;&gt;</code> case is for an <em>exclusive</em> min-max check, while the <code>&lt;=&gt;</code> is for an <em>inclusive</em> min-max check.</p>
<h4 id="format-92"><a class="header" href="#format-92">Format:</a></h4>
<h5 id="single-value-comparison-10"><a class="header" href="#single-value-comparison-10">Single value comparison:</a></h5>
<pre><code>cip_status:[<|>|=|!|<=|>=]<var style="color:slategrey;">status</var>;</code></pre>
<h5 id="range-comparison-10"><a class="header" href="#range-comparison-10">Range comparison:</a></h5>
<pre><code>cip_status:<var style="color:slategrey;">min_status</var>{<>|<=>}<var style="color:slategrey;">max_status</var>;</code></pre>
<blockquote>
<p>Note: The chosen <code><var style="color:slategrey;">status</var></code> values must be in the following range: <code>0:255</code>.</p>
</blockquote>
<h4 id="examples-92"><a class="header" href="#examples-92">Examples:</a></h4>
<pre><code class="language-snort">cip_status:0;
</code></pre>
<pre><code class="language-snort">cip_status:!0;
</code></pre>
<h2 id="enip_command"><a class="header" href="#enip_command">enip_command</a></h2>
<p>The <code>enip_command</code> rule option is used to match a single ENIP command value or multiple ENIP command values.</p>
<p>This rule option takes in one argument, which is either a single ENIP command value used with an optional comparison operator sign, or a range of ENIP command values using one of two range operator signs. The range comparison is done by including either the <code>&lt;&gt;</code> or <code>&lt;=&gt;</code> sign and putting the minimum number the left of the sign and the maximum number to the right of it. The <code>&lt;&gt;</code> case is for an <em>exclusive</em> min-max check, while the <code>&lt;=&gt;</code> is for an <em>inclusive</em> min-max check.</p>
<h4 id="format-93"><a class="header" href="#format-93">Format:</a></h4>
<h5 id="single-value-comparison-11"><a class="header" href="#single-value-comparison-11">Single value comparison:</a></h5>
<pre><code>enip_command:[<|>|=|!|<=|>=]<var style="color:slategrey;">enip_command</var>;</code></pre>
<h5 id="range-comparison-11"><a class="header" href="#range-comparison-11">Range comparison:</a></h5>
<pre><code>enip_command:<var style="color:slategrey;">min_enip_command</var>{<>|<=>}<var style="color:slategrey;">max_enip_command</var>;</code></pre>
<blockquote>
<p>Note: The chosen <code><var style="color:slategrey;">command</var></code> values must be in the following range: <code>0:65535</code>.</p>
</blockquote>
<h4 id="examples-93"><a class="header" href="#examples-93">Examples:</a></h4>
<pre><code class="language-snort">enip_command:5&lt;&gt;100;
</code></pre>
<pre><code class="language-snort">enip_command:&lt;7;
</code></pre>
<h2 id="enip_req"><a class="header" href="#enip_req">enip_req</a></h2>
<p>The <code>enip_req</code> rule option is used to match ENIP response packets.</p>
<p>This rule option takes no arguments.</p>
<h4 id="format-94"><a class="header" href="#format-94">Format:</a></h4>
<pre><code>enip_req;
</code></pre>
<h4 id="examples-94"><a class="header" href="#examples-94">Examples:</a></h4>
<pre><code class="language-snort">enip_req;
</code></pre>
<h2 id="enip_rsp"><a class="header" href="#enip_rsp">enip_rsp</a></h2>
<p>The <code>enip_rsp</code> rule option is used to match ENIP response packets.</p>
<p>This rule option takes no arguments.</p>
<h4 id="format-95"><a class="header" href="#format-95">Format:</a></h4>
<pre><code>enip_rsp;
</code></pre>
<h4 id="examples-95"><a class="header" href="#examples-95">Examples:</a></h4>
<pre><code class="language-snort">enip_rsp;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="iec-104-specific-options"><a class="header" href="#iec-104-specific-options">IEC 104 Specific Options</a></h1>
<p>Snort 3 contains a service inspector for the IEC 60870-5-104 (IEC 104) protocol, a protocol that is distributed by the International Electrotechnical Commission (IEC) and provides a standardized method of sending telecontrol messages between central stations and outstations. Traffic using this protocol typically runs on TCP port 2404. </p>
<p>This inspector decodes IEC104 traffic and provides two rule options to let rule writers evaluate the (1) IEC104 APCI type and (2) IEC104 function code.</p>
<p>To be able to use the various <code>iec104</code> rule options, one must make sure to enable the inspector and add an approriate Binder entry in the Snort 3 config. For example:</p>
<pre><code class="language-lua">-- enable the IEC104 inspector
iec104 = { }
-- add the IEC104 binder entry
binder =
{
    { when = { proto = 'tcp', ports = '2404' }, use = { type = 'iec104' }, },
}
</code></pre>
<h2 id="iec104_apci_type"><a class="header" href="#iec104_apci_type">iec104_apci_type</a></h2>
<p>The <code>iec104_apci_type</code> rule option is used to verify that the message being processed is of the specified type. The argument passed to this rule option can be specified in one of three ways: the full type name, the lowercase type abbreviation, or the uppercase type abbreviation.</p>
<h4 id="format-96"><a class="header" href="#format-96">Format:</a></h4>
<pre><code>iec104_apci_type:{u|U|unnumbered_control_function|s|S|numbered_supervisory_function \
    |i|I|information_transfer_format};
</code></pre>
<h4 id="examples-96"><a class="header" href="#examples-96">Examples:</a></h4>
<pre><code class="language-snort">iec104_apci_type:unnumbered_control_function;
</code></pre>
<pre><code class="language-snort">iec104_apci_type:S;
</code></pre>
<pre><code class="language-snort">iec104_apci_type:i;
</code></pre>
<h2 id="iec104_asdu_func"><a class="header" href="#iec104_asdu_func">iec104_asdu_func</a></h2>
<p>The <code>iec104_asdu_func</code> rule option is used to verify that the message being processed is using the specified ASDU function. The argument passed to this rule option can be specified in one of two ways: the uppercase function name, or the lowercase function name.</p>
<p>A list of accepted function cames can be found in the Snort 3 code <a href="https://github.com/snort3/snort3/blob/master/src/service_inspectors/iec104/ips_iec104_asdu_func.cc#L50">here</a>.</p>
<h4 id="format-97"><a class="header" href="#format-97">Format:</a></h4>
<pre><code>iec104_asdu_func:<var style="color:slategrey;">function_name</var>;</code></pre>
<h4 id="examples-97"><a class="header" href="#examples-97">Examples:</a></h4>
<pre><code class="language-snort">iec104_asdu_func:M_SP_NA_1;
</code></pre>
<pre><code class="language-snort">iec104_asdu_func:m_ps_na_1;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mms-specific-options"><a class="header" href="#mms-specific-options">MMS Specific Options</a></h1>
<p>IEC 61850 is a family of protocols, including the Manufacturing Message Specification (MMS), distributed by the International Electrotechnical Commission (IEC). It provides a standardized method of sending service messages between various manufacturing and process control devices, typically running on TCP port 102.</p>
<p>This inspector decodes MMS traffic and provides two rule options: <code>mms_func</code> and <code>mms_data</code>.</p>
<p>To be able to use the various <code>mms</code> rule options, one must make sure to enable the inspector and add an approriate Binder entry in the Snort 3 config. For example:</p>
<pre><code class="language-lua">-- enable the mms wizard support
wizard = { curses = {'mms'}, }
-- enable the mms service inspector
mms = { }
-- add the mms binder entry
binder =
{
    { when = { service = 'mms' },              use = { type = 'mms' } },
    { use = { type = 'wizard' } }
}
</code></pre>
<h2 id="mms_func"><a class="header" href="#mms_func">mms_func</a></h2>
<p>The <code>mms_func</code> rule option takes a single argument, a service name or a service number, and compares it with the <code>Confirmed Service</code> field in the MMS request or response packet that's being analyzed. The argument passed to this rule option can be specified in one of two ways: either as the full service name, or as a number that corresponds to a particular service. The full list of service names and their associated numbers can be found in the Snort3 source code <a href="https://github.com/snort3/snort3/blob/master/src/service_inspectors/mms/ips_mms_func.cc">here</a>.</p>
<h4 id="format-98"><a class="header" href="#format-98">Format:</a></h4>
<pre><code>mms_func:{<var style="color:slategrey;">full_service_name</var>|<var style="color:slategrey;">service_number</var>};</code></pre>
<h4 id="examples-98"><a class="header" href="#examples-98">Examples:</a></h4>
<p>In this example the rule is using the <code>mms_func</code> rule option with a string argument containing the <code>Confirmed Service Request</code> service name on which to alert:</p>
<pre><code class="language-snort">mms_func:get_name_list;
</code></pre>
<p>The following example also uses the <code>mms_func</code> rule option to alert on a <code>GetNameList</code> message, but this time an integer argument containing the function number is used:</p>
<pre><code class="language-snort">mms_func:1;
</code></pre>
<h2 id="mms_data"><a class="header" href="#mms_data">mms_data</a></h2>
<p>The <code>mms_data</code> rule option is used to set the detection cursor to the start of MMS PDU, bypassing all of the OSI encapsulation layers and allowing subsequent rule options to start processing from the MMS PDU field.</p>
<h4 id="format-99"><a class="header" href="#format-99">Format:</a></h4>
<pre><code>mms_data;
</code></pre>
<h4 id="examples-99"><a class="header" href="#examples-99">Examples:</a></h4>
<p>In this example, the rule is using the <code>mms_data</code> rule option to set the cursor position to the beginning of the MMS PDU, and then checking the byte at that position for the value indicative of an <code>Initiate-Request</code> message:</p>
<pre><code class="language-snort">mms_data;
content:&quot;|A8|&quot;, depth 1;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="modbus-specific-options"><a class="header" href="#modbus-specific-options">Modbus Specific Options</a></h1>
<p>Modbus is a protocol used in SCADA networks, and its traffic is typically seen on TCP port 502 (aka Modbus TCP). The Modbus service inspector decodes the Modbus protocol and provides three rule options that rule writers can use to evaluate Modbus traffic.</p>
<p>Those three options are <code>modbus_data</code>, <code>modbus_func</code>, and <code>modbus_unit</code>.</p>
<p>To be able to use the various <code>modbus</code> rule options, one must make sure to enable the inspector and add an approriate Binder entry in the Snort 3 config. For example:</p>
<pre><code class="language-lua">-- enable the Modbus service inspector
modbus = {}
-- add the Modbus binder entry
binder =
{
    { when = { proto = 'tcp', ports = '502' }, use = { type = 'modbus' }, },
}
</code></pre>
<h2 id="modbus_data"><a class="header" href="#modbus_data">modbus_data</a></h2>
<p>The <code>modbus_data</code> rule option is used to set the detection cursor to the start of Modbus data.</p>
<h4 id="format-100"><a class="header" href="#format-100">Format:</a></h4>
<pre><code>modbus_data;
</code></pre>
<h4 id="examples-100"><a class="header" href="#examples-100">Examples:</a></h4>
<pre><code class="language-snort">modbus_data;
content:&quot;modbus stuff&quot;; 
</code></pre>
<h2 id="modbus_func"><a class="header" href="#modbus_func">modbus_func</a></h2>
<p>The <code>modbus_func</code> rule option is used to check for a particular Modbus function code or function name.</p>
<p>Rule writers can provide either the function code—an integer value—or the function's string name. The list of valid function strings can be found in the Snort 3 source code <a href="https://github.com/snort3/snort3/blob/master/src/service_inspectors/modbus/ips_modbus_func.cc">here</a>. If providing the function name as the argument, one <em>should not</em> enclose the string in double quotes.</p>
<h4 id="format-101"><a class="header" href="#format-101">Format:</a></h4>
<pre><code>modbus_func:{<var style="color:slategrey;">function_name</var>|<var style="color:slategrey;">function_code</var>};</code></pre>
<h4 id="examples-101"><a class="header" href="#examples-101">Examples:</a></h4>
<pre><code class="language-snort">modbus_func:5;
</code></pre>
<pre><code class="language-snort">modbus_func:write_single_coil;
</code></pre>
<h2 id="modbus_unit"><a class="header" href="#modbus_unit">modbus_unit</a></h2>
<p>The <code>modbus_unit</code> rule option is used to check for a particular Modbus unit identifier.</p>
<p>This rule option takes in a single argument, an integer in the following range: <code>0-255</code>.</p>
<h4 id="format-102"><a class="header" href="#format-102">Format:</a></h4>
<pre><code>modbus_unit:<var style="color:slategrey;">modbus_unit_id</var>;</code></pre>
<h4 id="examples-102"><a class="header" href="#examples-102">Examples:</a></h4>
<pre><code class="language-snort">modbus_unit:0;
</code></pre>
<pre><code class="language-snort">modbus_unit:73;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="s7commplus-specific-options"><a class="header" href="#s7commplus-specific-options">S7CommPlus Specific Options</a></h1>
<p>S7 Communication (S7Comm) and S7CommPlus are Siemens protocols that run between programmable logic controllers (PLCs) of the Siemens S7-300/400 and S7-1500/1200(v4.0) families. Traffic of this service typically runs on TCP port 102.</p>
<p>S7Comm and S7CommPlus data is sent in the payload of Connection Oriented Transport Protocol (COTP) data packets. Snort 3 features a S7CommPlus service inspector that provides three rule options: <code>s7commplus_content</code>, <code>s7commplus_func</code>, and <code>s7commplus_opcode</code>.</p>
<p>To be able to use the various <code>s7commplus</code> rule options, one must make sure to enable the inspector and add an approriate Binder entry in the Snort 3 config. For example:</p>
<pre><code class="language-lua">-- enable the s7commplus wizard support
wizard = { curses = {'s7commplus'}, }
-- enable the s7commplus service inspector
s7commplus = { }
-- add the s7commplus binder entry
binder =
{
    { when = { service = 's7commplus' },       use = { type = 's7commplus' } },
    { use = { type = 'wizard' } }
}
</code></pre>
<h2 id="s7commplus_content"><a class="header" href="#s7commplus_content">s7commplus_content</a></h2>
<p>The <code>s7commplus_content</code> rule option is used to set the detection cursor to the start of S7CommPlus content.</p>
<h4 id="format-103"><a class="header" href="#format-103">Format:</a></h4>
<pre><code>s7commplus_content;
</code></pre>
<h4 id="examples-103"><a class="header" href="#examples-103">Examples:</a></h4>
<pre><code class="language-snort">s7commplus_content;
content:&quot;|01 02 03 04|&quot;; 
</code></pre>
<h2 id="s7commplus_func"><a class="header" href="#s7commplus_func">s7commplus_func</a></h2>
<p>The <code>s7commplus_func</code> rule option is used to check for a particular S7CommPlus function code.</p>
<p>This option takes in a single argument, either the name of a function code or the integer value of a function code. The currently supported function names and codes can be found in the Snort 3 source code <a href="https://github.com/snort3/snort3/blob/master/src/service_inspectors/s7commplus/ips_s7comm_func.cc">here</a>.</p>
<h4 id="format-104"><a class="header" href="#format-104">Format:</a></h4>
<pre><code>s7commplus_func:{<var style="color:slategrey;">function_code_name</var>|<var style="color:slategrey;">function_code_number</var>};</code></pre>
<h4 id="examples-104"><a class="header" href="#examples-104">Examples:</a></h4>
<pre><code class="language-snort">s7commplus_func:explore;
</code></pre>
<pre><code class="language-snort">s7commplus_func:0x586;
</code></pre>
<h2 id="s7commplus_opcode"><a class="header" href="#s7commplus_opcode">s7commplus_opcode</a></h2>
<p>The <code>s7commplus_opcode</code> rule option is used to check for a particular S7CommPlus opcode code. </p>
<p>This option takes in a single argument, either the name of the opcode code or an integer value of the opcode code. The currently supported opcode names and codes can be found in the Snort 3 source code <a href="https://github.com/snort3/snort3/blob/master/src/service_inspectors/s7commplus/ips_s7comm_opcode.cc">here</a>.</p>
<h4 id="format-105"><a class="header" href="#format-105">Format:</a></h4>
<pre><code>s7commplus_opcode:{<var style="color:slategrey;">opcode_code_name</var>|<var style="color:slategrey;">opcode_code_number</var>};</code></pre>
<h4 id="examples-105"><a class="header" href="#examples-105">Examples:</a></h4>
<pre><code class="language-snort">s7commplus_opcode:request;
</code></pre>
<pre><code class="language-snort">s7commplus_opcode:0x31;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="non-payload-detection-rule-options"><a class="header" href="#non-payload-detection-rule-options">Non-Payload Detection Rule Options</a></h1>
<p>The non-payload rule options look for non-payload-related data. All of these options are described in detail in subsequent sections, but essentially, these options enable users to evaluate parts of a packet other than the TCP and UDP data sections, as well as keep track of packet states for future evaluation. </p>
<h4 id="quick-reference-2"><a class="header" href="#quick-reference-2">Quick Reference</a></h4>
<table><thead><tr><th>keyword</th><th>description</th></tr></thead><tbody>
<tr><td><a href="rules/options/non_payload/fragoffset.htm">fragoffset</a></td><td><code>fragoffset</code> looks for specific IP header fragment offset values</td></tr>
<tr><td><a href="rules/options/non_payload/ttl.htm">ttl</a></td><td><code>ttl</code> looks for specific IP header TTL values</td></tr>
<tr><td><a href="rules/options/non_payload/tos.htm">tos</a></td><td><code>tos</code> looks for specific IP header ToS values</td></tr>
<tr><td><a href="rules/options/non_payload/id.htm">id</a></td><td><code>id</code> looks for specific IP header ID values</td></tr>
<tr><td><a href="rules/options/non_payload/ipopts.htm">ipopts</a></td><td><code>ipopts</code> looks for the prescence of specific IP options</td></tr>
<tr><td><a href="rules/options/non_payload/fragbits.htm">fragbits</a></td><td><code>fragbits</code> checks the IP header for fragmentation or reserved bits</td></tr>
<tr><td><a href="rules/options/non_payload/ip_proto.htm">ip_proto</a></td><td><code>ip_proto</code> looks for specific IP header protocol fields</td></tr>
<tr><td><a href="rules/options/non_payload/flags.htm">flags</a></td><td><code>flags</code> checks the TCP header for specific TCP flag bits</td></tr>
<tr><td><a href="rules/options/non_payload/flow.htm">flow</a></td><td><code>flow</code> checks the session properties associated with given packet</td></tr>
<tr><td><a href="rules/options/non_payload/flowbits.htm">flowbits</a></td><td><code>flowbits</code> is used to set and test arbitrary boolean flags to track states during a transport protocol session</td></tr>
<tr><td><a href="rules/options/non_payload/file_type.htm">file_type</a></td><td><code>file_type</code> is used to create rules that are constrained to a specific file type, a specific version of a file type</td></tr>
<tr><td><a href="rules/options/non_payload/seq.htm">seq</a></td><td><code>seq</code> looks for specific TCP header sequence numbers</td></tr>
<tr><td><a href="rules/options/non_payload/ack.htm">ack</a></td><td><code>ack</code> looks for specific TCP header acknowledgment numbers</td></tr>
<tr><td><a href="rules/options/non_payload/window.htm">window</a></td><td><code>window</code> looks for specific TCP header window sizes</td></tr>
<tr><td><a href="rules/options/non_payload/itype.htm">itype</a></td><td><code>itype</code> looks for specific ICMP type values</td></tr>
<tr><td><a href="rules/options/non_payload/icode.htm">icode</a></td><td><code>icode</code> looks for specific ICMP code values</td></tr>
<tr><td><a href="rules/options/non_payload/icmp_id.htm">icmp_id</a></td><td><code>icmp_id</code> looks for specific ICMP ID values</td></tr>
<tr><td><a href="rules/options/non_payload/icmp_seq.htm">icmp_seq</a></td><td><code>icmp_seq</code> looks for specific ICMP sequence values</td></tr>
<tr><td><a href="rules/options/non_payload/rpc.htm">rpc</a></td><td><code>rpc</code> looks for specific SUNRPC CALL request parameters</td></tr>
<tr><td><a href="rules/options/non_payload/stream_reassemble.htm">stream_reassemble</a></td><td><code>stream_reassemble</code> is used to enable or disable TCP stream reassembly on matching traffic</td></tr>
<tr><td><a href="rules/options/non_payload/stream_size.htm">stream_size</a></td><td><code>stream_size</code> is used to perform stream size checking</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="fragoffset"><a class="header" href="#fragoffset">fragoffset</a></h1>
<p>The <code>fragoffset</code> rule option is used to check that the IP fragment offset value in the IP header is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also check that the header's fragment's offset value is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<h4 id="format-106"><a class="header" href="#format-106">Format:</a></h4>
<h5 id="single-value-comparison-12"><a class="header" href="#single-value-comparison-12">Single value comparison:</a></h5>
<pre><code>fragoffset:[<|>|=|!|<=|>=]<var style="color:slategrey;">fragoffset</var>;</code></pre>
<h5 id="range-comparison-12"><a class="header" href="#range-comparison-12">Range comparison:</a></h5>
<pre><code>fragoffset:<var style="color:slategrey;">fragoffset_min</var>{<>|<=>}<var style="color:slategrey;">fragoffset_max</var>;</code></pre>
<h4 id="examples-106"><a class="header" href="#examples-106">Examples:</a></h4>
<pre><code class="language-snort"># Check that the fragoffset equals 0
fragoffset:0;
</code></pre>
<pre><code class="language-snort"># Check that the fragoffset does not equal 0
fragoffset:!0;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ttl"><a class="header" href="#ttl">ttl</a></h1>
<p>The <code>ttl</code> rule option is used to check that the IP time-to-live (TTL) value in the IP header is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also check that the header's TTL value is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<h4 id="format-107"><a class="header" href="#format-107">Format:</a></h4>
<h5 id="single-value-comparision"><a class="header" href="#single-value-comparision">Single value comparision:</a></h5>
<pre><code>ttl:[<|>|=|!|<=|>=]<var style="color:slategrey;">ttl</var>;</code></pre>
<h5 id="range-comparison-13"><a class="header" href="#range-comparison-13">Range comparison:</a></h5>
<pre><code>ttl:<var style="color:slategrey;">ttl_min</var>{<>|<=>}<var style="color:slategrey;">ttl_max</var>;</code></pre>
<h4 id="examples-107"><a class="header" href="#examples-107">Examples:</a></h4>
<pre><code class="language-snort"># Check that the TTL equals 64
ttl:64;
</code></pre>
<pre><code class="language-snort"># Check that the TTL does not equal 64
ttl:!64;
</code></pre>
<pre><code class="language-snort"># Check that the TTL is less than 3 
ttl:&lt;3;
</code></pre>
<pre><code class="language-snort"># Check that the TTL is between 3 and 5 (inclusive)
ttl:3&lt;=&gt;5;
</code></pre>
<pre><code class="language-snort"># Check that the TTL is equal to 5
ttl:=5;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tos"><a class="header" href="#tos">tos</a></h1>
<p>The <code>tos</code> rule option is used to check an IP header's type of service (ToS) value is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also check that the header's ToS value is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<p>This option is useful to detect things like the &quot;bubonic&quot; DoS tool.</p>
<h4 id="format-108"><a class="header" href="#format-108">Format:</a></h4>
<h5 id="single-value-comparison-13"><a class="header" href="#single-value-comparison-13">Single value comparison:</a></h5>
<pre><code>tos:[<|>|=|!|<=|>=]<var style="color:slategrey;">tos</var>;</code></pre>
<h5 id="range-comparison-14"><a class="header" href="#range-comparison-14">Range comparison:</a></h5>
<pre><code>tos:<var style="color:slategrey;">tos_min</var>{<>|<=>}<var style="color:slategrey;">tos_max</var>;</code></pre>
<h4 id="examples-108"><a class="header" href="#examples-108">Examples:</a></h4>
<pre><code class="language-snort"># Check that the ToS value does not equal 4
tos:!4;
</code></pre>
<pre><code class="language-snort"># Check that the ToS value equals 4
tos:4;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="id"><a class="header" href="#id">id</a></h1>
<p>The <code>id</code> rule option is used to check an IP header's identification (ID) field value is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also check that the header's ID value is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> range operator for an inclusive one.</p>
<h4 id="format-109"><a class="header" href="#format-109">Format:</a></h4>
<h5 id="single-value-comparison-14"><a class="header" href="#single-value-comparison-14">Single value comparison</a></h5>
<pre><code>id:[<|>|=|!|<=|>=]<var style="color:slategrey;">id</var>;</code></pre>
<h5 id="range-comparison-15"><a class="header" href="#range-comparison-15">Range comparison</a></h5>
<pre><code>id:<var style="color:slategrey;">id_min</var>{<>|<=>}<var style="color:slategrey;">id_max</var>;</code></pre>
<h4 id="examples-109"><a class="header" href="#examples-109">Examples:</a></h4>
<pre><code class="language-snort"># Check for an ID value that equals 31337
id:31337;
</code></pre>
<pre><code class="language-snort"># Check for an ID value that is greater than 31337
id:&gt;31337;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ipopts"><a class="header" href="#ipopts">ipopts</a></h1>
<p>The <code>ipopts</code> rule option is used to check if a specified IP option is present in an IP header. </p>
<p>There are 11 possible <code>ipopts</code> arguments to choose from, and an <code>ipopts</code> option can only have one argument. These options include the following:</p>
<ul>
<li><code>rr</code>: Record Route</li>
<li><code>eol</code>: End of Options List</li>
<li><code>nop</code>: No Operation</li>
<li><code>ts</code>: Time Stamp</li>
<li><code>sec</code>: Security</li>
<li><code>esec</code>: Extended Security</li>
<li><code>lsrr</code>: Loose Source Routing </li>
<li><code>lsrre</code>: Loose Source Routing (For MS99-038 and CVE-1999-0909)</li>
<li><code>ssrr</code>: Strict Source Route</li>
<li><code>satid</code>: Stream ID</li>
<li><code>any</code>: Any IP options are set</li>
</ul>
<h4 id="format-110"><a class="header" href="#format-110">Format:</a></h4>
<pre><code>ipopts:{rr|eol|nop|ts|sec|esec|lsrr|lsrre|ssrr|satid|any};
</code></pre>
<h4 id="examples-110"><a class="header" href="#examples-110">Examples:</a></h4>
<pre><code class="language-snort"># Match packets with IP headers containing the 
# Record Route option
ipopts:rr;
</code></pre>
<pre><code class="language-snort"># Match packets with IP headers containing any option 
ipopts:any;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="fragbits"><a class="header" href="#fragbits">fragbits</a></h1>
<p>The <code>fragbits</code> option checks the IP header to see if specific fragmentation and reserved bits are set or not.</p>
<p>Rule writers can check for the following bits:</p>
<ul>
<li><code>M</code> -&gt; More Fragments</li>
<li><code>D</code> -&gt; Don't Fragment</li>
<li><code>R</code> -&gt; Reserved Bit</li>
</ul>
<p>Additionally, rule options can include one of the following optional modifiers to change how the criteria is evaluated: </p>
<ul>
<li><code>+</code> -&gt; Match on the specified bits, plus any others</li>
<li><code>*</code> -&gt; Match if any of the specified bits are set</li>
<li><code>!</code> -&gt; Match if the specified bits are not set</li>
</ul>
<h4 id="format-111"><a class="header" href="#format-111">Format:</a></h4>
<pre><code>fragbits:[<var style="color:slategrey;">modifier</var>]<var style="color:slategrey;">fragbit</var>…;</code></pre>
<h4 id="examples-111"><a class="header" href="#examples-111">Examples:</a></h4>
<pre><code class="language-snort">## Checks if only the More Fragments bit is set 
fragbits:M;
</code></pre>
<pre><code class="language-snort"># Checks if the More Fragments bit and the 
# Do not Fragment bit are set, plus any others
fragbits:+MD;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ip_proto"><a class="header" href="#ip_proto">ip_proto</a></h1>
<p>The <code>ip_proto</code> rule option is used to check the IP header protocol field against an IP protocol number or name. Valid protocol numbers and names can be found on the IANA's &quot;Protocol Numbers&quot; page here: <a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml</a>.</p>
<p>Rule writers can also use the <code>!</code>, <code>&lt;</code>, or <code>&gt;</code> operators to check for IP header protocol numbers that are not equal to, less than, or greater than the specified protocol number or protocol name's corresponding number.</p>
<h4 id="format-112"><a class="header" href="#format-112">Format:</a></h4>
<pre><code>ip_proto:[!|>|<]{<var style="color:slategrey;">proto_number</var>|<var style="color:slategrey;">proto_name</var>};</code></pre>
<h4 id="examples-112"><a class="header" href="#examples-112">Examples:</a></h4>
<pre><code class="language-snort"># Check that the IP protocol field equals IGMP
ip_proto:igmp;
</code></pre>
<pre><code class="language-snort"># Check that the IP protocol field does not equal TCP 
ip_proto:!tcp;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="flags"><a class="header" href="#flags">flags</a></h1>
<p>The <code>flags</code> rule option checks to see if the specified flag bits are set in the TCP header.</p>
<p>The following flag bits may be checked:</p>
<ul>
<li><code>F</code> -&gt; FIN (Finish)</li>
<li><code>S</code> -&gt; SYN (Synchronize sequence numbers)</li>
<li><code>R</code> -&gt; RST (Reset the connection)</li>
<li><code>P</code> -&gt; PSH (Push buffered data)</li>
<li><code>A</code> -&gt; ACK (Acknowledgement)</li>
<li><code>U</code> -&gt; URG (Urgent pointer)</li>
<li><code>C</code> -&gt; CWR (Congestion window reduced)</li>
<li><code>E</code> -&gt; ECE (ECN-Echo)</li>
<li><code>0</code> -&gt; No TCP flags set</li>
</ul>
<p>One can look for multiple flags at once by specifying more than one flag character. Doing this tells Snort to look for <em>all</em> of the flags specified in the option.</p>
<p>Additionally, rule options can also include one of the following optional modifiers to change how the criteria is evaluated:</p>
<ul>
<li><code>+</code> -&gt; match any of the specified bits, plus any others</li>
<li><code>*</code> -&gt; match if any of the specified bits are set</li>
<li><code>!</code> -&gt; match if the specified bits are not set</li>
</ul>
<p>Rule writers can also specify flags to <em>ignore</em> by placing a comma after the initial set of flags followed by a flag character or flag characters to ignore. </p>
<h4 id="format-113"><a class="header" href="#format-113">Format:</a></h4>
<pre><code>flags:[<var style="color:slategrey;">modifier</var>]<var style="color:slategrey;">test_flag</var>…[,<var style="color:slategrey;">mask_flag</var>…];</code></pre>
<h4 id="examples-113"><a class="header" href="#examples-113">Examples:</a></h4>
<pre><code class="language-snort"># Check for TCP packets where only the SYN flag is set 
flags:S;
</code></pre>
<pre><code class="language-snort"># Check for TCP packets where only the SYN and ACK flags is set 
flags:SA;
</code></pre>
<pre><code class="language-snort"># Check for TCP packets where the SYN and/or ACK flags are set 
flags:*SA;
</code></pre>
<pre><code class="language-snort"># Check if the SYN and FIN bits are set, ignoring the CWR and ECN bits
flags:SF,CE;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="flow"><a class="header" href="#flow">flow</a></h1>
<p>The <code>flow</code> option is used to check session properties of a given packet. There are four main property categories that one can check with this option:</p>
<ul>
<li>The direction of the packet, specifically whether it's from a client to a server or from a server to a client</li>
<li>Whether the packet is part of an established TCP connection or not</li>
<li>Whether the packet is a reassembled packet or not</li>
<li>Whether the packet is a rebuilt frag packet or not</li>
</ul>
<p>Each of these property categories has a few different arguments that can be specified in a <code>flow</code> option, but only one property from each &quot;category&quot; can be included in a single option. All possible arguments are listed and described in the below table, and specifying multiple properties is done by adding commas in between them. The order is not important.</p>
<table><thead><tr><th>Argument</th><th>Description</th></tr></thead><tbody>
<tr><td><code>to_client</code></td><td>Match on server responses</td></tr>
<tr><td><code>to_server</code></td><td>Match on client requests</td></tr>
<tr><td><code>from_client</code></td><td>Match on client requests</td></tr>
<tr><td><code>from_server</code></td><td>Match on server responses</td></tr>
<tr><td><code>established</code></td><td>Match only on established TCP connections</td></tr>
<tr><td><code>not_established</code></td><td>Match only when no TCP connection is established</td></tr>
<tr><td><code>stateless</code></td><td>Match regardless of stream state</td></tr>
<tr><td><code>no_stream</code></td><td>Match only on non-reassembled packets</td></tr>
<tr><td><code>only_stream</code></td><td>Match only on reassembled packets</td></tr>
<tr><td><code>no_frag</code></td><td>Match only on fragmented packets</td></tr>
<tr><td><code>only_frag</code></td><td>Match only on de-fragmented packets</td></tr>
</tbody></table>
<h4 id="format-114"><a class="header" href="#format-114">Format:</a></h4>
<pre><code>flow:[{established|not_established|stateless}] \
     [,{to_client|to_server|from_client|from_server}] \
     [,{no_stream|only_stream}] \
     [,{no_frag|only_frag}]; 
</code></pre>
<h4 id="examples-114"><a class="header" href="#examples-114">Examples:</a></h4>
<pre><code class="language-snort">flow:to_server,established;
</code></pre>
<pre><code class="language-snort">flow:to_client,established;
</code></pre>
<pre><code class="language-snort">flow:stateless;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="flowbits"><a class="header" href="#flowbits">flowbits</a></h1>
<p>The <code>flowbits</code> rule option is used to set and test arbitrary boolean flags to track states throughout the entirety of a transport protocol session (UDP or TCP).</p>
<p>There are five <code>flowbit</code> operations, all of which are listed below, that rule writers can use to track states. These are described in the following table:</p>
<table><thead><tr><th>Argument</th><th>Description</th></tr></thead><tbody>
<tr><td><code>set</code></td><td>Sets the specified states for the current flow</td></tr>
<tr><td><code>unset</code></td><td>Unsets the specified states for the current flow</td></tr>
<tr><td><code>isset</code></td><td>Checks if the specified states are set</td></tr>
<tr><td><code>isnotset</code></td><td>Checks if the specified states are not set</td></tr>
<tr><td><code>noalert</code></td><td>Cause the rule to not generate an alert, regardless of the rest of the detection options</td></tr>
</tbody></table>
<h2 id="setting-and-checking-flowbits"><a class="header" href="#setting-and-checking-flowbits">Setting and checking flowbits</a></h2>
<p>The first four operations, <code>set</code>, <code>unset</code>, <code>isset</code>, and <code>isnotset</code>, are used to track states throughout a transport protocol session. These four operations require an additional argument, the flowbit flag <em>name</em>, which is the name of the flag to be associated with that particular state. </p>
<p>Tracking states is done properly by creating at least two rules: (1) a &quot;flowbit setter&quot; rule that tells Snort to set a flag if the other conditions in it are met and (2) a &quot;flowbit checker&quot; rule to check whether that particular flag has been set or not set previously in the current transport protocol session, using that as one of its conditions. Rule writers can also &quot;unset&quot; a flag if there's something in a particular packet to warrant such a thing.</p>
<p>Lastly, rule writers can also set and evaluate <em>multiple</em> bits at once using the <code>&amp;</code> and <code>|</code> operators. However, if setting or unsetting multiple flowbit flags with one <code>flowbit</code> option, one must use <code>&amp;</code>.</p>
<h4 id="format-115"><a class="header" href="#format-115">Format:</a></h4>
<h5 id="setting-or-unsetting-bits"><a class="header" href="#setting-or-unsetting-bits">Setting or unsetting bits</a></h5>
<pre><code>flowbits:{set|unset},<var style="color:slategrey;">bit</var>[&<var style="color:slategrey;">bit</var>]…;</code></pre>
<h5 id="checking-if-any-bit-is-set"><a class="header" href="#checking-if-any-bit-is-set">Checking if any bit is set</a></h5>
<pre><code>flowbits:{isset|isnotset},<var style="color:slategrey;">bit</var>[|<var style="color:slategrey;">bit</var>]…;</code></pre>
<h5 id="checking-if-all-bits-are-set"><a class="header" href="#checking-if-all-bits-are-set">Checking if all bits are set</a></h5>
<pre><code>flowbits:{isset|isnotset},<var style="color:slategrey;">bit</var>[&<var style="color:slategrey;">bit</var>]…;</code></pre>
<blockquote>
<p><strong>Note</strong>: The names of the flowbit names should be limited to alphanumeric strings and can include periods, dashes, or underscores.</p>
</blockquote>
<h4 id="examples-115"><a class="header" href="#examples-115">Examples:</a></h4>
<pre><code class="language-snort"># this example sets a &quot;logged_in&quot; flag that is used to denote
# that an IMAP login has occurred 
alert tcp any 143 -&gt; any any (
    msg:&quot;IMAP login&quot;; 
    content:&quot;OK LOGIN&quot;; 
    flowbits:set,logged_in; 
    flowbits:noalert;
)
      
# this rule then will only &quot;alert&quot; if &quot;LIST&quot; is found in a packet AND
# the &quot;logged_in&quot; flag has been set previously during the 
# current transport protocol session
alert tcp any any -&gt; any 143 (
    msg:&quot;IMAP LIST&quot;; 
    content:&quot;LIST&quot;; 
    flowbits:isset,logged_in;
)
</code></pre>
<pre><code class="language-snort"># check that flag1 AND flag2 have been set previously in the 
# current transport protocol session
flowbits:isset,flag1&amp;flag2;
</code></pre>
<pre><code class="language-snort"># check that flag1 OR flag2 have been set previously in the 
# current transport protocol session
flowbits:isset,flag1|flag2;
</code></pre>
<pre><code class="language-snort"># set the flowbits, flag1 AND flag2, for the current transport
# protocol session
flowbits:set,flag1&amp;flag2;
</code></pre>
<pre><code class="language-snort"># unset the flowbits, flag1 AND flag2, for the current transport
# protocol session
flowbits:unset,flag1&amp;flag2;
</code></pre>
<h2 id="the-noalert-flowbit"><a class="header" href="#the-noalert-flowbit">The noalert flowbit</a></h2>
<p>The last flowbit operation is <code>noalert</code>. Invoking this operation simply tells Snort not to generate an alert for that particular rule. There is not bit name required for this one.</p>
<p>This operation is most commonly used in flowbit setter rules since those are usually just a precursor to what one actually wants to detect.</p>
<h4 id="format-116"><a class="header" href="#format-116">Format:</a></h4>
<pre><code>flowbits:noalert;
</code></pre>
<h4 id="examples-116"><a class="header" href="#examples-116">Examples:</a></h4>
<pre><code class="language-snort">flowbits:noalert;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="file_type"><a class="header" href="#file_type">file_type</a></h1>
<p>The <code>file_type</code> rule option is used write rules that are constrained to a given file type, a specific version of a file type, several different file types, or several file types of varying versions. </p>
<p>Rule writers can use this option by specifying either a single file type name, a file type name and a specific version, or multiple file type names with optional version numbers. File type version numbers are specified with a comma followed by the specific version number to look for, and multiple type names are then separated by a single space character. </p>
<p>The entire <code>file_type</code> argument should be wrapped in double quotes if specifying a version as well.</p>
<h4 id="use-of-file-identification-rules"><a class="header" href="#use-of-file-identification-rules">Use of file identification rules</a></h4>
<p>It's important to note that successful use of <code>file_type</code> requires the prescence of &quot;file identification rules&quot; that leverage the Snort rule engine to define the matches that indicate a particular file type is present in the traffic currently being inspected. Open source Snort 3 includes definitions for the most common file types, such as EXE, PDF, and Office files, and those are located in <a href="https://github.com/snort3/snort3/blob/master/lua/file_magic.rules">file_magic.rules</a>. </p>
<p>These identification rules are created as <code>file_id</code> rules, and more info about them and their syntax can be found in the <a href="rules/headers/file_id_rules.htm">file_id manual page</a>.</p>
<h4 id="format-117"><a class="header" href="#format-117">Format:</a></h4>
<pre><code>file_type:"<var style="color:slategrey;">type_name</var>[,<var style="color:slategrey;">type_version</var>]…[ <var style="color:slategrey;">type_name</var>[,<var style="color:slategrey;">type_version</var>]…]…";</code></pre>
<blockquote>
<p><strong>Note</strong>: This is one of the few rule options where whitespace <em>does</em> matter.</p>
</blockquote>
<h4 id="examples-117"><a class="header" href="#examples-117">Examples:</a></h4>
<pre><code class="language-snort"># look for PDF files
file_type:&quot;PDF&quot;;
</code></pre>
<pre><code class="language-snort"># look for version 1.6 PDF files
file_type:&quot;PDF,1.6&quot;;
</code></pre>
<pre><code class="language-snort"># look for version 1.6 or version 1.7 PDF files
file_type:&quot;PDF,1.6,1.7&quot;;
</code></pre>
<pre><code class="language-snort"># look for MSEXE, MSCAB, or MSOLE files
file_type:&quot;MSEXE MSCAB MSOLE2&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="seq"><a class="header" href="#seq">seq</a></h1>
<p>The <code>seq</code> rule option is used to check that the TCP header sequence number is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also check that the sequence number is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<h4 id="format-118"><a class="header" href="#format-118">Format:</a></h4>
<h5 id="single-value-comparison-15"><a class="header" href="#single-value-comparison-15">Single value comparison:</a></h5>
<pre><code>seq:[<|>|=|!|<=|>=]<var style="color:slategrey;">seq</var>;</code></pre>
<h5 id="range-comparison-16"><a class="header" href="#range-comparison-16">Range comparison:</a></h5>
<pre><code>seq:<var style="color:slategrey;">seq_min</var>{<>|<=>}<var style="color:slategrey;">seq_max</var>;</code></pre>
<h4 id="examples-118"><a class="header" href="#examples-118">Examples:</a></h4>
<pre><code class="language-snort"># Look for a sequence number of 0
seq:0;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ack"><a class="header" href="#ack">ack</a></h1>
<p>The <code>ack</code> rule option is used to check that the TCP header acknowledgment number is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also check that the acknowlegment number is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<h4 id="format-119"><a class="header" href="#format-119">Format:</a></h4>
<h5 id="single-value-comparison-16"><a class="header" href="#single-value-comparison-16">Single value comparison:</a></h5>
<pre><code>ack:[<|>|=|!|<=|>=]<var style="color:slategrey;">ack</var>;</code></pre>
<h5 id="range-comparison-17"><a class="header" href="#range-comparison-17">Range comparison:</a></h5>
<pre><code>ack:<var style="color:slategrey;">ack_min</var>{<>|<=>}<var style="color:slategrey;">ack_max</var>;</code></pre>
<h4 id="examples-119"><a class="header" href="#examples-119">Examples:</a></h4>
<pre><code class="language-snort"># Look for an acknowledgment number of 0
ack:0;
</code></pre>
<pre><code class="language-snort"># Look for an acknowledgment number between
# 0 and 1000 (inclusive)
ack:0&lt;=&gt;1000;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="window"><a class="header" href="#window">window</a></h1>
<p>The <code>window</code> rule option is used to check that the TCP header window number is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also check that the window number is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<h4 id="format-120"><a class="header" href="#format-120">Format:</a></h4>
<h5 id="single-value-comparison-17"><a class="header" href="#single-value-comparison-17">Single value comparison:</a></h5>
<pre><code>window:[<|>|=|!|<=|>=]<var style="color:slategrey;">window</var>;</code></pre>
<h5 id="range-comparison-18"><a class="header" href="#range-comparison-18">Range comparison:</a></h5>
<pre><code>window:<var style="color:slategrey;">window_min</var>{<>|<=>}<var style="color:slategrey;">window_max</var>;</code></pre>
<h4 id="examples-120"><a class="header" href="#examples-120">Examples:</a></h4>
<pre><code class="language-snort"># Check for a Window size that equals 55808
window:55808;
</code></pre>
<pre><code class="language-snort"># Check for a Window size that is between 0 and 55808 (exclusive)
window:0&lt;&gt;55808;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="itype"><a class="header" href="#itype">itype</a></h1>
<p>The <code>itype</code> rule option is used to check that a packet's ICMP type is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also check that an ICMP type is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<h4 id="format-121"><a class="header" href="#format-121">Format:</a></h4>
<h5 id="single-value-comparison-18"><a class="header" href="#single-value-comparison-18">Single value comparison:</a></h5>
<pre><code>itype:[<|>|=|!|<=|>=]<var style="color:slategrey;">itype</var>;</code></pre>
<h5 id="range-comparison-19"><a class="header" href="#range-comparison-19">Range comparison:</a></h5>
<pre><code>itype:<var style="color:slategrey;">itype_min</var>{<>|<=>}<var style="color:slategrey;">itype_max</var>;</code></pre>
<h4 id="examples-121"><a class="header" href="#examples-121">Examples:</a></h4>
<pre><code class="language-snort"># Check for an ICMP type greater than 30
itype:&gt;30;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="icode"><a class="header" href="#icode">icode</a></h1>
<p>The <code>icode</code> rule option is used to check that an ICMP code value is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also check that ICMP code value is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<h4 id="format-122"><a class="header" href="#format-122">Format:</a></h4>
<h5 id="single-value-comparison-19"><a class="header" href="#single-value-comparison-19">Single value comparison:</a></h5>
<pre><code>icode:[<|>|=|!|<=|>=]<var style="color:slategrey;">icode</var>;</code></pre> 
<h5 id="range-comparison-20"><a class="header" href="#range-comparison-20">Range comparison:</a></h5>
<pre><code>icode:<var style="color:slategrey;">icode_min</var>{<>|<=>}<var style="color:slategrey;">icode_max</var>;</code></pre>
<h4 id="examples-122"><a class="header" href="#examples-122">Examples:</a></h4>
<pre><code class="language-snort"># Check for an ICMP code value greater than 30 
icode:&gt;30;
</code></pre>
<pre><code class="language-snort"># Check for an ICMP code greater than or equal to zero and less than 30
icode:0&lt;=&gt;30;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="icmp_id"><a class="header" href="#icmp_id">icmp_id</a></h1>
<p>The <code>icmp_id</code> rule option is used to check that an ICMP ID value is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also check that ICMP ID value is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<h4 id="format-123"><a class="header" href="#format-123">Format:</a></h4>
<h5 id="single-value-comparison-20"><a class="header" href="#single-value-comparison-20">Single value comparison:</a></h5>
<pre><code>icmp_id:[<|>|=|!|<=|>=]<var style="color:slategrey;">icmp_id</var>;</code></pre>
<h5 id="range-comparison-21"><a class="header" href="#range-comparison-21">Range comparison:</a></h5>
<pre><code>icmp_id:<var style="color:slategrey;">icmp_id_min</var>{<>|<=>}<var style="color:slategrey;">icmp_id_max</var>;</code></pre>
<h4 id="examples-123"><a class="header" href="#examples-123">Examples:</a></h4>
<pre><code class="language-snort"># Check for an ICMP ID value of 0 
icmp_id:0;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="icmp_seq"><a class="header" href="#icmp_seq">icmp_seq</a></h1>
<p>The <code>icmp_seq</code> rule option is used to check that an ICMP sequence value is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value. This rule option can also check that ICMP Sequence value is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<h4 id="format-124"><a class="header" href="#format-124">Format:</a></h4>
<h5 id="single-value-comparison-21"><a class="header" href="#single-value-comparison-21">Single value comparison:</a></h5>
<pre><code>icmp_seq:[<|>|=|!|<=|>=]<var style="color:slategrey;">icmp_seq</var>;</code></pre>
<h5 id="range-comparison-22"><a class="header" href="#range-comparison-22">Range comparison:</a></h5>
<pre><code>icmp_seq:<var style="color:slategrey;">icmp_seq_min</var>{<>|<=>}<var style="color:slategrey;">icmp_seq_max</var>;</code></pre>
<h4 id="examples-124"><a class="header" href="#examples-124">Examples:</a></h4>
<pre><code class="language-snort"># Check for an ICMP sequence value of 0
icmp_seq:0;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rpc"><a class="header" href="#rpc">rpc</a></h1>
<p>The <code>rpc</code> rule option is used to look for specific RPC application/program numbers, version numbers, and procedure numbers in SUNRPC CALL requests. The RPC application number is a required argument, but the version and procedure numbers are optional. Rule writers can either specify specific version and procedure numbers, or they can use the <code>*</code> character to look for any version number or any procedure number.</p>
<h4 id="format-125"><a class="header" href="#format-125">Format:</a></h4>
<pre><code>rpc:<var style="color:slategrey;">application_number</var>[,{<var style="color:slategrey;">version_number</var>|*}][,{<var style="color:slategrey;">procedure_number</var>|*}];</code></pre>
<h4 id="examples-125"><a class="header" href="#examples-125">Examples:</a></h4>
<pre><code class="language-snort"># Look for the 100000 application number, any version number,
# and procedure number 3
rpc:100000, *, 3;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="stream_reassemble"><a class="header" href="#stream_reassemble">stream_reassemble</a></h1>
<p>The <code>stream_reassemble</code> rule option is used to enable or disable TCP stream reassembly on matching traffic. </p>
<p>This rule option takes two required arguments: (1) whether to enable or disable stream reassembly and (2) whether the action applies to client traffic, server traffic, or both client and server traffic. Rule writers can have two optional arguments to choose from: (1) <code>noalert</code> to prevent alerting on matching traffic and (2) <code>fastpath</code> to ingore the rest of the session.</p>
<h4 id="format-126"><a class="header" href="#format-126">Format:</a></h4>
<pre><code>stream_reassemble:action {enable|disable}, direction {server|client|both} \
                  [, noalert][, fastpath];
</code></pre>
<h4 id="example-7"><a class="header" href="#example-7">Example:</a></h4>
<pre><code class="language-snort">flow:to_client,established;
content:&quot;ABCDEF&quot;;
# this will disable stream reassembly on client traffic when 
# &quot;ABCDEF&quot; is seen in server response traffic and will also
# prevent the rule from generating an alert
stream_reassemble:action disable, direction client, noalert;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="stream_size"><a class="header" href="#stream_size">stream_size</a></h1>
<p>The <code>stream_size</code> rule option is used to check the stream size of a given TCP session.</p>
<p>Rule writers can check whether the <code>stream_size</code> is less than, greater than, equal to, not equal to, less than or equal to, or greater than or equal to a specified integer value, or they can check that the window number is between a range of numbers, using the <code>&lt;&gt;</code> range operator for an exclusive range check or the <code>&lt;=&gt;</code> for an inclusive one.</p>
<p>By default, the specified value gets checked against both the client and server's TCP sequence numbers, marking it as a &quot;match&quot; if either check passes. However, rule writers can also specify that the <code>stream_size</code> apply only to TCP sequence numbers from the server, client, or both server and client. This is done by placing a comma at the end of the argument followed by one of four possible options: <code>either</code>, <code>to_server</code>, <code>to_client</code>, and <code>both</code>.</p>
<h4 id="format-127"><a class="header" href="#format-127">Format:</a></h4>
<h5 id="single-value-comparison-22"><a class="header" href="#single-value-comparison-22">Single value comparison:</a></h5>
<pre><code>stream_size:[<|>|=|!|<=|>=]<var style="color:slategrey;">bytes</var>[,{either|to_server|to_client|both}];</code></pre>
<h5 id="range-comparison-23"><a class="header" href="#range-comparison-23">Range comparison:</a></h5>
<pre><code>stream_size:<var style="color:slategrey;">min_bytes</var>{<>|<=>}<var style="color:slategrey;">max_bytes</var>[,{either|to_server|to_client|both}];</code></pre>
<h4 id="examples-126"><a class="header" href="#examples-126">Examples:</a></h4>
<pre><code class="language-snort"># Look for sessions containg traffic to the server where the 
# stream size is equal to 125 bytes
stream_size:=125,to_server;
</code></pre>
<pre><code class="language-snort"># Look for sessions where the stream size values from both
# the client and server are between 0 and 100 bytes (exclusive)
stream_size:0&lt;&gt;100,both;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="post-detection-rule-options"><a class="header" href="#post-detection-rule-options">Post-Detection Rule Options</a></h1>
<p>Post-detection rule options are specific triggers that happen after a rule has &quot;fired&quot;. All post-detection options are discussed in the next few sections, but a quick reference of them all can be found below.</p>
<h4 id="quick-reference-3"><a class="header" href="#quick-reference-3">Quick Reference</a></h4>
<table><thead><tr><th>keyword</th><th>description</th></tr></thead><tbody>
<tr><td><a href="rules/options/post/detection_filter.htm">detection_filter</a></td><td><code>detection_filter</code> sets the rate in which the rule must hit before an event gets generated</td></tr>
<tr><td><a href="rules/options/post/replace.htm">replace</a></td><td><code>replace</code> is used to match and then overwrite payload data</td></tr>
<tr><td><a href="rules/options/post/tag.htm">tag</a></td><td><code>tag</code> is used to log additional packets after a rule event</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="detection_filter"><a class="header" href="#detection_filter">detection_filter</a></h1>
<p>The <code>detection_filter</code> option is used to require multiple rule hits before generating an &quot;event&quot;. Rule writers use this option to define a rate (count per seconds) that must be exceeded by a source or destination host before a rule can generate an event.</p>
<p>This option is used by declaring three things: (1) whether to track from a source or destination host, (2) the maximum number of rule matches in <code>s</code> seconds allowed before the detection filter limit is exceeded, and (3) the period over which the count is accrued. </p>
<p>Snort evaluates a <code>detection_filter</code> option last, after evaluating all other rule options (regardless of the position of the filter within the rule source). Only one <code>detection_filter</code> option is permitted per rule.</p>
<h4 id="format-128"><a class="header" href="#format-128">Format:</a></h4>
<pre><code>detection_filter:track {by_src|by_dst}, count <var style="color:slategrey;">c</var>, seconds <var style="color:slategrey;">s</var>;</code></pre>
<h4 id="examples-127"><a class="header" href="#examples-127">Examples:</a></h4>
<pre><code class="language-snort"># this rule looks for 30 SSH login attempts occurring
# in 60 seconds from a single source IP
flow:established,to_server;
content:&quot;SSH&quot;,nocase,offset 0,depth 4;
detection_filter:track by_src, count 30, seconds 60;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="replace"><a class="header" href="#replace">replace</a></h1>
<p>The <code>replace</code> rule option is used to overwrite prior matching content with the string provided to the option. This option should be used with the <code>rewrite</code> rule action, and it works for raw packets only.</p>
<h4 id="format-129"><a class="header" href="#format-129">Format:</a></h4>
<pre><code>replace:"<var style="color:slategrey;">string</var>";</code></pre>
<h4 id="examples-128"><a class="header" href="#examples-128">Examples:</a></h4>
<pre><code class="language-snort">content:&quot;ABCD&quot;;
replace:&quot;EFGH&quot;;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tag"><a class="header" href="#tag">tag</a></h1>
<p>The <code>tag</code> rule option is used to tell Snort to continue to log additional packets or bytes following a rule &quot;event&quot;. Rule writers can specify whether to tag packets or bytes seen from both the source host and destination host, just the source host, or just the destination host. Furthermore, they can also control whether to log a certain number of packets or bytes, or to log all packets occurring over a specified number of seconds.</p>
<p>This rule option requires two arguments: (1) the tag type that defines from whom to log the packets and (2) the number of packets or bytes to log or the number of seconds to log for. </p>
<h4 id="format-130"><a class="header" href="#format-130">Format:</a></h4>
<pre><code>tag:{session|host_src|host_dst}, {packets <var style="color:slategrey;">packets</var>|seconds <var style="color:slategrey;">seconds</var>|bytes <var style="color:slategrey;">bytes</var>};</code></pre>
<h4 id="examples-129"><a class="header" href="#examples-129">Examples:</a></h4>
<pre><code class="language-snort"># tag the next 10 packets from the entire session
tag:session, packets 10;
</code></pre>
<pre><code class="language-snort"># tag the next 4000 bytes from the source IP address of the
# packet that generated the initial event
tag:host_src, bytes 4000;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="shared-object-rules"><a class="header" href="#shared-object-rules">Shared Object Rules</a></h1>
<p>Shared object rules are written in C++ and loaded by Snort at runtime.</p>
<p>The following is a simple Snort3 SO rule example:</p>
<pre><code class="language-C++">#include &quot;main/snort_types.h&quot;
#include &quot;framework/so_rule.h&quot;

using namespace snort;

static const char* rule_1337 = R&quot;[Snort_SO_Rule](
alert tcp any any -&gt; any any (
    msg:&quot;SERVER-OTHER SO Example&quot;;
    soid:1337;
    flow:to_server,established;
    content:&quot;foo&quot;,nocase;
    so:eval;
    gid:3;
    sid:1337;
)
)[Snort_SO_Rule]&quot;;

static const unsigned rule_1337_len = 0;

static IpsOption::EvalStatus rule_1337_eval(void*, Cursor&amp;, Packet*)
{
    return IpsOption::MATCH;
}

static SoEvalFunc rule_1337_ctor(const char* /*so*/, void** pv)
{
    *pv = nullptr;
    return rule_1337_eval;
}

static const SoApi so_1337 =
{
    {
        PT_SO_RULE,
        sizeof(SoApi),
        SOAPI_VERSION,
        0, // version
        API_RESERVED,
        API_OPTIONS,
        &quot;1337&quot;,
        &quot;SERVER-OTHER SO Example&quot;,
        nullptr,
        nullptr
    },
    (uint8_t*)rule_1337,
    rule_1337_len,
    nullptr,        // pinit
    nullptr,        // pterm
    nullptr,        // tinit
    nullptr,        // tterm
    rule_1337_ctor, // ctor
    nullptr         // dtor
};

const BaseApi* pso_1337 = &amp;so_1337.base;

SO_PUBLIC const BaseApi* snort_plugins[] =
{
    pso_1337,
    nullptr
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    <script defer="" src="beacon.min.js/v84a3a4012de94ce1a686ba8c167c359c1696973893317" integrity="sha512-euoFGowhlaLqXsPWQ48qSkBSCFs3DPRyiwVu3FjR96cMPx+Fr+gpWRhIafcHwqwCqWS42RZhIudOvEI+Ckf6MA==" data-cf-beacon='{"rayId":"847db18b0d0cd97b","b":1,"version":"2024.1.0","token":"259dc4eadf5b43fbbc95b1d26ba39d7c"}' crossorigin="anonymous"></script>
</body>
</html>
